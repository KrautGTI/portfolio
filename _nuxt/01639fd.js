/*! For license information please see LICENSES */
(window.webpackJsonp = window.webpackJsonp || []).push([
    [25],
    [function(t, e, n) {
        "use strict";

        function r(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function o(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
        }
        n.d(e, "b", (function() {
            return en
        })), n.d(e, "d", (function() {
            return An
        })), n.d(e, "z", (function() {
            return Rn
        })), n.d(e, "c", (function() {
            return Pn
        })), n.d(e, "a", (function() {
            return Dn
        })), n.d(e, "y", (function() {
            return ge
        })), n.d(e, "k", (function() {
            return Dt
        })), n.d(e, "p", (function() {
            return ct
        })), n.d(e, "q", (function() {
            return ut
        })), n.d(e, "m", (function() {
            return J
        })), n.d(e, "n", (function() {
            return tt
        })), n.d(e, "t", (function() {
            return bn
        })), n.d(e, "s", (function() {
            return pt
        })), n.d(e, "i", (function() {
            return Ot
        })), n.d(e, "w", (function() {
            return En
        })), n.d(e, "g", (function() {
            return He
        })), n.d(e, "u", (function() {
            return Ae
        })), n.d(e, "e", (function() {
            return ln
        })), n.d(e, "r", (function() {
            return Et
        })), n.d(e, "x", (function() {
            return je
        })), n.d(e, "h", (function() {
            return U
        })), n.d(e, "v", (function() {
            return It
        })), n.d(e, "o", (function() {
            return _t
        })), n.d(e, "l", (function() {
            return yn
        })), n.d(e, "j", (function() {
            return Pt
        })), n.d(e, "f", (function() {
            return Be
        }));
        var l, c, h, d, f, m, v, y, _, x, w, M, S, T, E, A, C, L, k, R, P, D, O, I, N, F, z, B, U = {
                autoSleep: 120,
                force3D: "auto",
                nullTargetWarn: 1,
                units: {
                    lineHeight: ""
                }
            },
            H = {
                duration: .5,
                overwrite: !1,
                delay: 0
            },
            j = 1e8,
            V = 1e-8,
            G = 2 * Math.PI,
            W = G / 4,
            X = 0,
            $ = Math.sqrt,
            Y = Math.cos,
            Z = Math.sin,
            J = function(t) {
                return "string" == typeof t
            },
            K = function(t) {
                return "function" == typeof t
            },
            Q = function(t) {
                return "number" == typeof t
            },
            tt = function(t) {
                return void 0 === t
            },
            et = function(t) {
                return "object" == typeof t
            },
            nt = function(t) {
                return !1 !== t
            },
            it = function() {
                return "undefined" != typeof window
            },
            ot = function(t) {
                return K(t) || J(t)
            },
            at = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
            st = Array.isArray,
            lt = /(?:-?\.?\d|\.)+/gi,
            ct = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
            ut = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
            ht = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
            pt = /[+-]=-?[.\d]+/,
            ft = /[^,'"\[\]\s]+/gi,
            mt = /[\d.+\-=]+(?:e[-+]\d*)*/i,
            gt = {},
            vt = {},
            yt = function(t) {
                return (vt = Vt(t, gt)) && Rn
            },
            _t = function(t, e) {
                return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
            },
            xt = function(t, e) {
                return !e && console.warn(t)
            },
            bt = function(t, e) {
                return t && (gt[t] = e) && vt && (vt[t] = e) || gt
            },
            wt = function() {
                return 0
            },
            Mt = {},
            St = [],
            Tt = {},
            Et = {},
            At = {},
            Ct = 30,
            Lt = [],
            kt = "",
            Rt = function(t) {
                var e, i, n = t[0];
                if (et(n) || K(n) || (t = [t]), !(e = (n._gsap || {}).harness)) {
                    for (i = Lt.length; i-- && !Lt[i].targetTest(n););
                    e = Lt[i]
                }
                for (i = t.length; i--;) t[i] && (t[i]._gsap || (t[i]._gsap = new en(t[i], e))) || t.splice(i, 1);
                return t
            },
            Pt = function(t) {
                return t._gsap || Rt(xe(t))[0]._gsap
            },
            Dt = function(t, e, n) {
                return (n = t[e]) && K(n) ? t[e]() : tt(n) && t.getAttribute && t.getAttribute(e) || n
            },
            Ot = function(t, e) {
                return (t = t.split(",")).forEach(e) || t
            },
            It = function(t) {
                return Math.round(1e5 * t) / 1e5 || 0
            },
            Nt = function(t, e) {
                for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;);
                return i < n
            },
            Ft = function() {
                var i, t, e = St.length,
                    a = St.slice(0);
                for (Tt = {}, St.length = 0, i = 0; i < e; i++)(t = a[i]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
            },
            zt = function(t, time, e, n) {
                St.length && Ft(), t.render(time, e, n), St.length && Ft()
            },
            Bt = function(t) {
                var e = parseFloat(t);
                return (e || 0 === e) && (t + "").match(ft).length < 2 ? e : J(t) ? t.trim() : t
            },
            Ut = function(p) {
                return p
            },
            Ht = function(t, e) {
                for (var p in e) p in t || (t[p] = e[p]);
                return t
            },
            jt = function(t, e) {
                for (var p in e) p in t || "duration" === p || "ease" === p || (t[p] = e[p])
            },
            Vt = function(base, t) {
                for (var p in t) base[p] = t[p];
                return base
            },
            Gt = function t(base, e) {
                for (var p in e) "__proto__" !== p && "constructor" !== p && "prototype" !== p && (base[p] = et(e[p]) ? t(base[p] || (base[p] = {}), e[p]) : e[p]);
                return base
            },
            Wt = function(t, e) {
                var p, n = {};
                for (p in t) p in e || (n[p] = t[p]);
                return n
            },
            qt = function(t) {
                var e = t.parent || c,
                    n = t.keyframes ? jt : Ht;
                if (nt(t.inherit))
                    for (; e;) n(t, e.vars.defaults), e = e.parent || e._dp;
                return t
            },
            Xt = function(t, e, n, r) {
                void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
                var o = e._prev,
                    l = e._next;
                o ? o._next = l : t[n] === e && (t[n] = l), l ? l._prev = o : t[r] === e && (t[r] = o), e._next = e._prev = e.parent = null
            },
            $t = function(t, e) {
                t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0
            },
            Yt = function(t, e) {
                if (t && (!e || e._end > t._dur || e._start < 0))
                    for (var a = t; a;) a._dirty = 1, a = a.parent;
                return t
            },
            Zt = function(t) {
                for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                return t
            },
            Jt = function t(e) {
                return !e || e._ts && t(e.parent)
            },
            Kt = function(t) {
                return t._repeat ? Qt(t._tTime, t = t.duration() + t._rDelay) * t : 0
            },
            Qt = function(t, e) {
                var n = Math.floor(t /= e);
                return t && n === t ? n - 1 : n
            },
            te = function(t, e) {
                return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
            },
            ee = function(t) {
                return t._end = It(t._start + (t._tDur / Math.abs(t._ts || t._rts || V) || 0))
            },
            ne = function(t, e) {
                var n = t._dp;
                return n && n.smoothChildTiming && t._ts && (t._start = It(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), ee(t), n._dirty || Yt(n, t)), t
            },
            re = function(t, e) {
                var n;
                if ((e._time || e._initted && !e._dur) && (n = te(t.rawTime(), e), (!e._dur || me(0, e.totalDuration(), n) - e._tTime > V) && e.render(n, !0)), Yt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                    if (t._dur < t.duration())
                        for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                    t._zTime = -1e-8
                }
            },
            ie = function(t, e, n, r) {
                return e.parent && $t(e), e._start = It((Q(n) ? n : n || t !== c ? de(t, n, e) : t._time) + e._delay), e._end = It(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
                    function(t, e, n, r, o) {
                        void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
                        var l, c = t[r];
                        if (o)
                            for (l = e[o]; c && c[o] > l;) c = c._prev;
                        c ? (e._next = c._next, c._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[r] = e, e._prev = c, e.parent = e._dp = t
                    }(t, e, "_first", "_last", t._sort ? "_start" : 0), le(e) || (t._recent = e), r || re(t, e), t
            },
            oe = function(t, e) {
                return (gt.ScrollTrigger || _t("scrollTrigger", e)) && gt.ScrollTrigger.create(e, t)
            },
            ae = function(t, e, n, r) {
                return cn(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && v !== je.frame ? (St.push(t), t._lazy = [e, r], 1) : void 0 : 1
            },
            se = function t(e) {
                var n = e.parent;
                return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
            },
            le = function(t) {
                var data = t.data;
                return "isFromStart" === data || "isStart" === data
            },
            ce = function(t, e, n, r) {
                var o = t._repeat,
                    l = It(e) || 0,
                    c = t._tTime / t._tDur;
                return c && !r && (t._time *= l / t._dur), t._dur = l, t._tDur = o ? o < 0 ? 1e10 : It(l * (o + 1) + t._rDelay * o) : l, c && !r ? ne(t, t._tTime = t._tDur * c) : t.parent && ee(t), n || Yt(t.parent, t), t
            },
            ue = function(t) {
                return t instanceof rn ? Yt(t) : ce(t, t._dur)
            },
            he = {
                _start: 0,
                endTime: wt,
                totalDuration: wt
            },
            de = function t(e, n, r) {
                var i, o, l, c = e.labels,
                    h = e._recent || he,
                    d = e.duration() >= j ? h.endTime(!1) : e._dur;
                return J(n) && (isNaN(n) || n in c) ? (o = n.charAt(0), l = "%" === n.substr(-1), i = n.indexOf("="), "<" === o || ">" === o ? (i >= 0 && (n = n.replace(/=/, "")), ("<" === o ? h._start : h.endTime(h._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (l ? (i < 0 ? h : r).totalDuration() / 100 : 1)) : i < 0 ? (n in c || (c[n] = d), c[n]) : (o = parseFloat(n.charAt(i - 1) + n.substr(i + 1)), l && r && (o = o / 100 * (st(r) ? r[0] : r).totalDuration()), i > 1 ? t(e, n.substr(0, i - 1), r) + o : d + o)) : null == n ? d : +n
            },
            pe = function(t, e, n) {
                var r, o, l = Q(e[1]),
                    c = (l ? 2 : 1) + (t < 2 ? 0 : 1),
                    h = e[c];
                if (l && (h.duration = e[1]), h.parent = n, t) {
                    for (r = h, o = n; o && !("immediateRender" in r);) r = o.vars.defaults || {}, o = nt(o.vars.inherit) && o.parent;
                    h.immediateRender = nt(r.immediateRender), t < 2 ? h.runBackwards = 1 : h.startAt = e[c - 1]
                }
                return new pn(e[0], h, e[c + 1])
            },
            fe = function(t, e) {
                return t || 0 === t ? e(t) : e
            },
            me = function(t, e, n) {
                return n < t ? t : n > e ? e : n
            },
            ge = function(t) {
                if ("string" != typeof t) return "";
                var e = mt.exec(t);
                return e ? t.substr(e.index + e[0].length) : ""
            },
            ve = [].slice,
            ye = function(t, e) {
                return t && et(t) && "length" in t && (!e && !t.length || t.length - 1 in t && et(t[0])) && !t.nodeType && t !== h
            },
            _e = function(t, e, n) {
                return void 0 === n && (n = []), t.forEach((function(t) {
                    var r;
                    return J(t) && !e || ye(t, 1) ? (r = n).push.apply(r, xe(t)) : n.push(t)
                })) || n
            },
            xe = function(t, e, n) {
                return !J(t) || n || !d && Ve() ? st(t) ? _e(t, n) : ye(t) ? ve.call(t, 0) : t ? [t] : [] : ve.call((e || f).querySelectorAll(t), 0)
            },
            be = function(a) {
                return a.sort((function() {
                    return .5 - Math.random()
                }))
            },
            we = function(t) {
                if (K(t)) return t;
                var e = et(t) ? t : {
                        each: t
                    },
                    n = Ze(e.ease),
                    r = e.from || 0,
                    base = parseFloat(e.base) || 0,
                    o = {},
                    l = r > 0 && r < 1,
                    c = isNaN(r) || l,
                    h = e.axis,
                    d = r,
                    f = r;
                return J(r) ? d = f = {
                        center: .5,
                        edges: .5,
                        end: 1
                    }[r] || 0 : !l && c && (d = r[0], f = r[1]),
                    function(i, t, a) {
                        var l, m, v, y, _, x, w, M, S, T = (a || e).length,
                            E = o[T];
                        if (!E) {
                            if (!(S = "auto" === e.grid ? 0 : (e.grid || [1, j])[1])) {
                                for (w = -j; w < (w = a[S++].getBoundingClientRect().left) && S < T;);
                                S--
                            }
                            for (E = o[T] = [], l = c ? Math.min(S, T) * d - .5 : r % S, m = c ? T * f / S - .5 : r / S | 0, w = 0, M = j, x = 0; x < T; x++) v = x % S - l, y = m - (x / S | 0), E[x] = _ = h ? Math.abs("y" === h ? y : v) : $(v * v + y * y), _ > w && (w = _), _ < M && (M = _);
                            "random" === r && be(E), E.max = w - M, E.min = M, E.v = T = (parseFloat(e.amount) || parseFloat(e.each) * (S > T ? T - 1 : h ? "y" === h ? T / S : S : Math.max(S, T / S)) || 0) * ("edges" === r ? -1 : 1), E.b = T < 0 ? base - T : base, E.u = ge(e.amount || e.each) || 0, n = n && T < 0 ? $e(n) : n
                        }
                        return T = (E[i] - E.min) / E.max || 0, It(E.b + (n ? n(T) : T) * E.v) + E.u
                    }
            },
            Me = function(t) {
                var p = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
                return function(e) {
                    var n = Math.round(parseFloat(e) / t) * t * p;
                    return (n - n % 1) / p + (Q(e) ? 0 : ge(e))
                }
            },
            Se = function(t, e) {
                var n, r, o = st(t);
                return !o && et(t) && (n = o = t.radius || j, t.values ? (t = xe(t.values), (r = !Q(t[0])) && (n *= n)) : t = Me(t.increment)), fe(e, o ? K(t) ? function(e) {
                    return r = t(e), Math.abs(r - e) <= n ? r : e
                } : function(e) {
                    for (var o, l, c = parseFloat(r ? e.x : e), h = parseFloat(r ? e.y : 0), d = j, f = 0, i = t.length; i--;)(o = r ? (o = t[i].x - c) * o + (l = t[i].y - h) * l : Math.abs(t[i] - c)) < d && (d = o, f = i);
                    return f = !n || d <= n ? t[f] : e, r || f === e || Q(e) ? f : f + ge(e)
                } : Me(t))
            },
            Te = function(t, e, n, r) {
                return fe(st(t) ? !e : !0 === n ? !!(n = 0) : !r, (function() {
                    return st(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * r) / r
                }))
            },
            Ee = function(a, t, e) {
                return fe(e, (function(e) {
                    return a[~~t(e)]
                }))
            },
            Ae = function(t) {
                for (var i, e, n, r, o = 0, s = ""; ~(i = t.indexOf("random(", o));) n = t.indexOf(")", i), r = "[" === t.charAt(i + 7), e = t.substr(i + 7, n - i - 7).match(r ? ft : lt), s += t.substr(o, i - o) + Te(r ? e : +e[0], r ? 0 : +e[1], +e[2] || 1e-5), o = n + 1;
                return s + t.substr(o, t.length - o)
            },
            Ce = function(t, e, n, r, o) {
                var l = e - t,
                    c = r - n;
                return fe(o, (function(e) {
                    return n + ((e - t) / l * c || 0)
                }))
            },
            Le = function(t, e, n) {
                var p, r, label, o = t.labels,
                    l = j;
                for (p in o)(r = o[p] - e) < 0 == !!n && r && l > (r = Math.abs(r)) && (label = p, l = r);
                return label
            },
            ke = function(t, e, n) {
                var r, o, l = t.vars,
                    c = l[e];
                if (c) return r = l[e + "Params"], o = l.callbackScope || t, n && St.length && Ft(), r ? c.apply(o, r) : c.call(o)
            },
            Re = function(t) {
                return $t(t), t.scrollTrigger && t.scrollTrigger.kill(!1), t.progress() < 1 && ke(t, "onInterrupt"), t
            },
            Pe = function(t) {
                var e = (t = !t.name && t.default || t).name,
                    n = K(t),
                    r = e && !n && t.init ? function() {
                        this._props = []
                    } : t,
                    o = {
                        init: wt,
                        render: wn,
                        add: sn,
                        kill: Sn,
                        modifier: Mn,
                        rawVars: 0
                    },
                    l = {
                        targetTest: 0,
                        get: 0,
                        getSetter: yn,
                        aliases: {},
                        register: 0
                    };
                if (Ve(), t !== r) {
                    if (Et[e]) return;
                    Ht(r, Ht(Wt(t, o), l)), Vt(r.prototype, Vt(o, Wt(t, l))), Et[r.prop = e] = r, t.targetTest && (Lt.push(r), Mt[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                }
                bt(e, r), t.register && t.register(Rn, r, An)
            },
            De = 255,
            Oe = {
                aqua: [0, De, De],
                lime: [0, De, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, De],
                navy: [0, 0, 128],
                white: [De, De, De],
                olive: [128, 128, 0],
                yellow: [De, De, 0],
                orange: [De, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [De, 0, 0],
                pink: [De, 192, 203],
                cyan: [0, De, De],
                transparent: [De, De, De, 0]
            },
            Ie = function(t, e, n) {
                return (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * De + .5 | 0
            },
            Ne = function(t, e, n) {
                var r, g, b, o, s, l, c, h, d, f, a = t ? Q(t) ? [t >> 16, t >> 8 & De, t & De] : 0 : Oe.black;
                if (!a) {
                    if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), Oe[t]) a = Oe[t];
                    else if ("#" === t.charAt(0)) {
                        if (t.length < 6 && (r = t.charAt(1), g = t.charAt(2), b = t.charAt(3), t = "#" + r + r + g + g + b + b + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(a = parseInt(t.substr(1, 6), 16)) >> 16, a >> 8 & De, a & De, parseInt(t.substr(7), 16) / 255];
                        a = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & De, t & De]
                    } else if ("hsl" === t.substr(0, 3))
                        if (a = f = t.match(lt), e) {
                            if (~t.indexOf("=")) return a = t.match(ct), n && a.length < 4 && (a[3] = 1), a
                        } else o = +a[0] % 360 / 360, s = +a[1] / 100, r = 2 * (l = +a[2] / 100) - (g = l <= .5 ? l * (s + 1) : l + s - l * s), a.length > 3 && (a[3] *= 1), a[0] = Ie(o + 1 / 3, r, g), a[1] = Ie(o, r, g), a[2] = Ie(o - 1 / 3, r, g);
                    else a = t.match(lt) || Oe.transparent;
                    a = a.map(Number)
                }
                return e && !f && (r = a[0] / De, g = a[1] / De, b = a[2] / De, l = ((c = Math.max(r, g, b)) + (h = Math.min(r, g, b))) / 2, c === h ? o = s = 0 : (d = c - h, s = l > .5 ? d / (2 - c - h) : d / (c + h), o = c === r ? (g - b) / d + (g < b ? 6 : 0) : c === g ? (b - r) / d + 2 : (r - g) / d + 4, o *= 60), a[0] = ~~(o + .5), a[1] = ~~(100 * s + .5), a[2] = ~~(100 * l + .5)), n && a.length < 4 && (a[3] = 1), a
            },
            Fe = function(t) {
                var e = [],
                    n = [],
                    i = -1;
                return t.split(Be).forEach((function(t) {
                    var a = t.match(ut) || [];
                    e.push.apply(e, a), n.push(i += a.length + 1)
                })), e.c = n, e
            },
            ze = function(s, t, e) {
                var n, r, o, l, c = "",
                    h = (s + c).match(Be),
                    d = t ? "hsla(" : "rgba(",
                    i = 0;
                if (!h) return s;
                if (h = h.map((function(e) {
                        return (e = Ne(e, t, 1)) && d + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
                    })), e && (o = Fe(s), (n = e.c).join(c) !== o.c.join(c)))
                    for (l = (r = s.replace(Be, "1").split(ut)).length - 1; i < l; i++) c += r[i] + (~n.indexOf(i) ? h.shift() || d + "0,0,0,0)" : (o.length ? o : h.length ? h : e).shift());
                if (!r)
                    for (l = (r = s.split(Be)).length - 1; i < l; i++) c += r[i] + h[i];
                return c + r[l]
            },
            Be = function() {
                var p, s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                for (p in Oe) s += "|" + p + "\\b";
                return new RegExp(s + ")", "gi")
            }(),
            Ue = /hsl[a]?\(/,
            He = function(a) {
                var t, e = a.join(" ");
                if (Be.lastIndex = 0, Be.test(e)) return t = Ue.test(e), a[1] = ze(a[1], t), a[0] = ze(a[0], t, Fe(a[1])), !0
            },
            je = (A = Date.now, C = 500, L = 33, k = A(), R = k, D = P = 1e3 / 240, I = function t(e) {
                var n, r, time, o, l = A() - R,
                    c = !0 === e;
                if (l > C && (k += l - L), ((n = (time = (R += l) - k) - D) > 0 || c) && (o = ++S.frame, T = time - 1e3 * S.time, S.time = time /= 1e3, D += n + (n >= P ? 4 : P - n), r = 1), c || (x = w(t)), r)
                    for (E = 0; E < O.length; E++) O[E](time, T, o, e)
            }, S = {
                time: 0,
                frame: 0,
                tick: function() {
                    I(!0)
                },
                deltaRatio: function(t) {
                    return T / (1e3 / (t || 60))
                },
                wake: function() {
                    m && (!d && it() && (h = d = window, f = h.document || {}, gt.gsap = Rn, (h.gsapVersions || (h.gsapVersions = [])).push(Rn.version), yt(vt || h.GreenSockGlobals || !h.gsap && h || {}), M = h.requestAnimationFrame), x && S.sleep(), w = M || function(t) {
                        return setTimeout(t, D - 1e3 * S.time + 1 | 0)
                    }, _ = 1, I(2))
                },
                sleep: function() {
                    (M ? h.cancelAnimationFrame : clearTimeout)(x), _ = 0, w = wt
                },
                lagSmoothing: function(t, e) {
                    C = t || 1e8, L = Math.min(e, C, 0)
                },
                fps: function(t) {
                    P = 1e3 / (t || 240), D = 1e3 * S.time + P
                },
                add: function(t) {
                    O.indexOf(t) < 0 && O.push(t), Ve()
                },
                remove: function(t) {
                    var i;
                    ~(i = O.indexOf(t)) && O.splice(i, 1) && E >= i && E--
                },
                _listeners: O = []
            }),
            Ve = function() {
                return !_ && je.wake()
            },
            Ge = {},
            We = /^[\d.\-M][\d.\-,\s]/,
            qe = /["']/g,
            Xe = function(t) {
                for (var e, n, r, o = {}, l = t.substr(1, t.length - 3).split(":"), c = l[0], i = 1, h = l.length; i < h; i++) n = l[i], e = i !== h - 1 ? n.lastIndexOf(",") : n.length, r = n.substr(0, e), o[c] = isNaN(r) ? r.replace(qe, "").trim() : +r, c = n.substr(e + 1).trim();
                return o
            },
            $e = function(t) {
                return function(p) {
                    return 1 - t(1 - p)
                }
            },
            Ye = function t(e, n) {
                for (var r, o = e._first; o;) o instanceof rn ? t(o, n) : !o.vars.yoyoEase || o._yoyo && o._repeat || o._yoyo === n || (o.timeline ? t(o.timeline, n) : (r = o._ease, o._ease = o._yEase, o._yEase = r, o._yoyo = n)), o = o._next
            },
            Ze = function(t, e) {
                return t && (K(t) ? t : Ge[t] || function(t) {
                    var e, n, r, o, l = (t + "").split("("),
                        c = Ge[l[0]];
                    return c && l.length > 1 && c.config ? c.config.apply(null, ~t.indexOf("{") ? [Xe(l[1])] : (e = t, n = e.indexOf("(") + 1, r = e.indexOf(")"), o = e.indexOf("(", n), e.substring(n, ~o && o < r ? e.indexOf(")", r + 1) : r)).split(",").map(Bt)) : Ge._CE && We.test(t) ? Ge._CE("", t) : c
                }(t)) || e
            },
            Je = function(t, e, n, r) {
                void 0 === n && (n = function(p) {
                    return 1 - e(1 - p)
                }), void 0 === r && (r = function(p) {
                    return p < .5 ? e(2 * p) / 2 : 1 - e(2 * (1 - p)) / 2
                });
                var o, l = {
                    easeIn: e,
                    easeOut: n,
                    easeInOut: r
                };
                return Ot(t, (function(t) {
                    for (var p in Ge[t] = gt[t] = l, Ge[o = t.toLowerCase()] = n, l) Ge[o + ("easeIn" === p ? ".in" : "easeOut" === p ? ".out" : ".inOut")] = Ge[t + "." + p] = l[p]
                })), l
            },
            Ke = function(t) {
                return function(p) {
                    return p < .5 ? (1 - t(1 - 2 * p)) / 2 : .5 + t(2 * (p - .5)) / 2
                }
            },
            Qe = function t(e, n, r) {
                var o = n >= 1 ? n : 1,
                    l = (r || (e ? .3 : .45)) / (n < 1 ? n : 1),
                    c = l / G * (Math.asin(1 / o) || 0),
                    h = function(p) {
                        return 1 === p ? 1 : o * Math.pow(2, -10 * p) * Z((p - c) * l) + 1
                    },
                    d = "out" === e ? h : "in" === e ? function(p) {
                        return 1 - h(1 - p)
                    } : Ke(h);
                return l = G / l, d.config = function(n, r) {
                    return t(e, n, r)
                }, d
            },
            tn = function t(e, n) {
                void 0 === n && (n = 1.70158);
                var r = function(p) {
                        return p ? --p * p * ((n + 1) * p + n) + 1 : 0
                    },
                    o = "out" === e ? r : "in" === e ? function(p) {
                        return 1 - r(1 - p)
                    } : Ke(r);
                return o.config = function(n) {
                    return t(e, n)
                }, o
            };
        Ot("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, i) {
            var e = i < 5 ? i + 1 : i;
            Je(t + ",Power" + (e - 1), i ? function(p) {
                return Math.pow(p, e)
            } : function(p) {
                return p
            }, (function(p) {
                return 1 - Math.pow(1 - p, e)
            }), (function(p) {
                return p < .5 ? Math.pow(2 * p, e) / 2 : 1 - Math.pow(2 * (1 - p), e) / 2
            }))
        })), Ge.Linear.easeNone = Ge.none = Ge.Linear.easeIn, Je("Elastic", Qe("in"), Qe("out"), Qe()), N = 7.5625, z = 1 / (F = 2.75), Je("Bounce", (function(p) {
            return 1 - B(1 - p)
        }), B = function(p) {
            return p < z ? N * p * p : p < .7272727272727273 ? N * Math.pow(p - 1.5 / F, 2) + .75 : p < .9090909090909092 ? N * (p -= 2.25 / F) * p + .9375 : N * Math.pow(p - 2.625 / F, 2) + .984375
        }), Je("Expo", (function(p) {
            return p ? Math.pow(2, 10 * (p - 1)) : 0
        })), Je("Circ", (function(p) {
            return -($(1 - p * p) - 1)
        })), Je("Sine", (function(p) {
            return 1 === p ? 1 : 1 - Y(p * W)
        })), Je("Back", tn("in"), tn("out"), tn()), Ge.SteppedEase = Ge.steps = gt.SteppedEase = {
            config: function(t, e) {
                void 0 === t && (t = 1);
                var n = 1 / t,
                    r = t + (e ? 0 : 1),
                    o = e ? 1 : 0;
                return function(p) {
                    return ((r * me(0, .99999999, p) | 0) + o) * n
                }
            }
        }, H.ease = Ge["quad.out"], Ot("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
            return kt += t + "," + t + "Params,"
        }));
        var en = function(t, e) {
                this.id = X++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : Dt, this.set = e ? e.getSetter : yn
            },
            nn = function() {
                function t(t) {
                    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, ce(this, +t.duration, 1, 1), this.data = t.data, _ || je.wake()
                }
                var e = t.prototype;
                return e.delay = function(t) {
                    return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
                }, e.duration = function(t) {
                    return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
                }, e.totalDuration = function(t) {
                    return arguments.length ? (this._dirty = 0, ce(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                }, e.totalTime = function(t, e) {
                    if (Ve(), !arguments.length) return this._tTime;
                    var n = this._dp;
                    if (n && n.smoothChildTiming && this._ts) {
                        for (ne(this, t), !n._dp || n.parent || re(n, this); n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && ie(this._dp, this, this._start - this._delay)
                    }
                    return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === V || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), zt(this, t, e)), this
                }, e.time = function(t, e) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Kt(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
                }, e.totalProgress = function(t, e) {
                    return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
                }, e.progress = function(t, e) {
                    return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Kt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
                }, e.iteration = function(t, e) {
                    var n = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Qt(this._tTime, n) + 1 : 1
                }, e.timeScale = function(t) {
                    if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                    if (this._rts === t) return this;
                    var e = this.parent && this._ts ? te(this.parent._time, this) : this._tTime;
                    return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, Zt(this.totalTime(me(-this._delay, this._tDur, e), !0))
                }, e.paused = function(t) {
                    return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Ve(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== V && (this._tTime -= V)))), this) : this._ps
                }, e.startTime = function(t) {
                    if (arguments.length) {
                        this._start = t;
                        var e = this.parent || this._dp;
                        return e && (e._sort || !this.parent) && ie(e, this, t - this._delay), this
                    }
                    return this._start
                }, e.endTime = function(t) {
                    return this._start + (nt(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
                }, e.rawTime = function(t) {
                    var e = this.parent || this._dp;
                    return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? te(e.rawTime(t), this) : this._tTime : this._tTime
                }, e.globalTime = function(t) {
                    for (var e = this, time = arguments.length ? t : e.rawTime(); e;) time = e._start + time / (e._ts || 1), e = e._dp;
                    return time
                }, e.repeat = function(t) {
                    return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, ue(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                }, e.repeatDelay = function(t) {
                    if (arguments.length) {
                        var time = this._time;
                        return this._rDelay = t, ue(this), time ? this.time(time) : this
                    }
                    return this._rDelay
                }, e.yoyo = function(t) {
                    return arguments.length ? (this._yoyo = t, this) : this._yoyo
                }, e.seek = function(t, e) {
                    return this.totalTime(de(this, t), nt(e))
                }, e.restart = function(t, e) {
                    return this.play().totalTime(t ? -this._delay : 0, nt(e))
                }, e.play = function(t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, e.reverse = function(t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, e.pause = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, e.resume = function() {
                    return this.paused(!1)
                }, e.reversed = function(t) {
                    return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
                }, e.invalidate = function() {
                    return this._initted = this._act = 0, this._zTime = -1e-8, this
                }, e.isActive = function() {
                    var t, e = this.parent || this._dp,
                        n = this._start;
                    return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - V))
                }, e.eventCallback = function(t, e, n) {
                    var r = this.vars;
                    return arguments.length > 1 ? (e ? (r[t] = e, n && (r[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete r[t], this) : r[t]
                }, e.then = function(t) {
                    var e = this;
                    return new Promise((function(n) {
                        var r = K(t) ? t : Ut,
                            o = function() {
                                var t = e.then;
                                e.then = null, K(r) && (r = r(e)) && (r.then || r === e) && (e.then = t), n(r), e.then = t
                            };
                        e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? o() : e._prom = o
                    }))
                }, e.kill = function() {
                    Re(this)
                }, t
            }();
        Ht(nn.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var rn = function(t) {
            function e(e, n) {
                var o;
                return void 0 === e && (e = {}), (o = t.call(this, e) || this).labels = {}, o.smoothChildTiming = !!e.smoothChildTiming, o.autoRemoveChildren = !!e.autoRemoveChildren, o._sort = nt(e.sortChildren), c && ie(e.parent || c, r(o), n), e.reversed && o.reverse(), e.paused && o.paused(!0), e.scrollTrigger && oe(r(o), e.scrollTrigger), o
            }
            o(e, t);
            var n = e.prototype;
            return n.to = function(t, e, n) {
                return pe(0, arguments, this), this
            }, n.from = function(t, e, n) {
                return pe(1, arguments, this), this
            }, n.fromTo = function(t, e, n, r) {
                return pe(2, arguments, this), this
            }, n.set = function(t, e, n) {
                return e.duration = 0, e.parent = this, qt(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new pn(t, e, de(this, n), 1), this
            }, n.call = function(t, e, n) {
                return ie(this, pn.delayedCall(0, t, e), n)
            }, n.staggerTo = function(t, e, n, r, o, l, c) {
                return n.duration = e, n.stagger = n.stagger || r, n.onComplete = l, n.onCompleteParams = c, n.parent = this, new pn(t, n, de(this, o)), this
            }, n.staggerFrom = function(t, e, n, r, o, l, c) {
                return n.runBackwards = 1, qt(n).immediateRender = nt(n.immediateRender), this.staggerTo(t, e, n, r, o, l, c)
            }, n.staggerFromTo = function(t, e, n, r, o, l, c, h) {
                return r.startAt = n, qt(r).immediateRender = nt(r.immediateRender), this.staggerTo(t, e, r, o, l, c, h)
            }, n.render = function(t, e, n) {
                var time, r, o, l, h, d, f, m, v, y, _, x, w = this._time,
                    M = this._dirty ? this.totalDuration() : this._tDur,
                    S = this._dur,
                    T = this !== c && t > M - V && t >= 0 ? M : t < V ? 0 : t,
                    E = this._zTime < 0 != t < 0 && (this._initted || !S);
                if (T !== this._tTime || n || E) {
                    if (w !== this._time && S && (T += this._time - w, t += this._time - w), time = T, v = this._start, d = !(m = this._ts), E && (S || (w = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) {
                        if (_ = this._yoyo, h = S + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * h + t, e, n);
                        if (time = It(T % h), T === M ? (l = this._repeat, time = S) : ((l = ~~(T / h)) && l === T / h && (time = S, l--), time > S && (time = S)), y = Qt(this._tTime, h), !w && this._tTime && y !== l && (y = l), _ && 1 & l && (time = S - time, x = 1), l !== y && !this._lock) {
                            var A = _ && 1 & y,
                                C = A === (_ && 1 & l);
                            if (l < y && (A = !A), w = A ? 0 : S, this._lock = 1, this.render(w || (x ? 0 : It(l * h)), e, !S)._lock = 0, this._tTime = T, !e && this.parent && ke(this, "onRepeat"), this.vars.repeatRefresh && !x && (this.invalidate()._lock = 1), w && w !== this._time || d !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                            if (S = this._dur, M = this._tDur, C && (this._lock = 2, w = A ? S : -1e-4, this.render(w, !0), this.vars.repeatRefresh && !x && this.invalidate()), this._lock = 0, !this._ts && !d) return this;
                            Ye(this, x)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (f = function(t, e, time) {
                            var n;
                            if (time > e)
                                for (n = t._first; n && n._start <= time;) {
                                    if (!n._dur && "isPause" === n.data && n._start > e) return n;
                                    n = n._next
                                } else
                                    for (n = t._last; n && n._start >= time;) {
                                        if (!n._dur && "isPause" === n.data && n._start < e) return n;
                                        n = n._prev
                                    }
                        }(this, It(w), It(time)), f && (T -= time - (time = f._start))), this._tTime = T, this._time = time, this._act = !m, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, w = 0), !w && time && !e && (ke(this, "onStart"), this._tTime !== T)) return this;
                    if (time >= w && t >= 0)
                        for (r = this._first; r;) {
                            if (o = r._next, (r._act || time >= r._start) && r._ts && f !== r) {
                                if (r.parent !== this) return this.render(t, e, n);
                                if (r.render(r._ts > 0 ? (time - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (time - r._start) * r._ts, e, n), time !== this._time || !this._ts && !d) {
                                    f = 0, o && (T += this._zTime = -1e-8);
                                    break
                                }
                            }
                            r = o
                        } else {
                            r = this._last;
                            for (var L = t < 0 ? t : time; r;) {
                                if (o = r._prev, (r._act || L <= r._end) && r._ts && f !== r) {
                                    if (r.parent !== this) return this.render(t, e, n);
                                    if (r.render(r._ts > 0 ? (L - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (L - r._start) * r._ts, e, n), time !== this._time || !this._ts && !d) {
                                        f = 0, o && (T += this._zTime = L ? -1e-8 : V);
                                        break
                                    }
                                }
                                r = o
                            }
                        }
                    if (f && !e && (this.pause(), f.render(time >= w ? 0 : -1e-8)._zTime = time >= w ? 1 : -1, this._ts)) return this._start = v, ee(this), this.render(t, e, n);
                    this._onUpdate && !e && ke(this, "onUpdate", !0), (T === M && M >= this.totalDuration() || !T && w) && (v !== this._start && Math.abs(m) === Math.abs(this._ts) || this._lock || ((t || !S) && (T === M && this._ts > 0 || !T && this._ts < 0) && $t(this, 1), e || t < 0 && !w || !T && !w && M || (ke(this, T === M && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(T < M && this.timeScale() > 0) && this._prom())))
                }
                return this
            }, n.add = function(t, e) {
                var n = this;
                if (Q(e) || (e = de(this, e, t)), !(t instanceof nn)) {
                    if (st(t)) return t.forEach((function(t) {
                        return n.add(t, e)
                    })), this;
                    if (J(t)) return this.addLabel(t, e);
                    if (!K(t)) return this;
                    t = pn.delayedCall(0, t)
                }
                return this !== t ? ie(this, t, e) : this
            }, n.getChildren = function(t, e, n, r) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === r && (r = -j);
                for (var a = [], o = this._first; o;) o._start >= r && (o instanceof pn ? e && a.push(o) : (n && a.push(o), t && a.push.apply(a, o.getChildren(!0, e, n)))), o = o._next;
                return a
            }, n.getById = function(t) {
                for (var e = this.getChildren(1, 1, 1), i = e.length; i--;)
                    if (e[i].vars.id === t) return e[i]
            }, n.remove = function(t) {
                return J(t) ? this.removeLabel(t) : K(t) ? this.killTweensOf(t) : (Xt(this, t), t === this._recent && (this._recent = this._last), Yt(this))
            }, n.totalTime = function(e, n) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = It(je.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
            }, n.addLabel = function(label, t) {
                return this.labels[label] = de(this, t), this
            }, n.removeLabel = function(label) {
                return delete this.labels[label], this
            }, n.addPause = function(t, e, n) {
                var r = pn.delayedCall(0, e || wt, n);
                return r.data = "isPause", this._hasPause = 1, ie(this, r, de(this, t))
            }, n.removePause = function(t) {
                var e = this._first;
                for (t = de(this, t); e;) e._start === t && "isPause" === e.data && $t(e), e = e._next
            }, n.killTweensOf = function(t, e, n) {
                for (var r = this.getTweensOf(t, n), i = r.length; i--;) on !== r[i] && r[i].kill(t, e);
                return this
            }, n.getTweensOf = function(t, e) {
                for (var n, a = [], r = xe(t), o = this._first, l = Q(e); o;) o instanceof pn ? Nt(o._targets, r) && (l ? (!on || o._initted && o._ts) && o.globalTime(0) <= e && o.globalTime(o.totalDuration()) > e : !e || o.isActive()) && a.push(o) : (n = o.getTweensOf(r, e)).length && a.push.apply(a, n), o = o._next;
                return a
            }, n.tweenTo = function(t, e) {
                e = e || {};
                var n, r = this,
                    o = de(r, t),
                    l = e,
                    c = l.startAt,
                    h = l.onStart,
                    d = l.onStartParams,
                    f = l.immediateRender,
                    m = pn.to(r, Ht({
                        ease: e.ease || "none",
                        lazy: !1,
                        immediateRender: !1,
                        time: o,
                        overwrite: "auto",
                        duration: e.duration || Math.abs((o - (c && "time" in c ? c.time : r._time)) / r.timeScale()) || V,
                        onStart: function() {
                            if (r.pause(), !n) {
                                var t = e.duration || Math.abs((o - (c && "time" in c ? c.time : r._time)) / r.timeScale());
                                m._dur !== t && ce(m, t, 0, 1).render(m._time, !0, !0), n = 1
                            }
                            h && h.apply(m, d || [])
                        }
                    }, e));
                return f ? m.render(0) : m
            }, n.tweenFromTo = function(t, e, n) {
                return this.tweenTo(e, Ht({
                    startAt: {
                        time: de(this, t)
                    }
                }, n))
            }, n.recent = function() {
                return this._recent
            }, n.nextLabel = function(t) {
                return void 0 === t && (t = this._time), Le(this, de(this, t))
            }, n.previousLabel = function(t) {
                return void 0 === t && (t = this._time), Le(this, de(this, t), 1)
            }, n.currentLabel = function(t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + V)
            }, n.shiftChildren = function(t, e, n) {
                void 0 === n && (n = 0);
                for (var p, r = this._first, o = this.labels; r;) r._start >= n && (r._start += t, r._end += t), r = r._next;
                if (e)
                    for (p in o) o[p] >= n && (o[p] += t);
                return Yt(this)
            }, n.invalidate = function() {
                var e = this._first;
                for (this._lock = 0; e;) e.invalidate(), e = e._next;
                return t.prototype.invalidate.call(this)
            }, n.clear = function(t) {
                void 0 === t && (t = !0);
                for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
                return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Yt(this)
            }, n.totalDuration = function(t) {
                var e, n, r, o = 0,
                    l = this,
                    h = l._last,
                    d = j;
                if (arguments.length) return l.timeScale((l._repeat < 0 ? l.duration() : l.totalDuration()) / (l.reversed() ? -t : t));
                if (l._dirty) {
                    for (r = l.parent; h;) e = h._prev, h._dirty && h.totalDuration(), (n = h._start) > d && l._sort && h._ts && !l._lock ? (l._lock = 1, ie(l, h, n - h._delay, 1)._lock = 0) : d = n, n < 0 && h._ts && (o -= n, (!r && !l._dp || r && r.smoothChildTiming) && (l._start += n / l._ts, l._time -= n, l._tTime -= n), l.shiftChildren(-n, !1, -Infinity), d = 0), h._end > o && h._ts && (o = h._end), h = e;
                    ce(l, l === c && l._time > o ? l._time : o, 1, 1), l._dirty = 0
                }
                return l._tDur
            }, e.updateRoot = function(time) {
                if (c._ts && (zt(c, te(time, c)), v = je.frame), je.frame >= Ct) {
                    Ct += U.autoSleep || 120;
                    var t = c._first;
                    if ((!t || !t._ts) && U.autoSleep && je._listeners.length < 2) {
                        for (; t && !t._ts;) t = t._next;
                        t || je.sleep()
                    }
                }
            }, e
        }(nn);
        Ht(rn.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var on, an = function(t, e, n, r, o, l, c) {
                var h, d, f, m, v, y, _, a, x = new An(this._pt, t, e, 0, 1, bn, null, o),
                    w = 0,
                    M = 0;
                for (x.b = n, x.e = r, n += "", (_ = ~(r += "").indexOf("random(")) && (r = Ae(r)), l && (l(a = [n, r], t, e), n = a[0], r = a[1]), d = n.match(ht) || []; h = ht.exec(r);) m = h[0], v = r.substring(w, h.index), f ? f = (f + 1) % 5 : "rgba(" === v.substr(-5) && (f = 1), m !== d[M++] && (y = parseFloat(d[M - 1]) || 0, x._pt = {
                    _next: x._pt,
                    p: v || 1 === M ? v : ",",
                    s: y,
                    c: "=" === m.charAt(1) ? parseFloat(m.substr(2)) * ("-" === m.charAt(0) ? -1 : 1) : parseFloat(m) - y,
                    m: f && f < 4 ? Math.round : 0
                }, w = ht.lastIndex);
                return x.c = w < r.length ? r.substring(w, r.length) : "", x.fp = c, (pt.test(r) || _) && (x.e = 0), this._pt = x, x
            },
            sn = function(t, e, n, r, o, l, c, h, d) {
                K(r) && (r = r(o || 0, t, l));
                var f, m = t[e],
                    v = "get" !== n ? n : K(m) ? d ? t[e.indexOf("set") || !K(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](d) : t[e]() : m,
                    y = K(m) ? d ? gn : mn : fn;
                if (J(r) && (~r.indexOf("random(") && (r = Ae(r)), "=" === r.charAt(1) && ((f = parseFloat(v) + parseFloat(r.substr(2)) * ("-" === r.charAt(0) ? -1 : 1) + (ge(v) || 0)) || 0 === f) && (r = f)), v !== r) return isNaN(v * r) || "" === r ? (!m && !(e in t) && _t(e, r), an.call(this, t, e, v, r, y, h || U.stringFilter, d)) : (f = new An(this._pt, t, e, +v || 0, r - (v || 0), "boolean" == typeof m ? xn : _n, 0, y), d && (f.fp = d), c && f.modifier(c, this, t), this._pt = f)
            },
            ln = function(t, e, n, r, o, l) {
                var c, h, d, i;
                if (Et[t] && !1 !== (c = new Et[t]).init(o, c.rawVars ? e[t] : function(t, e, n, r, o) {
                        if (K(t) && (t = un(t, o, e, n, r)), !et(t) || t.style && t.nodeType || st(t) || at(t)) return J(t) ? un(t, o, e, n, r) : t;
                        var p, l = {};
                        for (p in t) l[p] = un(t[p], o, e, n, r);
                        return l
                    }(e[t], r, o, l, n), n, r, l) && (n._pt = h = new An(n._pt, o, t, 0, 1, c.render, c, 0, c.priority), n !== y))
                    for (d = n._ptLookup[n._targets.indexOf(o)], i = c._props.length; i--;) d[c._props[i]] = h;
                return c
            },
            cn = function t(e, time) {
                var n, i, p, r, o, h, d, f, m, v, y, _, x, w = e.vars,
                    M = w.ease,
                    S = w.startAt,
                    T = w.immediateRender,
                    E = w.lazy,
                    A = w.onUpdate,
                    C = w.onUpdateParams,
                    L = w.callbackScope,
                    k = w.runBackwards,
                    R = w.yoyoEase,
                    P = w.keyframes,
                    D = w.autoRevert,
                    O = e._dur,
                    I = e._startAt,
                    N = e._targets,
                    F = e.parent,
                    z = F && "nested" === F.data ? F.parent._targets : N,
                    B = "auto" === e._overwrite && !l,
                    U = e.timeline;
                if (U && (!P || !M) && (M = "none"), e._ease = Ze(M, H.ease), e._yEase = R ? $e(Ze(!0 === R ? M : R, H.ease)) : 0, R && e._yoyo && !e._repeat && (R = e._yEase, e._yEase = e._ease, e._ease = R), e._from = !U && !!w.runBackwards, !U) {
                    if (_ = (f = N[0] ? Pt(N[0]).harness : 0) && w[f.prop], n = Wt(w, Mt), I && I.render(-1, !0).kill(), S)
                        if ($t(e._startAt = pn.set(N, Ht({
                                data: "isStart",
                                overwrite: !1,
                                parent: F,
                                immediateRender: !0,
                                lazy: nt(E),
                                startAt: null,
                                delay: 0,
                                onUpdate: A,
                                onUpdateParams: C,
                                callbackScope: L,
                                stagger: 0
                            }, S))), time < 0 && !T && !D && e._startAt.render(-1, !0), T) {
                            if (time > 0 && !D && (e._startAt = 0), O && time <= 0) return void(time && (e._zTime = time))
                        } else !1 === D && (e._startAt = 0);
                    else if (k && O)
                        if (I) !D && (e._startAt = 0);
                        else if (time && (T = !1), p = Ht({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: T && nt(E),
                            immediateRender: T,
                            stagger: 0,
                            parent: F
                        }, n), _ && (p[f.prop] = _), $t(e._startAt = pn.set(N, p)), time < 0 && e._startAt.render(-1, !0), T) {
                        if (!time) return
                    } else t(e._startAt, V);
                    for (e._pt = 0, E = O && nt(E) || E && !O, i = 0; i < N.length; i++) {
                        if (d = (o = N[i])._gsap || Rt(N)[i]._gsap, e._ptLookup[i] = v = {}, Tt[d.id] && St.length && Ft(), y = z === N ? i : z.indexOf(o), f && !1 !== (m = new f).init(o, _ || n, e, y, z) && (e._pt = r = new An(e._pt, o, m.name, 0, 1, m.render, m, 0, m.priority), m._props.forEach((function(t) {
                                v[t] = r
                            })), m.priority && (h = 1)), !f || _)
                            for (p in n) Et[p] && (m = ln(p, n, e, y, o, z)) ? m.priority && (h = 1) : v[p] = r = sn.call(e, o, p, "get", n[p], y, z, 0, w.stringFilter);
                        e._op && e._op[i] && e.kill(o, e._op[i]), B && e._pt && (on = e, c.killTweensOf(o, v, e.globalTime(0)), x = !e.parent, on = 0), e._pt && E && (Tt[d.id] = 1)
                    }
                    h && En(e), e._onInit && e._onInit(e)
                }
                e._onUpdate = A, e._initted = (!e._op || e._pt) && !x
            },
            un = function(t, e, i, n, r) {
                return K(t) ? t.call(e, i, n, r) : J(t) && ~t.indexOf("random(") ? Ae(t) : t
            },
            hn = kt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
            dn = (hn + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
            pn = function(t) {
                function e(e, n, o, h) {
                    var d;
                    "number" == typeof n && (o.duration = n, n = o, o = null);
                    var f, i, m, v, p, y, _, x, w = (d = t.call(this, h ? n : qt(n)) || this).vars,
                        M = w.duration,
                        S = w.delay,
                        T = w.immediateRender,
                        E = w.stagger,
                        A = w.overwrite,
                        C = w.keyframes,
                        L = w.defaults,
                        k = w.scrollTrigger,
                        R = w.yoyoEase,
                        P = n.parent || c,
                        D = (st(e) || at(e) ? Q(e[0]) : "length" in n) ? [e] : xe(e);
                    if (d._targets = D.length ? Rt(D) : xt("GSAP target " + e + " not found. https://greensock.com", !U.nullTargetWarn) || [], d._ptLookup = [], d._overwrite = A, C || E || ot(M) || ot(S)) {
                        if (n = d.vars, (f = d.timeline = new rn({
                                data: "nested",
                                defaults: L || {}
                            })).kill(), f.parent = f._dp = r(d), f._start = 0, C) Ht(f.vars.defaults, {
                            ease: "none"
                        }), E ? D.forEach((function(t, i) {
                            return C.forEach((function(e, n) {
                                return f.to(t, e, n ? ">" : i * E)
                            }))
                        })) : C.forEach((function(t) {
                            return f.to(D, t, ">")
                        }));
                        else {
                            if (v = D.length, _ = E ? we(E) : wt, et(E))
                                for (p in E) ~hn.indexOf(p) && (x || (x = {}), x[p] = E[p]);
                            for (i = 0; i < v; i++) {
                                for (p in m = {}, n) dn.indexOf(p) < 0 && (m[p] = n[p]);
                                m.stagger = 0, R && (m.yoyoEase = R), x && Vt(m, x), y = D[i], m.duration = +un(M, r(d), i, y, D), m.delay = (+un(S, r(d), i, y, D) || 0) - d._delay, !E && 1 === v && m.delay && (d._delay = S = m.delay, d._start += S, m.delay = 0), f.to(y, m, _(i, y, D))
                            }
                            f.duration() ? M = S = 0 : d.timeline = 0
                        }
                        M || d.duration(M = f.duration())
                    } else d.timeline = 0;
                    return !0 !== A || l || (on = r(d), c.killTweensOf(D), on = 0), ie(P, r(d), o), n.reversed && d.reverse(), n.paused && d.paused(!0), (T || !M && !C && d._start === It(P._time) && nt(T) && Jt(r(d)) && "nested" !== P.data) && (d._tTime = -1e-8, d.render(Math.max(0, -S))), k && oe(r(d), k), d
                }
                o(e, t);
                var n = e.prototype;
                return n.render = function(t, e, n) {
                    var time, r, o, l, c, h, d, f, m, v = this._time,
                        y = this._tDur,
                        _ = this._dur,
                        x = t > y - V && t >= 0 ? y : t < V ? 0 : t;
                    if (_) {
                        if (x !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 != t < 0) {
                            if (time = x, f = this.timeline, this._repeat) {
                                if (l = _ + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * l + t, e, n);
                                if (time = It(x % l), x === y ? (o = this._repeat, time = _) : ((o = ~~(x / l)) && o === x / l && (time = _, o--), time > _ && (time = _)), (h = this._yoyo && 1 & o) && (m = this._yEase, time = _ - time), c = Qt(this._tTime, l), time === v && !n && this._initted) return this;
                                o !== c && (f && this._yEase && Ye(f, h), !this.vars.repeatRefresh || h || this._lock || (this._lock = n = 1, this.render(It(l * o), !0).invalidate()._lock = 0))
                            }
                            if (!this._initted) {
                                if (ae(this, t < 0 ? t : time, n, e)) return this._tTime = 0, this;
                                if (_ !== this._dur) return this.render(t, e, n)
                            }
                            if (this._tTime = x, this._time = time, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = d = (m || this._ease)(time / _), this._from && (this.ratio = d = 1 - d), time && !v && !e && (ke(this, "onStart"), this._tTime !== x)) return this;
                            for (r = this._pt; r;) r.r(d, r.d), r = r._next;
                            f && f.render(t < 0 ? t : !time && h ? -1e-8 : f._dur * d, e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), ke(this, "onUpdate")), this._repeat && o !== c && this.vars.onRepeat && !e && this.parent && ke(this, "onRepeat"), x !== this._tDur && x || this._tTime !== x || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !_) && (x === this._tDur && this._ts > 0 || !x && this._ts < 0) && $t(this, 1), e || t < 0 && !v || !x && !v || (ke(this, x === y ? "onComplete" : "onReverseComplete", !0), this._prom && !(x < y && this.timeScale() > 0) && this._prom()))
                        }
                    } else ! function(t, e, n, r) {
                        var o, l, c, h = t.ratio,
                            d = e < 0 || !e && (!t._start && se(t) && (t._initted || !le(t)) || (t._ts < 0 || t._dp._ts < 0) && !le(t)) ? 0 : 1,
                            f = t._rDelay,
                            m = 0;
                        if (f && t._repeat && (m = me(0, t._tDur, e), l = Qt(m, f), c = Qt(t._tTime, f), t._yoyo && 1 & l && (d = 1 - d), l !== c && (h = 1 - d, t.vars.repeatRefresh && t._initted && t.invalidate())), d !== h || r || t._zTime === V || !e && t._zTime) {
                            if (!t._initted && ae(t, e, r, n)) return;
                            for (c = t._zTime, t._zTime = e || (n ? V : 0), n || (n = e && !c), t.ratio = d, t._from && (d = 1 - d), t._time = 0, t._tTime = m, o = t._pt; o;) o.r(d, o.d), o = o._next;
                            t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !n && ke(t, "onUpdate"), m && t._repeat && !n && t.parent && ke(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === d && (d && $t(t, 1), n || (ke(t, d ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                        } else t._zTime || (t._zTime = e)
                    }(this, t, e, n);
                    return this
                }, n.targets = function() {
                    return this._targets
                }, n.invalidate = function() {
                    return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
                }, n.kill = function(t, e) {
                    if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? Re(this) : this;
                    if (this.timeline) {
                        var n = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(t, e, on && !0 !== on.vars.overwrite)._first || Re(this), this.parent && n !== this.timeline.totalDuration() && ce(this, this._dur * this.timeline._tDur / n, 0, 1), this
                    }
                    var r, o, l, c, p, h, i, d = this._targets,
                        f = t ? xe(t) : d,
                        m = this._ptLookup,
                        v = this._pt;
                    if ((!e || "all" === e) && function(t, e) {
                            for (var i = t.length, n = i === e.length; n && i-- && t[i] === e[i];);
                            return i < 0
                        }(d, f)) return "all" === e && (this._pt = 0), Re(this);
                    for (r = this._op = this._op || [], "all" !== e && (J(e) && (p = {}, Ot(e, (function(t) {
                            return p[t] = 1
                        })), e = p), e = function(t, e) {
                            var n, p, i, r, o = t[0] ? Pt(t[0]).harness : 0,
                                l = o && o.aliases;
                            if (!l) return e;
                            for (p in n = Vt({}, e), l)
                                if (p in n)
                                    for (i = (r = l[p].split(",")).length; i--;) n[r[i]] = n[p];
                            return n
                        }(d, e)), i = d.length; i--;)
                        if (~f.indexOf(d[i]))
                            for (p in o = m[i], "all" === e ? (r[i] = e, c = o, l = {}) : (l = r[i] = r[i] || {}, c = e), c)(h = o && o[p]) && ("kill" in h.d && !0 !== h.d.kill(p) || Xt(this, h, "_pt"), delete o[p]), "all" !== l && (l[p] = 1);
                    return this._initted && !this._pt && v && Re(this), this
                }, e.to = function(t, n) {
                    return new e(t, n, arguments[2])
                }, e.from = function(t, e) {
                    return pe(1, arguments)
                }, e.delayedCall = function(t, n, r, o) {
                    return new e(n, 0, {
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: t,
                        onComplete: n,
                        onReverseComplete: n,
                        onCompleteParams: r,
                        onReverseCompleteParams: r,
                        callbackScope: o
                    })
                }, e.fromTo = function(t, e, n) {
                    return pe(2, arguments)
                }, e.set = function(t, n) {
                    return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
                }, e.killTweensOf = function(t, e, n) {
                    return c.killTweensOf(t, e, n)
                }, e
            }(nn);
        Ht(pn.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), Ot("staggerTo,staggerFrom,staggerFromTo", (function(t) {
            pn[t] = function() {
                var e = new rn,
                    n = ve.call(arguments, 0);
                return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
            }
        }));
        var fn = function(t, e, n) {
                return t[e] = n
            },
            mn = function(t, e, n) {
                return t[e](n)
            },
            gn = function(t, e, n, data) {
                return t[e](data.fp, n)
            },
            vn = function(t, e, n) {
                return t.setAttribute(e, n)
            },
            yn = function(t, e) {
                return K(t[e]) ? mn : tt(t[e]) && t.setAttribute ? vn : fn
            },
            _n = function(t, data) {
                return data.set(data.t, data.p, Math.round(1e6 * (data.s + data.c * t)) / 1e6, data)
            },
            xn = function(t, data) {
                return data.set(data.t, data.p, !!(data.s + data.c * t), data)
            },
            bn = function(t, data) {
                var e = data._pt,
                    s = "";
                if (!t && data.b) s = data.b;
                else if (1 === t && data.e) s = data.e;
                else {
                    for (; e;) s = e.p + (e.m ? e.m(e.s + e.c * t) : Math.round(1e4 * (e.s + e.c * t)) / 1e4) + s, e = e._next;
                    s += data.c
                }
                data.set(data.t, data.p, s, data)
            },
            wn = function(t, data) {
                for (var e = data._pt; e;) e.r(t, e.d), e = e._next
            },
            Mn = function(t, e, n, r) {
                for (var o, l = this._pt; l;) o = l._next, l.p === r && l.modifier(t, e, n), l = o
            },
            Sn = function(t) {
                for (var e, n, r = this._pt; r;) n = r._next, r.p === t && !r.op || r.op === t ? Xt(this, r, "_pt") : r.dep || (e = 1), r = n;
                return !e
            },
            Tn = function(t, e, n, data) {
                data.mSet(t, e, data.m.call(data.tween, n, data.mt), data)
            },
            En = function(t) {
                for (var e, n, r, o, l = t._pt; l;) {
                    for (e = l._next, n = r; n && n.pr > l.pr;) n = n._next;
                    (l._prev = n ? n._prev : o) ? l._prev._next = l: r = l, (l._next = n) ? n._prev = l : o = l, l = e
                }
                t._pt = r
            },
            An = function() {
                function t(t, e, n, r, o, l, data, c, h) {
                    this.t = e, this.s = r, this.c = o, this.p = n, this.r = l || _n, this.d = data || this, this.set = c || fn, this.pr = h || 0, this._next = t, t && (t._prev = this)
                }
                return t.prototype.modifier = function(t, e, n) {
                    this.mSet = this.mSet || this.set, this.set = Tn, this.m = t, this.mt = n, this.tween = e
                }, t
            }();
        Ot(kt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
            return Mt[t] = 1
        })), gt.TweenMax = gt.TweenLite = pn, gt.TimelineLite = gt.TimelineMax = rn, c = new rn({
            sortChildren: !1,
            defaults: H,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }), U.stringFilter = He;
        var Cn = {
            registerPlugin: function() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                e.forEach((function(t) {
                    return Pe(t)
                }))
            },
            timeline: function(t) {
                return new rn(t)
            },
            getTweensOf: function(t, e) {
                return c.getTweensOf(t, e)
            },
            getProperty: function(t, e, n, r) {
                J(t) && (t = xe(t)[0]);
                var o = Pt(t || {}).get,
                    l = n ? Ut : Bt;
                return "native" === n && (n = ""), t ? e ? l((Et[e] && Et[e].get || o)(t, e, n, r)) : function(e, n, r) {
                    return l((Et[e] && Et[e].get || o)(t, e, n, r))
                } : t
            },
            quickSetter: function(t, e, n) {
                if ((t = xe(t)).length > 1) {
                    var r = t.map((function(t) {
                            return Rn.quickSetter(t, e, n)
                        })),
                        o = r.length;
                    return function(t) {
                        for (var i = o; i--;) r[i](t)
                    }
                }
                t = t[0] || {};
                var l = Et[e],
                    c = Pt(t),
                    p = c.harness && (c.harness.aliases || {})[e] || e,
                    h = l ? function(e) {
                        var p = new l;
                        y._pt = 0, p.init(t, n ? e + n : e, y, 0, [t]), p.render(1, p), y._pt && wn(1, y)
                    } : c.set(t, p);
                return l ? h : function(e) {
                    return h(t, p, n ? e + n : e, c, 1)
                }
            },
            isTweening: function(t) {
                return c.getTweensOf(t, !0).length > 0
            },
            defaults: function(t) {
                return t && t.ease && (t.ease = Ze(t.ease, H.ease)), Gt(H, t || {})
            },
            config: function(t) {
                return Gt(U, t || {})
            },
            registerEffect: function(t) {
                var e = t.name,
                    n = t.effect,
                    r = t.plugins,
                    o = t.defaults,
                    l = t.extendTimeline;
                (r || "").split(",").forEach((function(t) {
                    return t && !Et[t] && !gt[t] && xt(e + " effect requires " + t + " plugin.")
                })), At[e] = function(t, e, r) {
                    return n(xe(t), Ht(e || {}, o), r)
                }, l && (rn.prototype[e] = function(t, n, r) {
                    return this.add(At[e](t, et(n) ? n : (r = n) && {}, this), r)
                })
            },
            registerEase: function(t, e) {
                Ge[t] = Ze(e)
            },
            parseEase: function(t, e) {
                return arguments.length ? Ze(t, e) : Ge
            },
            getById: function(t) {
                return c.getById(t)
            },
            exportRoot: function(t, e) {
                void 0 === t && (t = {});
                var n, r, o = new rn(t);
                for (o.smoothChildTiming = nt(t.smoothChildTiming), c.remove(o), o._dp = 0, o._time = o._tTime = c._time, n = c._first; n;) r = n._next, !e && !n._dur && n instanceof pn && n.vars.onComplete === n._targets[0] || ie(o, n, n._start - n._delay), n = r;
                return ie(c, o, 0), o
            },
            utils: {
                wrap: function t(e, n, r) {
                    var o = n - e;
                    return st(e) ? Ee(e, t(0, e.length), n) : fe(r, (function(t) {
                        return (o + (t - e) % o) % o + e
                    }))
                },
                wrapYoyo: function t(e, n, r) {
                    var o = n - e,
                        l = 2 * o;
                    return st(e) ? Ee(e, t(0, e.length - 1), n) : fe(r, (function(t) {
                        return e + ((t = (l + (t - e) % l) % l || 0) > o ? l - t : t)
                    }))
                },
                distribute: we,
                random: Te,
                snap: Se,
                normalize: function(t, e, n) {
                    return Ce(t, e, 0, 1, n)
                },
                getUnit: ge,
                clamp: function(t, e, n) {
                    return fe(n, (function(n) {
                        return me(t, e, n)
                    }))
                },
                splitColor: Ne,
                toArray: xe,
                selector: function(t) {
                    return t = xe(t)[0] || xt("Invalid scope") || {},
                        function(e) {
                            var n = t.current || t.nativeElement || t;
                            return xe(e, n.querySelectorAll ? n : n === t ? xt("Invalid scope") || f.createElement("div") : t)
                        }
                },
                mapRange: Ce,
                pipe: function() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return function(t) {
                        return e.reduce((function(t, e) {
                            return e(t)
                        }), t)
                    }
                },
                unitize: function(t, e) {
                    return function(n) {
                        return t(parseFloat(n)) + (e || ge(n))
                    }
                },
                interpolate: function t(e, n, progress, r) {
                    var o = isNaN(e + n) ? 0 : function(p) {
                        return (1 - p) * e + p * n
                    };
                    if (!o) {
                        var p, i, l, c, h, d = J(e),
                            f = {};
                        if (!0 === progress && (r = 1) && (progress = null), d) e = {
                            p: e
                        }, n = {
                            p: n
                        };
                        else if (st(e) && !st(n)) {
                            for (l = [], c = e.length, h = c - 2, i = 1; i < c; i++) l.push(t(e[i - 1], e[i]));
                            c--, o = function(p) {
                                p *= c;
                                var i = Math.min(h, ~~p);
                                return l[i](p - i)
                            }, progress = n
                        } else r || (e = Vt(st(e) ? [] : {}, e));
                        if (!l) {
                            for (p in n) sn.call(f, e, p, "get", n[p]);
                            o = function(p) {
                                return wn(p, f) || (d ? e.p : e)
                            }
                        }
                    }
                    return fe(progress, o)
                },
                shuffle: be
            },
            install: yt,
            effects: At,
            ticker: je,
            updateRoot: rn.updateRoot,
            plugins: Et,
            globalTimeline: c,
            core: {
                PropTween: An,
                globals: bt,
                Tween: pn,
                Timeline: rn,
                Animation: nn,
                getCache: Pt,
                _removeLinkedListItem: Xt,
                suppressOverwrites: function(t) {
                    return l = t
                }
            }
        };
        Ot("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
            return Cn[t] = pn[t]
        })), je.add(rn.updateRoot), y = Cn.to({}, {
            duration: 0
        });
        var Ln = function(t, e) {
                for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
                return n
            },
            kn = function(t, e) {
                return {
                    name: t,
                    rawVars: 1,
                    init: function(t, n, r) {
                        r._onInit = function(t) {
                            var r, p;
                            if (J(n) && (r = {}, Ot(n, (function(t) {
                                    return r[t] = 1
                                })), n = r), e) {
                                for (p in r = {}, n) r[p] = e(n[p]);
                                n = r
                            }! function(t, e) {
                                var p, i, n, r = t._targets;
                                for (p in e)
                                    for (i = r.length; i--;)(n = t._ptLookup[i][p]) && (n = n.d) && (n._pt && (n = Ln(n, p)), n && n.modifier && n.modifier(e[p], t, r[i], p))
                            }(t, n)
                        }
                    }
                }
            },
            Rn = Cn.registerPlugin({
                name: "attr",
                init: function(t, e, n, r, o) {
                    var p, l;
                    for (p in e)(l = this.add(t, "setAttribute", (t.getAttribute(p) || 0) + "", e[p], r, o, 0, 0, p)) && (l.op = p), this._props.push(p)
                }
            }, {
                name: "endArray",
                init: function(t, e) {
                    for (var i = e.length; i--;) this.add(t, i, t[i] || 0, e[i])
                }
            }, kn("roundProps", Me), kn("modifiers"), kn("snap", Se)) || Cn;
        pn.version = rn.version = Rn.version = "3.7.1", m = 1, it() && Ve();
        Ge.Power0, Ge.Power1, Ge.Power2, Ge.Power3, Ge.Power4;
        var Pn = Ge.Linear,
            Dn = (Ge.Quad, Ge.Cubic, Ge.Quart, Ge.Quint, Ge.Strong, Ge.Elastic, Ge.Back, Ge.SteppedEase, Ge.Bounce, Ge.Sine, Ge.Expo);
        Ge.Circ
    }, , function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
            return o
        })), n.d(e, "b", (function() {
            return ln
        })), n.d(e, "c", (function() {
            return Zl
        })), n.d(e, "d", (function() {
            return We
        })), n.d(e, "e", (function() {
            return Nn
        })), n.d(e, "f", (function() {
            return Ke
        })), n.d(e, "g", (function() {
            return r
        })), n.d(e, "h", (function() {
            return T
        })), n.d(e, "i", (function() {
            return E
        })), n.d(e, "j", (function() {
            return En
        })), n.d(e, "k", (function() {
            return or
        })), n.d(e, "l", (function() {
            return On
        })), n.d(e, "m", (function() {
            return Ol
        })), n.d(e, "n", (function() {
            return _c
        })), n.d(e, "o", (function() {
            return O
        })), n.d(e, "p", (function() {
            return D
        })), n.d(e, "q", (function() {
            return Vo
        })), n.d(e, "r", (function() {
            return Pn
        })), n.d(e, "s", (function() {
            return Ns
        })), n.d(e, "t", (function() {
            return Ns
        })), n.d(e, "u", (function() {
            return Rn
        })), n.d(e, "v", (function() {
            return ht
        })), n.d(e, "w", (function() {
            return Mt
        })), n.d(e, "x", (function() {
            return _t
        })), n.d(e, "y", (function() {
            return zn
        })), n.d(e, "z", (function() {
            return xt
        })), n.d(e, "A", (function() {
            return Uo
        })), n.d(e, "B", (function() {
            return X
        }));
        const r = 0,
            o = 1,
            l = 100,
            c = 301,
            h = 302,
            d = 303,
            f = 304,
            m = 306,
            v = 307,
            y = 1e3,
            _ = 1001,
            x = 1002,
            w = 1003,
            M = 1004,
            S = 1005,
            T = 1006,
            E = 1008,
            A = 1009,
            C = 1012,
            L = 1014,
            k = 1015,
            R = 1016,
            P = 1020,
            D = 1022,
            O = 1023,
            I = O,
            N = 1026,
            F = 1027,
            z = 2300,
            B = 2301,
            U = 2302,
            H = 2400,
            j = 2401,
            V = 2402,
            G = 2500,
            W = 3e3,
            X = 3001,
            $ = 3007,
            Y = 3002,
            Z = 7680,
            J = 35044,
            K = 35048,
            Q = "300 es";
        class tt {
            addEventListener(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
            }
            hasEventListener(t, e) {
                if (void 0 === this._listeners) return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }
            removeEventListener(t, e) {
                if (void 0 === this._listeners) return;
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                }
            }
            dispatchEvent(t) {
                if (void 0 === this._listeners) return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let i = 0, e = n.length; i < e; i++) n[i].call(this, t);
                    t.target = null
                }
            }
        }
        const et = [];
        for (let i = 0; i < 256; i++) et[i] = (i < 16 ? "0" : "") + i.toString(16);
        const nt = Math.PI / 180,
            it = 180 / Math.PI;

        function ot() {
            const t = 4294967295 * Math.random() | 0,
                e = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                r = 4294967295 * Math.random() | 0;
            return (et[255 & t] + et[t >> 8 & 255] + et[t >> 16 & 255] + et[t >> 24 & 255] + "-" + et[255 & e] + et[e >> 8 & 255] + "-" + et[e >> 16 & 15 | 64] + et[e >> 24 & 255] + "-" + et[63 & n | 128] + et[n >> 8 & 255] + "-" + et[n >> 16 & 255] + et[n >> 24 & 255] + et[255 & r] + et[r >> 8 & 255] + et[r >> 16 & 255] + et[r >> 24 & 255]).toUpperCase()
        }

        function at(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }

        function st(t, e) {
            return (t % e + e) % e
        }

        function lt(t, e, n) {
            return (1 - n) * t + n * e
        }

        function ct(t) {
            return 0 == (t & t - 1) && 0 !== t
        }

        function ut(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
        class ht {
            constructor(t = 0, e = 0) {
                this.x = t, this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t, this.y = e, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
            }
            addScalar(s) {
                return this.x += s, this.y += s, this
            }
            addVectors(a, b) {
                return this.x = a.x + b.x, this.y = a.y + b.y, this
            }
            addScaledVector(t, s) {
                return this.x += t.x * s, this.y += t.y * s, this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
            }
            subScalar(s) {
                return this.x -= s, this.y -= s, this
            }
            subVectors(a, b) {
                return this.x = a.x - b.x, this.y = a.y - b.y, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
            }
            rotateAround(t, e) {
                const n = Math.cos(e),
                    s = Math.sin(e),
                    r = this.x - t.x,
                    o = this.y - t.y;
                return this.x = r * n - o * s + t.x, this.y = r * s + o * n + t.y, this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            }
        }
        ht.prototype.isVector2 = !0;
        class pt {
            constructor() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, n, r, o, l, c, h, d) {
                const f = this.elements;
                return f[0] = t, f[1] = r, f[2] = c, f[3] = e, f[4] = o, f[5] = h, f[6] = n, f[7] = l, f[8] = d, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(a, b) {
                const t = a.elements,
                    e = b.elements,
                    n = this.elements,
                    r = t[0],
                    o = t[3],
                    l = t[6],
                    c = t[1],
                    h = t[4],
                    d = t[7],
                    f = t[2],
                    m = t[5],
                    v = t[8],
                    y = e[0],
                    _ = e[3],
                    x = e[6],
                    w = e[1],
                    M = e[4],
                    S = e[7],
                    T = e[2],
                    E = e[5],
                    A = e[8];
                return n[0] = r * y + o * w + l * T, n[3] = r * _ + o * M + l * E, n[6] = r * x + o * S + l * A, n[1] = c * y + h * w + d * T, n[4] = c * _ + h * M + d * E, n[7] = c * x + h * S + d * A, n[2] = f * y + m * w + v * T, n[5] = f * _ + m * M + v * E, n[8] = f * x + m * S + v * A, this
            }
            multiplyScalar(s) {
                const t = this.elements;
                return t[0] *= s, t[3] *= s, t[6] *= s, t[1] *= s, t[4] *= s, t[7] *= s, t[2] *= s, t[5] *= s, t[8] *= s, this
            }
            determinant() {
                const t = this.elements,
                    a = t[0],
                    b = t[1],
                    e = t[2],
                    n = t[3],
                    r = t[4],
                    o = t[5],
                    g = t[6],
                    l = t[7],
                    i = t[8];
                return a * r * i - a * o * l - b * n * i + b * o * g + e * n * l - e * r * g
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    r = t[2],
                    o = t[3],
                    l = t[4],
                    c = t[5],
                    h = t[6],
                    d = t[7],
                    f = t[8],
                    m = f * l - c * d,
                    v = c * h - f * o,
                    y = d * o - l * h,
                    _ = e * m + n * v + r * y;
                if (0 === _) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const x = 1 / _;
                return t[0] = m * x, t[1] = (r * d - f * n) * x, t[2] = (c * n - r * l) * x, t[3] = v * x, t[4] = (f * e - r * h) * x, t[5] = (r * o - c * e) * x, t[6] = y * x, t[7] = (n * h - d * e) * x, t[8] = (l * e - n * o) * x, this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            }
            setUvTransform(t, e, n, r, o, l, c) {
                const h = Math.cos(o),
                    s = Math.sin(o);
                return this.set(n * h, n * s, -n * (h * l + s * c) + l + t, -r * s, r * h, -r * (-s * l + h * c) + c + e, 0, 0, 1), this
            }
            scale(t, e) {
                const n = this.elements;
                return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
            }
            rotate(t) {
                const e = Math.cos(t),
                    s = Math.sin(t),
                    n = this.elements,
                    r = n[0],
                    o = n[3],
                    l = n[6],
                    c = n[1],
                    h = n[4],
                    d = n[7];
                return n[0] = e * r + s * c, n[3] = e * o + s * h, n[6] = e * l + s * d, n[1] = -s * r + e * c, n[4] = -s * o + e * h, n[7] = -s * l + e * d, this
            }
            translate(t, e) {
                const n = this.elements;
                return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let i = 0; i < 9; i++)
                    if (e[i] !== n[i]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        let ft;
        pt.prototype.isMatrix3 = !0;
        class mt {
            static getDataURL(image) {
                if (/^data:/i.test(image.src)) return image.src;
                if ("undefined" == typeof HTMLCanvasElement) return image.src;
                let canvas;
                if (image instanceof HTMLCanvasElement) canvas = image;
                else {
                    void 0 === ft && (ft = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), ft.width = image.width, ft.height = image.height;
                    const t = ft.getContext("2d");
                    image instanceof ImageData ? t.putImageData(image, 0, 0) : t.drawImage(image, 0, 0, image.width, image.height), canvas = ft
                }
                return canvas.width > 2048 || canvas.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image), canvas.toDataURL("image/jpeg", .6)) : canvas.toDataURL("image/png")
            }
        }
        let gt = 0;
        class vt extends tt {
            constructor(image = vt.DEFAULT_IMAGE, t = vt.DEFAULT_MAPPING, e = 1001, n = 1001, r = T, o = E, l = O, c = 1009, h = 1, d = 3e3) {
                super(), Object.defineProperty(this, "id", {
                    value: gt++
                }), this.uuid = ot(), this.name = "", this.image = image, this.mipmaps = [], this.mapping = t, this.wrapS = e, this.wrapT = n, this.magFilter = r, this.minFilter = o, this.anisotropy = h, this.format = l, this.internalFormat = null, this.type = c, this.offset = new ht(0, 0), this.repeat = new ht(1, 1), this.center = new ht(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new pt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = d, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(source) {
                return this.name = source.name, this.image = source.image, this.mipmaps = source.mipmaps.slice(0), this.mapping = source.mapping, this.wrapS = source.wrapS, this.wrapT = source.wrapT, this.magFilter = source.magFilter, this.minFilter = source.minFilter, this.anisotropy = source.anisotropy, this.format = source.format, this.internalFormat = source.internalFormat, this.type = source.type, this.offset.copy(source.offset), this.repeat.copy(source.repeat), this.center.copy(source.center), this.rotation = source.rotation, this.matrixAutoUpdate = source.matrixAutoUpdate, this.matrix.copy(source.matrix), this.generateMipmaps = source.generateMipmaps, this.premultiplyAlpha = source.premultiplyAlpha, this.flipY = source.flipY, this.unpackAlignment = source.unpackAlignment, this.encoding = source.encoding, this
            }
            toJSON(meta) {
                const t = void 0 === meta || "string" == typeof meta;
                if (!t && void 0 !== meta.textures[this.uuid]) return meta.textures[this.uuid];
                const output = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    const image = this.image;
                    if (void 0 === image.uuid && (image.uuid = ot()), !t && void 0 === meta.images[image.uuid]) {
                        let t;
                        if (Array.isArray(image)) {
                            t = [];
                            for (let i = 0, e = image.length; i < e; i++) image[i].isDataTexture ? t.push(yt(image[i].image)) : t.push(yt(image[i]))
                        } else t = yt(image);
                        meta.images[image.uuid] = {
                            uuid: image.uuid,
                            url: t
                        }
                    }
                    output.image = image.uuid
                }
                return t || (meta.textures[this.uuid] = output), output
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (300 !== this.mapping) return t;
                if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                    case y:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case _:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case x:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                    case y:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case _:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case x:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                return this.flipY && (t.y = 1 - t.y), t
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }

        function yt(image) {
            return "undefined" != typeof HTMLImageElement && image instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && image instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && image instanceof ImageBitmap ? mt.getDataURL(image) : image.data ? {
                data: Array.prototype.slice.call(image.data),
                width: image.width,
                height: image.height,
                type: image.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
        }
        vt.DEFAULT_IMAGE = void 0, vt.DEFAULT_MAPPING = 300, vt.prototype.isTexture = !0;
        class _t {
            constructor(t = 0, e = 0, n = 0, r = 1) {
                this.x = t, this.y = e, this.z = n, this.w = r
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, r) {
                return this.x = t, this.y = e, this.z = n, this.w = r, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setW(t) {
                return this.w = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            }
            addScalar(s) {
                return this.x += s, this.y += s, this.z += s, this.w += s, this
            }
            addVectors(a, b) {
                return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, this
            }
            addScaledVector(t, s) {
                return this.x += t.x * s, this.y += t.y * s, this.z += t.z * s, this.w += t.w * s, this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            }
            subScalar(s) {
                return this.x -= s, this.y -= s, this.z -= s, this.w -= s, this
            }
            subVectors(a, b) {
                return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, this
            }
            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    o = this.w,
                    l = t.elements;
                return this.x = l[0] * e + l[4] * n + l[8] * r + l[12] * o, this.y = l[1] * e + l[5] * n + l[9] * r + l[13] * o, this.z = l[2] * e + l[6] * n + l[10] * r + l[14] * o, this.w = l[3] * e + l[7] * n + l[11] * r + l[15] * o, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(q) {
                this.w = 2 * Math.acos(q.w);
                const s = Math.sqrt(1 - q.w * q.w);
                return s < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = q.x / s, this.y = q.y / s, this.z = q.z / s), this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, r, o;
                const l = .01,
                    c = .1,
                    h = t.elements,
                    d = h[0],
                    f = h[4],
                    m = h[8],
                    v = h[1],
                    y = h[5],
                    _ = h[9],
                    x = h[2],
                    w = h[6],
                    M = h[10];
                if (Math.abs(f - v) < l && Math.abs(m - x) < l && Math.abs(_ - w) < l) {
                    if (Math.abs(f + v) < c && Math.abs(m + x) < c && Math.abs(_ + w) < c && Math.abs(d + y + M - 3) < c) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    const t = (d + 1) / 2,
                        h = (y + 1) / 2,
                        S = (M + 1) / 2,
                        T = (f + v) / 4,
                        E = (m + x) / 4,
                        A = (_ + w) / 4;
                    return t > h && t > S ? t < l ? (n = 0, r = .707106781, o = .707106781) : (n = Math.sqrt(t), r = T / n, o = E / n) : h > S ? h < l ? (n = .707106781, r = 0, o = .707106781) : (r = Math.sqrt(h), n = T / r, o = A / r) : S < l ? (n = .707106781, r = .707106781, o = 0) : (o = Math.sqrt(S), n = E / o, r = A / o), this.set(n, r, o, e), this
                }
                let s = Math.sqrt((w - _) * (w - _) + (m - x) * (m - x) + (v - f) * (v - f));
                return Math.abs(s) < .001 && (s = 1), this.x = (w - _) / s, this.y = (m - x) / s, this.z = (v - f) / s, this.w = Math.acos((d + y + M - 1) / 2), this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }
        }
        _t.prototype.isVector4 = !0;
        class xt extends tt {
            constructor(t, e, n = {}) {
                super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new _t(0, 0, t, e), this.scissorTest = !1, this.viewport = new _t(0, 0, t, e), this.texture = new vt(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
                    width: t,
                    height: e,
                    depth: 1
                }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : T, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }
            setTexture(t) {
                t.image = {
                    width: this.width,
                    height: this.height,
                    depth: this.depth
                }, this.texture = t
            }
            setSize(t, e, n = 1) {
                this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(source) {
                return this.width = source.width, this.height = source.height, this.depth = source.depth, this.viewport.copy(source.viewport), this.texture = source.texture.clone(), this.texture.image = { ...this.texture.image
                }, this.depthBuffer = source.depthBuffer, this.stencilBuffer = source.stencilBuffer, this.depthTexture = source.depthTexture, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        xt.prototype.isWebGLRenderTarget = !0;
        (class extends xt {
            constructor(t, e, n) {
                super(t, e);
                const r = this.texture;
                this.texture = [];
                for (let i = 0; i < n; i++) this.texture[i] = r.clone()
            }
            setSize(t, e, n = 1) {
                if (this.width !== t || this.height !== e || this.depth !== n) {
                    this.width = t, this.height = e, this.depth = n;
                    for (let i = 0, r = this.texture.length; i < r; i++) this.texture[i].image.width = t, this.texture[i].image.height = e, this.texture[i].image.depth = n;
                    this.dispose()
                }
                return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
            }
            copy(source) {
                this.dispose(), this.width = source.width, this.height = source.height, this.depth = source.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = source.depthBuffer, this.stencilBuffer = source.stencilBuffer, this.depthTexture = source.depthTexture, this.texture.length = 0;
                for (let i = 0, t = source.texture.length; i < t; i++) this.texture[i] = source.texture[i].clone();
                return this
            }
        }).prototype.isWebGLMultipleRenderTargets = !0;
        class bt extends xt {
            constructor(t, e, n) {
                super(t, e, n), this.samples = 4
            }
            copy(source) {
                return super.copy.call(this, source), this.samples = source.samples, this
            }
        }
        bt.prototype.isWebGLMultisampleRenderTarget = !0;
        class wt {
            constructor(t = 0, e = 0, n = 0, r = 1) {
                this._x = t, this._y = e, this._z = n, this._w = r
            }
            static slerp(t, e, n, r) {
                return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, r)
            }
            static slerpFlat(t, e, n, r, o, l, c) {
                let h = n[r + 0],
                    d = n[r + 1],
                    f = n[r + 2],
                    m = n[r + 3];
                const v = o[l + 0],
                    y = o[l + 1],
                    _ = o[l + 2],
                    x = o[l + 3];
                if (0 === c) return t[e + 0] = h, t[e + 1] = d, t[e + 2] = f, void(t[e + 3] = m);
                if (1 === c) return t[e + 0] = v, t[e + 1] = y, t[e + 2] = _, void(t[e + 3] = x);
                if (m !== x || h !== v || d !== y || f !== _) {
                    let s = 1 - c;
                    const t = h * v + d * y + f * _ + m * x,
                        e = t >= 0 ? 1 : -1,
                        n = 1 - t * t;
                    if (n > Number.EPSILON) {
                        const r = Math.sqrt(n),
                            o = Math.atan2(r, t * e);
                        s = Math.sin(s * o) / r, c = Math.sin(c * o) / r
                    }
                    const r = c * e;
                    if (h = h * s + v * r, d = d * s + y * r, f = f * s + _ * r, m = m * s + x * r, s === 1 - c) {
                        const t = 1 / Math.sqrt(h * h + d * d + f * f + m * m);
                        h *= t, d *= t, f *= t, m *= t
                    }
                }
                t[e] = h, t[e + 1] = d, t[e + 2] = f, t[e + 3] = m
            }
            static multiplyQuaternionsFlat(t, e, n, r, o, l) {
                const c = n[r],
                    h = n[r + 1],
                    d = n[r + 2],
                    f = n[r + 3],
                    m = o[l],
                    v = o[l + 1],
                    y = o[l + 2],
                    _ = o[l + 3];
                return t[e] = c * _ + f * m + h * y - d * v, t[e + 1] = h * _ + f * v + d * m - c * y, t[e + 2] = d * _ + f * y + c * v - h * m, t[e + 3] = f * _ - c * m - h * v - d * y, t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t, this._onChangeCallback()
            }
            set(t, e, n, r) {
                return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }
            copy(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
            }
            setFromEuler(t, e) {
                if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                const n = t._x,
                    r = t._y,
                    o = t._z,
                    l = t._order,
                    c = Math.cos,
                    h = Math.sin,
                    d = c(n / 2),
                    f = c(r / 2),
                    m = c(o / 2),
                    v = h(n / 2),
                    y = h(r / 2),
                    _ = h(o / 2);
                switch (l) {
                    case "XYZ":
                        this._x = v * f * m + d * y * _, this._y = d * y * m - v * f * _, this._z = d * f * _ + v * y * m, this._w = d * f * m - v * y * _;
                        break;
                    case "YXZ":
                        this._x = v * f * m + d * y * _, this._y = d * y * m - v * f * _, this._z = d * f * _ - v * y * m, this._w = d * f * m + v * y * _;
                        break;
                    case "ZXY":
                        this._x = v * f * m - d * y * _, this._y = d * y * m + v * f * _, this._z = d * f * _ + v * y * m, this._w = d * f * m - v * y * _;
                        break;
                    case "ZYX":
                        this._x = v * f * m - d * y * _, this._y = d * y * m + v * f * _, this._z = d * f * _ - v * y * m, this._w = d * f * m + v * y * _;
                        break;
                    case "YZX":
                        this._x = v * f * m + d * y * _, this._y = d * y * m + v * f * _, this._z = d * f * _ - v * y * m, this._w = d * f * m - v * y * _;
                        break;
                    case "XZY":
                        this._x = v * f * m - d * y * _, this._y = d * y * m - v * f * _, this._z = d * f * _ + v * y * m, this._w = d * f * m + v * y * _;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l)
                }
                return !1 !== e && this._onChangeCallback(), this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2,
                    s = Math.sin(n);
                return this._x = t.x * s, this._y = t.y * s, this._z = t.z * s, this._w = Math.cos(n), this._onChangeCallback(), this
            }
            setFromRotationMatrix(t) {
                const e = t.elements,
                    n = e[0],
                    r = e[4],
                    o = e[8],
                    l = e[1],
                    c = e[5],
                    h = e[9],
                    d = e[2],
                    f = e[6],
                    m = e[10],
                    v = n + c + m;
                if (v > 0) {
                    const s = .5 / Math.sqrt(v + 1);
                    this._w = .25 / s, this._x = (f - h) * s, this._y = (o - d) * s, this._z = (l - r) * s
                } else if (n > c && n > m) {
                    const s = 2 * Math.sqrt(1 + n - c - m);
                    this._w = (f - h) / s, this._x = .25 * s, this._y = (r + l) / s, this._z = (o + d) / s
                } else if (c > m) {
                    const s = 2 * Math.sqrt(1 + c - n - m);
                    this._w = (o - d) / s, this._x = (r + l) / s, this._y = .25 * s, this._z = (h + f) / s
                } else {
                    const s = 2 * Math.sqrt(1 + m - n - c);
                    this._w = (l - r) / s, this._x = (o + d) / s, this._y = (h + f) / s, this._z = .25 * s
                }
                return this._onChangeCallback(), this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
            }
            angleTo(q) {
                return 2 * Math.acos(Math.abs(at(this.dot(q), -1, 1)))
            }
            rotateTowards(q, t) {
                const e = this.angleTo(q);
                if (0 === e) return this;
                const n = Math.min(1, t / e);
                return this.slerp(q, n), this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
            }
            multiply(q, p) {
                return void 0 !== p ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(q, p)) : this.multiplyQuaternions(this, q)
            }
            premultiply(q) {
                return this.multiplyQuaternions(q, this)
            }
            multiplyQuaternions(a, b) {
                const t = a._x,
                    e = a._y,
                    n = a._z,
                    r = a._w,
                    o = b._x,
                    l = b._y,
                    c = b._z,
                    h = b._w;
                return this._x = t * h + r * o + e * c - n * l, this._y = e * h + r * l + n * o - t * c, this._z = n * h + r * c + t * l - e * o, this._w = r * h - t * o - e * l - n * c, this._onChangeCallback(), this
            }
            slerp(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                const n = this._x,
                    r = this._y,
                    o = this._z,
                    l = this._w;
                let c = l * t._w + n * t._x + r * t._y + o * t._z;
                if (c < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, c = -c) : this.copy(t), c >= 1) return this._w = l, this._x = n, this._y = r, this._z = o, this;
                const h = 1 - c * c;
                if (h <= Number.EPSILON) {
                    const s = 1 - e;
                    return this._w = s * l + e * this._w, this._x = s * n + e * this._x, this._y = s * r + e * this._y, this._z = s * o + e * this._z, this.normalize(), this._onChangeCallback(), this
                }
                const d = Math.sqrt(h),
                    f = Math.atan2(d, c),
                    m = Math.sin((1 - e) * f) / d,
                    v = Math.sin(e * f) / d;
                return this._w = l * m + this._w * v, this._x = n * m + this._x * v, this._y = r * m + this._y * v, this._z = o * m + this._z * v, this._onChangeCallback(), this
            }
            slerpQuaternions(t, e, n) {
                this.copy(t).slerp(e, n)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e = 0) {
                return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() {}
        }
        wt.prototype.isQuaternion = !0;
        class Mt {
            constructor(t = 0, e = 0, n = 0) {
                this.x = t, this.y = e, this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
            }
            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this
            }
            setX(t) {
                return this.x = t, this
            }
            setY(t) {
                return this.y = t, this
            }
            setZ(t) {
                return this.z = t, this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }
            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            }
            addScalar(s) {
                return this.x += s, this.y += s, this.z += s, this
            }
            addVectors(a, b) {
                return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this
            }
            addScaledVector(t, s) {
                return this.x += t.x * s, this.y += t.y * s, this.z += t.z * s, this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            }
            subScalar(s) {
                return this.x -= s, this.y -= s, this.z -= s, this
            }
            subVectors(a, b) {
                return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            }
            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            }
            multiplyVectors(a, b) {
                return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this
            }
            applyEuler(t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Tt.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(Tt.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    o = t.elements;
                return this.x = o[0] * e + o[3] * n + o[6] * r, this.y = o[1] * e + o[4] * n + o[7] * r, this.z = o[2] * e + o[5] * n + o[8] * r, this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    o = t.elements,
                    l = 1 / (o[3] * e + o[7] * n + o[11] * r + o[15]);
                return this.x = (o[0] * e + o[4] * n + o[8] * r + o[12]) * l, this.y = (o[1] * e + o[5] * n + o[9] * r + o[13]) * l, this.z = (o[2] * e + o[6] * n + o[10] * r + o[14]) * l, this
            }
            applyQuaternion(q) {
                const t = this.x,
                    e = this.y,
                    n = this.z,
                    r = q.x,
                    o = q.y,
                    l = q.z,
                    c = q.w,
                    h = c * t + o * n - l * e,
                    d = c * e + l * t - r * n,
                    f = c * n + r * e - o * t,
                    m = -r * t - o * e - l * n;
                return this.x = h * c + m * -r + d * -l - f * -o, this.y = d * c + m * -o + f * -r - h * -l, this.z = f * c + m * -l + h * -o - d * -r, this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x,
                    n = this.y,
                    r = this.z,
                    o = t.elements;
                return this.x = o[0] * e + o[4] * n + o[8] * r, this.y = o[1] * e + o[5] * n + o[9] * r, this.z = o[2] * e + o[6] * n + o[10] * r, this.normalize()
            }
            divide(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
            }
            cross(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
            }
            crossVectors(a, b) {
                const t = a.x,
                    e = a.y,
                    n = a.z,
                    r = b.x,
                    o = b.y,
                    l = b.z;
                return this.x = e * l - n * o, this.y = n * r - t * l, this.z = t * o - e * r, this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e) return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return St.copy(this).projectOnVector(t), this.sub(St)
            }
            reflect(t) {
                return this.sub(St.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(at(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x,
                    n = this.y - t.y,
                    r = this.z - t.z;
                return e * e + n * n + r * r
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(s) {
                return this.setFromSphericalCoords(s.radius, s.phi, s.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const r = Math.sin(e) * t;
                return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length(),
                    n = this.setFromMatrixColumn(t, 1).length(),
                    r = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = n, this.z = r, this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
        }
        Mt.prototype.isVector3 = !0;
        const St = new Mt,
            Tt = new wt;
        class Et {
            constructor(t = new Mt(1 / 0, 1 / 0, 1 / 0), e = new Mt(-1 / 0, -1 / 0, -1 / 0)) {
                this.min = t, this.max = e
            }
            set(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }
            setFromArray(t) {
                let e = 1 / 0,
                    n = 1 / 0,
                    r = 1 / 0,
                    o = -1 / 0,
                    l = -1 / 0,
                    c = -1 / 0;
                for (let i = 0, h = t.length; i < h; i += 3) {
                    const h = t[i],
                        d = t[i + 1],
                        f = t[i + 2];
                    h < e && (e = h), d < n && (n = d), f < r && (r = f), h > o && (o = h), d > l && (l = d), f > c && (c = f)
                }
                return this.min.set(e, n, r), this.max.set(o, l, c), this
            }
            setFromBufferAttribute(t) {
                let e = 1 / 0,
                    n = 1 / 0,
                    r = 1 / 0,
                    o = -1 / 0,
                    l = -1 / 0,
                    c = -1 / 0;
                for (let i = 0, h = t.count; i < h; i++) {
                    const h = t.getX(i),
                        d = t.getY(i),
                        f = t.getZ(i);
                    h < e && (e = h), d < n && (n = d), f < r && (r = f), h > o && (o = h), d > l && (l = d), f > c && (c = f)
                }
                return this.min.set(e, n, r), this.max.set(o, l, c), this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let i = 0, e = t.length; i < e; i++) this.expandByPoint(t[i]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = Ct.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }
            setFromObject(object) {
                return this.makeEmpty(), this.expandByObject(object)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t), this.max.max(t), this
            }
            expandByVector(t) {
                return this.min.sub(t), this.max.add(t), this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }
            expandByObject(object) {
                object.updateWorldMatrix(!1, !1);
                const t = object.geometry;
                void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), Lt.copy(t.boundingBox), Lt.applyMatrix4(object.matrixWorld), this.union(Lt));
                const e = object.children;
                for (let i = 0, t = e.length; i < t; i++) this.expandByObject(e[i]);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, Ct), Ct.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty()) return !1;
                this.getCenter(Nt), Ft.subVectors(this.max, Nt), kt.subVectors(t.a, Nt), Rt.subVectors(t.b, Nt), Pt.subVectors(t.c, Nt), Dt.subVectors(Rt, kt), Ot.subVectors(Pt, Rt), It.subVectors(kt, Pt);
                let e = [0, -Dt.z, Dt.y, 0, -Ot.z, Ot.y, 0, -It.z, It.y, Dt.z, 0, -Dt.x, Ot.z, 0, -Ot.x, It.z, 0, -It.x, -Dt.y, Dt.x, 0, -Ot.y, Ot.x, 0, -It.y, It.x, 0];
                return !!Ut(e, kt, Rt, Pt, Ft) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Ut(e, kt, Rt, Pt, Ft) && (zt.crossVectors(Dt, Ot), e = [zt.x, zt.y, zt.z], Ut(e, kt, Rt, Pt, Ft)))
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return Ct.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            getBoundingSphere(t) {
                return this.getCenter(t.center), t.radius = .5 * this.getSize(Ct).length(), t
            }
            intersect(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (At[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), At[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), At[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), At[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), At[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), At[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), At[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), At[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(At)), this
            }
            translate(t) {
                return this.min.add(t), this.max.add(t), this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        Et.prototype.isBox3 = !0;
        const At = [new Mt, new Mt, new Mt, new Mt, new Mt, new Mt, new Mt, new Mt],
            Ct = new Mt,
            Lt = new Et,
            kt = new Mt,
            Rt = new Mt,
            Pt = new Mt,
            Dt = new Mt,
            Ot = new Mt,
            It = new Mt,
            Nt = new Mt,
            Ft = new Mt,
            zt = new Mt,
            Bt = new Mt;

        function Ut(t, e, n, r, o) {
            for (let i = 0, l = t.length - 3; i <= l; i += 3) {
                Bt.fromArray(t, i);
                const l = o.x * Math.abs(Bt.x) + o.y * Math.abs(Bt.y) + o.z * Math.abs(Bt.z),
                    c = e.dot(Bt),
                    h = n.dot(Bt),
                    d = r.dot(Bt);
                if (Math.max(-Math.max(c, h, d), Math.min(c, h, d)) > l) return !1
            }
            return !0
        }
        const Ht = new Et,
            jt = new Mt,
            Vt = new Mt,
            Gt = new Mt;
        class Wt {
            constructor(t = new Mt, e = -1) {
                this.center = t, this.radius = e
            }
            set(t, e) {
                return this.center.copy(t), this.radius = e, this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : Ht.setFromPoints(t).getCenter(n);
                let r = 0;
                for (let i = 0, e = t.length; i < e; i++) r = Math.max(r, n.distanceToSquared(t[i]));
                return this.radius = Math.sqrt(r), this
            }
            copy(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            }
            getBoundingBox(t) {
                return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            }
            translate(t) {
                return this.center.add(t), this
            }
            expandByPoint(t) {
                Gt.subVectors(t, this.center);
                const e = Gt.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e),
                        n = .5 * (t - this.radius);
                    this.center.add(Gt.multiplyScalar(n / t)), this.radius += n
                }
                return this
            }
            union(t) {
                return Vt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(jt.copy(t.center).add(Vt)), this.expandByPoint(jt.copy(t.center).sub(Vt)), this
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const qt = new Mt,
            Xt = new Mt,
            $t = new Mt,
            Yt = new Mt,
            Zt = new Mt,
            Jt = new Mt,
            Kt = new Mt;
        class Qt {
            constructor(t = new Mt, e = new Mt(0, 0, -1)) {
                this.origin = t, this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            }
            copy(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            }
            at(t, e) {
                return e.copy(this.direction).multiplyScalar(t).add(this.origin)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            }
            recast(t) {
                return this.origin.copy(this.at(t, qt)), this
            }
            closestPointToPoint(t, e) {
                e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = qt.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (qt.copy(this.direction).multiplyScalar(e).add(this.origin), qt.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, r) {
                Xt.copy(t).add(e).multiplyScalar(.5), $t.copy(e).sub(t).normalize(), Yt.copy(this.origin).sub(Xt);
                const o = .5 * t.distanceTo(e),
                    l = -this.direction.dot($t),
                    c = Yt.dot(this.direction),
                    h = -Yt.dot($t),
                    d = Yt.lengthSq(),
                    f = Math.abs(1 - l * l);
                let m, v, y, _;
                if (f > 0)
                    if (m = l * h - c, v = l * c - h, _ = o * f, m >= 0)
                        if (v >= -_)
                            if (v <= _) {
                                const t = 1 / f;
                                m *= t, v *= t, y = m * (m + l * v + 2 * c) + v * (l * m + v + 2 * h) + d
                            } else v = o, m = Math.max(0, -(l * v + c)), y = -m * m + v * (v + 2 * h) + d;
                else v = -o, m = Math.max(0, -(l * v + c)), y = -m * m + v * (v + 2 * h) + d;
                else v <= -_ ? (m = Math.max(0, -(-l * o + c)), v = m > 0 ? -o : Math.min(Math.max(-o, -h), o), y = -m * m + v * (v + 2 * h) + d) : v <= _ ? (m = 0, v = Math.min(Math.max(-o, -h), o), y = v * (v + 2 * h) + d) : (m = Math.max(0, -(l * o + c)), v = m > 0 ? o : Math.min(Math.max(-o, -h), o), y = -m * m + v * (v + 2 * h) + d);
                else v = l > 0 ? -o : o, m = Math.max(0, -(l * v + c)), y = -m * m + v * (v + 2 * h) + d;
                return n && n.copy(this.direction).multiplyScalar(m).add(this.origin), r && r.copy($t).multiplyScalar(v).add(Xt), y
            }
            intersectSphere(t, e) {
                qt.subVectors(t.center, this.origin);
                const n = qt.dot(this.direction),
                    r = qt.dot(qt) - n * n,
                    o = t.radius * t.radius;
                if (r > o) return null;
                const l = Math.sqrt(o - r),
                    c = n - l,
                    h = n + l;
                return c < 0 && h < 0 ? null : c < 0 ? this.at(h, e) : this.at(c, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                if (0 === e) return !0;
                return t.normal.dot(this.direction) * e < 0
            }
            intersectBox(t, e) {
                let n, r, o, l, c, h;
                const d = 1 / this.direction.x,
                    f = 1 / this.direction.y,
                    m = 1 / this.direction.z,
                    v = this.origin;
                return d >= 0 ? (n = (t.min.x - v.x) * d, r = (t.max.x - v.x) * d) : (n = (t.max.x - v.x) * d, r = (t.min.x - v.x) * d), f >= 0 ? (o = (t.min.y - v.y) * f, l = (t.max.y - v.y) * f) : (o = (t.max.y - v.y) * f, l = (t.min.y - v.y) * f), n > l || o > r ? null : ((o > n || n != n) && (n = o), (l < r || r != r) && (r = l), m >= 0 ? (c = (t.min.z - v.z) * m, h = (t.max.z - v.z) * m) : (c = (t.max.z - v.z) * m, h = (t.min.z - v.z) * m), n > h || c > r ? null : ((c > n || n != n) && (n = c), (h < r || r != r) && (r = h), r < 0 ? null : this.at(n >= 0 ? n : r, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, qt)
            }
            intersectTriangle(a, b, t, e, n) {
                Zt.subVectors(b, a), Jt.subVectors(t, a), Kt.crossVectors(Zt, Jt);
                let r, o = this.direction.dot(Kt);
                if (o > 0) {
                    if (e) return null;
                    r = 1
                } else {
                    if (!(o < 0)) return null;
                    r = -1, o = -o
                }
                Yt.subVectors(this.origin, a);
                const l = r * this.direction.dot(Jt.crossVectors(Yt, Jt));
                if (l < 0) return null;
                const c = r * this.direction.dot(Zt.cross(Yt));
                if (c < 0) return null;
                if (l + c > o) return null;
                const h = -r * Yt.dot(Kt);
                return h < 0 ? null : this.at(h / o, n)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class te {
            constructor() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, n, r, o, l, c, h, d, f, m, v, y, _, x, w) {
                const M = this.elements;
                return M[0] = t, M[4] = e, M[8] = n, M[12] = r, M[1] = o, M[5] = l, M[9] = c, M[13] = h, M[2] = d, M[6] = f, M[10] = m, M[14] = v, M[3] = y, M[7] = _, M[11] = x, M[15] = w, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            clone() {
                return (new te).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements,
                    n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
            }
            copyPosition(t) {
                const e = this.elements,
                    n = t.elements;
                return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
            }
            extractRotation(t) {
                const e = this.elements,
                    n = t.elements,
                    r = 1 / ee.setFromMatrixColumn(t, 0).length(),
                    o = 1 / ee.setFromMatrixColumn(t, 1).length(),
                    l = 1 / ee.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * o, e[5] = n[5] * o, e[6] = n[6] * o, e[7] = 0, e[8] = n[8] * l, e[9] = n[9] * l, e[10] = n[10] * l, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromEuler(t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                const e = this.elements,
                    n = t.x,
                    r = t.y,
                    o = t.z,
                    a = Math.cos(n),
                    b = Math.sin(n),
                    l = Math.cos(r),
                    c = Math.sin(r),
                    h = Math.cos(o),
                    d = Math.sin(o);
                if ("XYZ" === t.order) {
                    const t = a * h,
                        n = a * d,
                        r = b * h,
                        o = b * d;
                    e[0] = l * h, e[4] = -l * d, e[8] = c, e[1] = n + r * c, e[5] = t - o * c, e[9] = -b * l, e[2] = o - t * c, e[6] = r + n * c, e[10] = a * l
                } else if ("YXZ" === t.order) {
                    const t = l * h,
                        n = l * d,
                        r = c * h,
                        o = c * d;
                    e[0] = t + o * b, e[4] = r * b - n, e[8] = a * c, e[1] = a * d, e[5] = a * h, e[9] = -b, e[2] = n * b - r, e[6] = o + t * b, e[10] = a * l
                } else if ("ZXY" === t.order) {
                    const t = l * h,
                        n = l * d,
                        r = c * h,
                        o = c * d;
                    e[0] = t - o * b, e[4] = -a * d, e[8] = r + n * b, e[1] = n + r * b, e[5] = a * h, e[9] = o - t * b, e[2] = -a * c, e[6] = b, e[10] = a * l
                } else if ("ZYX" === t.order) {
                    const t = a * h,
                        n = a * d,
                        r = b * h,
                        o = b * d;
                    e[0] = l * h, e[4] = r * c - n, e[8] = t * c + o, e[1] = l * d, e[5] = o * c + t, e[9] = n * c - r, e[2] = -c, e[6] = b * l, e[10] = a * l
                } else if ("YZX" === t.order) {
                    const t = a * l,
                        n = a * c,
                        r = b * l,
                        o = b * c;
                    e[0] = l * h, e[4] = o - t * d, e[8] = r * d + n, e[1] = d, e[5] = a * h, e[9] = -b * h, e[2] = -c * h, e[6] = n * d + r, e[10] = t - o * d
                } else if ("XZY" === t.order) {
                    const t = a * l,
                        n = a * c,
                        r = b * l,
                        o = b * c;
                    e[0] = l * h, e[4] = -d, e[8] = c * h, e[1] = t * d + o, e[5] = a * h, e[9] = n * d - r, e[2] = r * d - n, e[6] = b * h, e[10] = o * d + t
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }
            makeRotationFromQuaternion(q) {
                return this.compose(re, q, ie)
            }
            lookAt(t, e, n) {
                const r = this.elements;
                return se.subVectors(t, e), 0 === se.lengthSq() && (se.z = 1), se.normalize(), oe.crossVectors(n, se), 0 === oe.lengthSq() && (1 === Math.abs(n.z) ? se.x += 1e-4 : se.z += 1e-4, se.normalize(), oe.crossVectors(n, se)), oe.normalize(), ae.crossVectors(se, oe), r[0] = oe.x, r[4] = ae.x, r[8] = se.x, r[1] = oe.y, r[5] = ae.y, r[9] = se.y, r[2] = oe.z, r[6] = ae.z, r[10] = se.z, this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(a, b) {
                const t = a.elements,
                    e = b.elements,
                    n = this.elements,
                    r = t[0],
                    o = t[4],
                    l = t[8],
                    c = t[12],
                    h = t[1],
                    d = t[5],
                    f = t[9],
                    m = t[13],
                    v = t[2],
                    y = t[6],
                    _ = t[10],
                    x = t[14],
                    w = t[3],
                    M = t[7],
                    S = t[11],
                    T = t[15],
                    E = e[0],
                    A = e[4],
                    C = e[8],
                    L = e[12],
                    k = e[1],
                    R = e[5],
                    P = e[9],
                    D = e[13],
                    O = e[2],
                    I = e[6],
                    N = e[10],
                    F = e[14],
                    z = e[3],
                    B = e[7],
                    U = e[11],
                    H = e[15];
                return n[0] = r * E + o * k + l * O + c * z, n[4] = r * A + o * R + l * I + c * B, n[8] = r * C + o * P + l * N + c * U, n[12] = r * L + o * D + l * F + c * H, n[1] = h * E + d * k + f * O + m * z, n[5] = h * A + d * R + f * I + m * B, n[9] = h * C + d * P + f * N + m * U, n[13] = h * L + d * D + f * F + m * H, n[2] = v * E + y * k + _ * O + x * z, n[6] = v * A + y * R + _ * I + x * B, n[10] = v * C + y * P + _ * N + x * U, n[14] = v * L + y * D + _ * F + x * H, n[3] = w * E + M * k + S * O + T * z, n[7] = w * A + M * R + S * I + T * B, n[11] = w * C + M * P + S * N + T * U, n[15] = w * L + M * D + S * F + T * H, this
            }
            multiplyScalar(s) {
                const t = this.elements;
                return t[0] *= s, t[4] *= s, t[8] *= s, t[12] *= s, t[1] *= s, t[5] *= s, t[9] *= s, t[13] *= s, t[2] *= s, t[6] *= s, t[10] *= s, t[14] *= s, t[3] *= s, t[7] *= s, t[11] *= s, t[15] *= s, this
            }
            determinant() {
                const t = this.elements,
                    e = t[0],
                    n = t[4],
                    r = t[8],
                    o = t[12],
                    l = t[1],
                    c = t[5],
                    h = t[9],
                    d = t[13],
                    f = t[2],
                    m = t[6],
                    v = t[10],
                    y = t[14];
                return t[3] * (+o * h * m - r * d * m - o * c * v + n * d * v + r * c * y - n * h * y) + t[7] * (+e * h * y - e * d * v + o * l * v - r * l * y + r * d * f - o * h * f) + t[11] * (+e * d * m - e * c * y - o * l * m + n * l * y + o * c * f - n * d * f) + t[15] * (-r * c * f - e * h * m + e * c * v + r * l * m - n * l * v + n * h * f)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            }
            setPosition(t, e, n) {
                const r = this.elements;
                return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this
            }
            invert() {
                const t = this.elements,
                    e = t[0],
                    n = t[1],
                    r = t[2],
                    o = t[3],
                    l = t[4],
                    c = t[5],
                    h = t[6],
                    d = t[7],
                    f = t[8],
                    m = t[9],
                    v = t[10],
                    y = t[11],
                    _ = t[12],
                    x = t[13],
                    w = t[14],
                    M = t[15],
                    S = m * w * d - x * v * d + x * h * y - c * w * y - m * h * M + c * v * M,
                    T = _ * v * d - f * w * d - _ * h * y + l * w * y + f * h * M - l * v * M,
                    E = f * x * d - _ * m * d + _ * c * y - l * x * y - f * c * M + l * m * M,
                    A = _ * m * h - f * x * h - _ * c * v + l * x * v + f * c * w - l * m * w,
                    C = e * S + n * T + r * E + o * A;
                if (0 === C) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const L = 1 / C;
                return t[0] = S * L, t[1] = (x * v * o - m * w * o - x * r * y + n * w * y + m * r * M - n * v * M) * L, t[2] = (c * w * o - x * h * o + x * r * d - n * w * d - c * r * M + n * h * M) * L, t[3] = (m * h * o - c * v * o - m * r * d + n * v * d + c * r * y - n * h * y) * L, t[4] = T * L, t[5] = (f * w * o - _ * v * o + _ * r * y - e * w * y - f * r * M + e * v * M) * L, t[6] = (_ * h * o - l * w * o - _ * r * d + e * w * d + l * r * M - e * h * M) * L, t[7] = (l * v * o - f * h * o + f * r * d - e * v * d - l * r * y + e * h * y) * L, t[8] = E * L, t[9] = (_ * m * o - f * x * o - _ * n * y + e * x * y + f * n * M - e * m * M) * L, t[10] = (l * x * o - _ * c * o + _ * n * d - e * x * d - l * n * M + e * c * M) * L, t[11] = (f * c * o - l * m * o - f * n * d + e * m * d + l * n * y - e * c * y) * L, t[12] = A * L, t[13] = (f * x * r - _ * m * r + _ * n * v - e * x * v - f * n * w + e * m * w) * L, t[14] = (_ * c * r - l * x * r - _ * n * h + e * x * h + l * n * w - e * c * w) * L, t[15] = (l * m * r - f * c * r + f * n * h - e * m * h - l * n * v + e * c * v) * L, this
            }
            scale(t) {
                const e = this.elements,
                    n = t.x,
                    r = t.y,
                    o = t.z;
                return e[0] *= n, e[4] *= r, e[8] *= o, e[1] *= n, e[5] *= r, e[9] *= o, e[2] *= n, e[6] *= r, e[10] *= o, e[3] *= n, e[7] *= r, e[11] *= o, this
            }
            getMaxScaleOnAxis() {
                const t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, r))
            }
            makeTranslation(t, e, n) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            }
            makeRotationX(t) {
                const e = Math.cos(t),
                    s = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -s, 0, 0, s, e, 0, 0, 0, 0, 1), this
            }
            makeRotationY(t) {
                const e = Math.cos(t),
                    s = Math.sin(t);
                return this.set(e, 0, s, 0, 0, 1, 0, 0, -s, 0, e, 0, 0, 0, 0, 1), this
            }
            makeRotationZ(t) {
                const e = Math.cos(t),
                    s = Math.sin(t);
                return this.set(e, -s, 0, 0, s, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e),
                    s = Math.sin(e),
                    r = 1 - n,
                    o = t.x,
                    l = t.y,
                    c = t.z,
                    h = r * o,
                    d = r * l;
                return this.set(h * o + n, h * l - s * c, h * c + s * l, 0, h * l + s * c, d * l + n, d * c - s * o, 0, h * c - s * l, d * c + s * o, r * c * c + n, 0, 0, 0, 0, 1), this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            }
            makeShear(t, e, n, r, o, l) {
                return this.set(1, n, o, 0, t, 1, l, 0, e, r, 1, 0, 0, 0, 0, 1), this
            }
            compose(t, e, n) {
                const r = this.elements,
                    o = e._x,
                    l = e._y,
                    c = e._z,
                    h = e._w,
                    d = o + o,
                    f = l + l,
                    m = c + c,
                    v = o * d,
                    y = o * f,
                    _ = o * m,
                    x = l * f,
                    w = l * m,
                    M = c * m,
                    S = h * d,
                    T = h * f,
                    E = h * m,
                    A = n.x,
                    C = n.y,
                    L = n.z;
                return r[0] = (1 - (x + M)) * A, r[1] = (y + E) * A, r[2] = (_ - T) * A, r[3] = 0, r[4] = (y - E) * C, r[5] = (1 - (v + M)) * C, r[6] = (w + S) * C, r[7] = 0, r[8] = (_ + T) * L, r[9] = (w - S) * L, r[10] = (1 - (v + x)) * L, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
            }
            decompose(t, e, n) {
                const r = this.elements;
                let o = ee.set(r[0], r[1], r[2]).length();
                const l = ee.set(r[4], r[5], r[6]).length(),
                    c = ee.set(r[8], r[9], r[10]).length();
                this.determinant() < 0 && (o = -o), t.x = r[12], t.y = r[13], t.z = r[14], ne.copy(this);
                const h = 1 / o,
                    d = 1 / l,
                    f = 1 / c;
                return ne.elements[0] *= h, ne.elements[1] *= h, ne.elements[2] *= h, ne.elements[4] *= d, ne.elements[5] *= d, ne.elements[6] *= d, ne.elements[8] *= f, ne.elements[9] *= f, ne.elements[10] *= f, e.setFromRotationMatrix(ne), n.x = o, n.y = l, n.z = c, this
            }
            makePerspective(t, e, n, r, o, l) {
                void 0 === l && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                const c = this.elements,
                    h = 2 * o / (e - t),
                    d = 2 * o / (n - r),
                    a = (e + t) / (e - t),
                    b = (n + r) / (n - r),
                    f = -(l + o) / (l - o),
                    m = -2 * l * o / (l - o);
                return c[0] = h, c[4] = 0, c[8] = a, c[12] = 0, c[1] = 0, c[5] = d, c[9] = b, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = f, c[14] = m, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this
            }
            makeOrthographic(t, e, n, r, o, l) {
                const c = this.elements,
                    h = 1 / (e - t),
                    d = 1 / (n - r),
                    p = 1 / (l - o),
                    f = (e + t) * h,
                    m = (n + r) * d,
                    v = (l + o) * p;
                return c[0] = 2 * h, c[4] = 0, c[8] = 0, c[12] = -f, c[1] = 0, c[5] = 2 * d, c[9] = 0, c[13] = -m, c[2] = 0, c[6] = 0, c[10] = -2 * p, c[14] = -v, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this
            }
            equals(t) {
                const e = this.elements,
                    n = t.elements;
                for (let i = 0; i < 16; i++)
                    if (e[i] !== n[i]) return !1;
                return !0
            }
            fromArray(t, e = 0) {
                for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
            }
        }
        te.prototype.isMatrix4 = !0;
        const ee = new Mt,
            ne = new te,
            re = new Mt(0, 0, 0),
            ie = new Mt(1, 1, 1),
            oe = new Mt,
            ae = new Mt,
            se = new Mt,
            le = new te,
            ce = new wt;
        class ue {
            constructor(t = 0, e = 0, n = 0, r = ue.DefaultOrder) {
                this._x = t, this._y = e, this._z = n, this._order = r
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t, this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t, this._onChangeCallback()
            }
            set(t, e, n, r = this._order) {
                return this._x = t, this._y = e, this._z = n, this._order = r, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }
            copy(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
            }
            setFromRotationMatrix(t, e = this._order, n = !0) {
                const r = t.elements,
                    o = r[0],
                    l = r[4],
                    c = r[8],
                    h = r[1],
                    d = r[5],
                    f = r[9],
                    m = r[2],
                    v = r[6],
                    y = r[10];
                switch (e) {
                    case "XYZ":
                        this._y = Math.asin(at(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-f, y), this._z = Math.atan2(-l, o)) : (this._x = Math.atan2(v, d), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-at(f, -1, 1)), Math.abs(f) < .9999999 ? (this._y = Math.atan2(c, y), this._z = Math.atan2(h, d)) : (this._y = Math.atan2(-m, o), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(at(v, -1, 1)), Math.abs(v) < .9999999 ? (this._y = Math.atan2(-m, y), this._z = Math.atan2(-l, d)) : (this._y = 0, this._z = Math.atan2(h, o));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-at(m, -1, 1)), Math.abs(m) < .9999999 ? (this._x = Math.atan2(v, y), this._z = Math.atan2(h, o)) : (this._x = 0, this._z = Math.atan2(-l, d));
                        break;
                    case "YZX":
                        this._z = Math.asin(at(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(-f, d), this._y = Math.atan2(-m, o)) : (this._x = 0, this._y = Math.atan2(c, y));
                        break;
                    case "XZY":
                        this._z = Math.asin(-at(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(v, d), this._y = Math.atan2(c, o)) : (this._x = Math.atan2(-f, y), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e, !0 === n && this._onChangeCallback(), this
            }
            setFromQuaternion(q, t, e) {
                return le.makeRotationFromQuaternion(q), this.setFromRotationMatrix(le, t, e)
            }
            setFromVector3(t, e = this._order) {
                return this.set(t.x, t.y, t.z, e)
            }
            reorder(t) {
                return ce.setFromEuler(this), this.setFromQuaternion(ce, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
            }
            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            }
            toVector3(t) {
                return t ? t.set(this._x, this._y, this._z) : new Mt(this._x, this._y, this._z)
            }
            _onChange(t) {
                return this._onChangeCallback = t, this
            }
            _onChangeCallback() {}
        }
        ue.prototype.isEuler = !0, ue.DefaultOrder = "XYZ", ue.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        class he {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = 1 << t | 0
            }
            enable(t) {
                this.mask |= 1 << t | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t | 0
            }
            disable(t) {
                this.mask &= ~(1 << t | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 != (this.mask & t.mask)
            }
        }
        let de = 0;
        const pe = new Mt,
            fe = new wt,
            me = new te,
            ge = new Mt,
            ve = new Mt,
            ye = new Mt,
            _e = new wt,
            xe = new Mt(1, 0, 0),
            be = new Mt(0, 1, 0),
            we = new Mt(0, 0, 1),
            Me = {
                type: "added"
            },
            Se = {
                type: "removed"
            };
        class Te extends tt {
            constructor() {
                super(), Object.defineProperty(this, "id", {
                    value: de++
                }), this.uuid = ot(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Te.DefaultUp.clone();
                const t = new Mt,
                    e = new ue,
                    n = new wt,
                    r = new Mt(1, 1, 1);
                e._onChange((function() {
                    n.setFromEuler(e, !1)
                })), n._onChange((function() {
                    e.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: r
                    },
                    modelViewMatrix: {
                        value: new te
                    },
                    normalMatrix: {
                        value: new pt
                    }
                }), this.matrix = new te, this.matrixWorld = new te, this.matrixAutoUpdate = Te.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new he, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(t) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(q) {
                return this.quaternion.premultiply(q), this
            }
            setRotationFromAxisAngle(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }
            setRotationFromEuler(t) {
                this.quaternion.setFromEuler(t, !0)
            }
            setRotationFromMatrix(t) {
                this.quaternion.setFromRotationMatrix(t)
            }
            setRotationFromQuaternion(q) {
                this.quaternion.copy(q)
            }
            rotateOnAxis(t, e) {
                return fe.setFromAxisAngle(t, e), this.quaternion.multiply(fe), this
            }
            rotateOnWorldAxis(t, e) {
                return fe.setFromAxisAngle(t, e), this.quaternion.premultiply(fe), this
            }
            rotateX(t) {
                return this.rotateOnAxis(xe, t)
            }
            rotateY(t) {
                return this.rotateOnAxis(be, t)
            }
            rotateZ(t) {
                return this.rotateOnAxis(we, t)
            }
            translateOnAxis(t, e) {
                return pe.copy(t).applyQuaternion(this.quaternion), this.position.add(pe.multiplyScalar(e)), this
            }
            translateX(t) {
                return this.translateOnAxis(xe, t)
            }
            translateY(t) {
                return this.translateOnAxis(be, t)
            }
            translateZ(t) {
                return this.translateOnAxis(we, t)
            }
            localToWorld(t) {
                return t.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(t) {
                return t.applyMatrix4(me.copy(this.matrixWorld).invert())
            }
            lookAt(t, e, n) {
                t.isVector3 ? ge.copy(t) : ge.set(t, e, n);
                const r = this.parent;
                this.updateWorldMatrix(!0, !1), ve.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? me.lookAt(ve, ge, this.up) : me.lookAt(ge, ve, this.up), this.quaternion.setFromRotationMatrix(me), r && (me.extractRotation(r.matrixWorld), fe.setFromRotationMatrix(me), this.quaternion.premultiply(fe.invert()))
            }
            add(object) {
                if (arguments.length > 1) {
                    for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
                    return this
                }
                return object === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", object), this) : (object && object.isObject3D ? (null !== object.parent && object.parent.remove(object), object.parent = this, this.children.push(object), object.dispatchEvent(Me)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object), this)
            }
            remove(object) {
                if (arguments.length > 1) {
                    for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
                    return this
                }
                const t = this.children.indexOf(object);
                return -1 !== t && (object.parent = null, this.children.splice(t, 1), object.dispatchEvent(Se)), this
            }
            removeFromParent() {
                const t = this.parent;
                return null !== t && t.remove(this), this
            }
            clear() {
                for (let i = 0; i < this.children.length; i++) {
                    const object = this.children[i];
                    object.parent = null, object.dispatchEvent(Se)
                }
                return this.children.length = 0, this
            }
            attach(object) {
                return this.updateWorldMatrix(!0, !1), me.copy(this.matrixWorld).invert(), null !== object.parent && (object.parent.updateWorldMatrix(!0, !1), me.multiply(object.parent.matrixWorld)), object.applyMatrix4(me), this.add(object), object.updateWorldMatrix(!1, !0), this
            }
            getObjectById(t) {
                return this.getObjectByProperty("id", t)
            }
            getObjectByName(t) {
                return this.getObjectByProperty("name", t)
            }
            getObjectByProperty(t, e) {
                if (this[t] === e) return this;
                for (let i = 0, n = this.children.length; i < n; i++) {
                    const object = this.children[i].getObjectByProperty(t, e);
                    if (void 0 !== object) return object
                }
            }
            getWorldPosition(t) {
                return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ve, t, ye), t
            }
            getWorldScale(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ve, _e, t), t
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }
            raycast() {}
            traverse(t) {
                t(this);
                const e = this.children;
                for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t)
            }
            traverseVisible(t) {
                if (!1 === this.visible) return;
                t(this);
                const e = this.children;
                for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
            }
            traverseAncestors(t) {
                const e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                const e = this.children;
                for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
            }
            updateWorldMatrix(t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                    const t = this.children;
                    for (let i = 0, e = t.length; i < e; i++) t[i].updateWorldMatrix(!1, !0)
                }
            }
            toJSON(meta) {
                const t = void 0 === meta || "string" == typeof meta,
                    output = {};
                t && (meta = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {}
                }, output.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const object = {};

                function e(t, element) {
                    return void 0 === t[element.uuid] && (t[element.uuid] = element.toJSON(meta)), element.uuid
                }
                if (object.uuid = this.uuid, object.type = this.type, "" !== this.name && (object.name = this.name), !0 === this.castShadow && (object.castShadow = !0), !0 === this.receiveShadow && (object.receiveShadow = !0), !1 === this.visible && (object.visible = !1), !1 === this.frustumCulled && (object.frustumCulled = !1), 0 !== this.renderOrder && (object.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (object.userData = this.userData), object.layers = this.layers.mask, object.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (object.matrixAutoUpdate = !1), this.isInstancedMesh && (object.type = "InstancedMesh", object.count = this.count, object.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (object.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? object.background = this.background.toJSON() : this.background.isTexture && (object.background = this.background.toJSON(meta).uuid)), this.environment && this.environment.isTexture && (object.environment = this.environment.toJSON(meta).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    object.geometry = e(meta.geometries, this.geometry);
                    const t = this.geometry.parameters;
                    if (void 0 !== t && void 0 !== t.shapes) {
                        const n = t.shapes;
                        if (Array.isArray(n))
                            for (let i = 0, t = n.length; i < t; i++) {
                                const t = n[i];
                                e(meta.shapes, t)
                            } else e(meta.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (object.bindMode = this.bindMode, object.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (e(meta.skeletons, this.skeleton), object.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const t = [];
                        for (let i = 0, n = this.material.length; i < n; i++) t.push(e(meta.materials, this.material[i]));
                        object.material = t
                    } else object.material = e(meta.materials, this.material);
                if (this.children.length > 0) {
                    object.children = [];
                    for (let i = 0; i < this.children.length; i++) object.children.push(this.children[i].toJSON(meta).object)
                }
                if (this.animations.length > 0) {
                    object.animations = [];
                    for (let i = 0; i < this.animations.length; i++) {
                        const t = this.animations[i];
                        object.animations.push(e(meta.animations, t))
                    }
                }
                if (t) {
                    const t = n(meta.geometries),
                        e = n(meta.materials),
                        r = n(meta.textures),
                        o = n(meta.images),
                        l = n(meta.shapes),
                        c = n(meta.skeletons),
                        h = n(meta.animations);
                    t.length > 0 && (output.geometries = t), e.length > 0 && (output.materials = e), r.length > 0 && (output.textures = r), o.length > 0 && (output.images = o), l.length > 0 && (output.shapes = l), c.length > 0 && (output.skeletons = c), h.length > 0 && (output.animations = h)
                }
                return output.object = object, output;

                function n(t) {
                    const e = [];
                    for (const n in t) {
                        const data = t[n];
                        delete data.metadata, e.push(data)
                    }
                    return e
                }
            }
            clone(t) {
                return (new this.constructor).copy(this, t)
            }
            copy(source, t = !0) {
                if (this.name = source.name, this.up.copy(source.up), this.position.copy(source.position), this.rotation.order = source.rotation.order, this.quaternion.copy(source.quaternion), this.scale.copy(source.scale), this.matrix.copy(source.matrix), this.matrixWorld.copy(source.matrixWorld), this.matrixAutoUpdate = source.matrixAutoUpdate, this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate, this.layers.mask = source.layers.mask, this.visible = source.visible, this.castShadow = source.castShadow, this.receiveShadow = source.receiveShadow, this.frustumCulled = source.frustumCulled, this.renderOrder = source.renderOrder, this.userData = JSON.parse(JSON.stringify(source.userData)), !0 === t)
                    for (let i = 0; i < source.children.length; i++) {
                        const t = source.children[i];
                        this.add(t.clone())
                    }
                return this
            }
        }
        Te.DefaultUp = new Mt(0, 1, 0), Te.DefaultMatrixAutoUpdate = !0, Te.prototype.isObject3D = !0;
        const Ee = new Mt,
            Ae = new Mt,
            Ce = new Mt,
            Le = new Mt,
            ke = new Mt,
            Re = new Mt,
            Pe = new Mt,
            De = new Mt,
            Oe = new Mt,
            Ie = new Mt;
        class Ne {
            constructor(a = new Mt, b = new Mt, t = new Mt) {
                this.a = a, this.b = b, this.c = t
            }
            static getNormal(a, b, t, e) {
                e.subVectors(t, b), Ee.subVectors(a, b), e.cross(Ee);
                const n = e.lengthSq();
                return n > 0 ? e.multiplyScalar(1 / Math.sqrt(n)) : e.set(0, 0, 0)
            }
            static getBarycoord(t, a, b, e, n) {
                Ee.subVectors(e, a), Ae.subVectors(b, a), Ce.subVectors(t, a);
                const r = Ee.dot(Ee),
                    o = Ee.dot(Ae),
                    l = Ee.dot(Ce),
                    c = Ae.dot(Ae),
                    h = Ae.dot(Ce),
                    d = r * c - o * o;
                if (0 === d) return n.set(-2, -1, -1);
                const f = 1 / d,
                    u = (c * l - o * h) * f,
                    m = (r * h - o * l) * f;
                return n.set(1 - u - m, m, u)
            }
            static containsPoint(t, a, b, e) {
                return this.getBarycoord(t, a, b, e, Le), Le.x >= 0 && Le.y >= 0 && Le.x + Le.y <= 1
            }
            static getUV(t, e, n, r, o, l, c, h) {
                return this.getBarycoord(t, e, n, r, Le), h.set(0, 0), h.addScaledVector(o, Le.x), h.addScaledVector(l, Le.y), h.addScaledVector(c, Le.z), h
            }
            static isFrontFacing(a, b, t, e) {
                return Ee.subVectors(t, b), Ae.subVectors(a, b), Ee.cross(Ae).dot(e) < 0
            }
            set(a, b, t) {
                return this.a.copy(a), this.b.copy(b), this.c.copy(t), this
            }
            setFromPointsAndIndices(t, e, n, r) {
                return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            }
            getArea() {
                return Ee.subVectors(this.c, this.b), Ae.subVectors(this.a, this.b), .5 * Ee.cross(Ae).length()
            }
            getMidpoint(t) {
                return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return Ne.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return Ne.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getUV(t, e, n, r, o) {
                return Ne.getUV(t, this.a, this.b, this.c, e, n, r, o)
            }
            containsPoint(t) {
                return Ne.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return Ne.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(p, t) {
                const a = this.a,
                    b = this.b,
                    e = this.c;
                let n, r;
                ke.subVectors(b, a), Re.subVectors(e, a), De.subVectors(p, a);
                const o = ke.dot(De),
                    l = Re.dot(De);
                if (o <= 0 && l <= 0) return t.copy(a);
                Oe.subVectors(p, b);
                const c = ke.dot(Oe),
                    h = Re.dot(Oe);
                if (c >= 0 && h <= c) return t.copy(b);
                const d = o * h - c * l;
                if (d <= 0 && o >= 0 && c <= 0) return n = o / (o - c), t.copy(a).addScaledVector(ke, n);
                Ie.subVectors(p, e);
                const f = ke.dot(Ie),
                    m = Re.dot(Ie);
                if (m >= 0 && f <= m) return t.copy(e);
                const v = f * l - o * m;
                if (v <= 0 && l >= 0 && m <= 0) return r = l / (l - m), t.copy(a).addScaledVector(Re, r);
                const y = c * m - f * h;
                if (y <= 0 && h - c >= 0 && f - m >= 0) return Pe.subVectors(e, b), r = (h - c) / (h - c + (f - m)), t.copy(b).addScaledVector(Pe, r);
                const _ = 1 / (y + v + d);
                return n = v * _, r = d * _, t.copy(a).addScaledVector(ke, n).addScaledVector(Re, r)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        let Fe = 0;
        class ze extends tt {
            constructor() {
                super(), Object.defineProperty(this, "id", {
                    value: Fe++
                }), this.uuid = ot(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = r, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = l, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Z, this.stencilZFail = Z, this.stencilZPass = Z, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
            }
            onBuild() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) {
                            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                            continue
                        }
                        if ("shading" === e) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                            continue
                        }
                        const r = this[e];
                        void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                    }
            }
            toJSON(meta) {
                const t = void 0 === meta || "string" == typeof meta;
                t && (meta = {
                    textures: {},
                    images: {}
                });
                const data = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function e(t) {
                    const e = [];
                    for (const n in t) {
                        const data = t[n];
                        delete data.metadata, e.push(data)
                    }
                    return e
                }
                if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), this.color && this.color.isColor && (data.color = this.color.getHex()), void 0 !== this.roughness && (data.roughness = this.roughness), void 0 !== this.metalness && (data.metalness = this.metalness), this.sheen && this.sheen.isColor && (data.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (data.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (data.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (data.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (data.specularIntensity = this.specularIntensity), this.specularTint && this.specularTint.isColor && (data.specularTint = this.specularTint.getHex()), void 0 !== this.shininess && (data.shininess = this.shininess), void 0 !== this.clearcoat && (data.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (data.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid, data.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (data.map = this.map.toJSON(meta).uuid), this.matcap && this.matcap.isTexture && (data.matcap = this.matcap.toJSON(meta).uuid), this.alphaMap && this.alphaMap.isTexture && (data.alphaMap = this.alphaMap.toJSON(meta).uuid), this.lightMap && this.lightMap.isTexture && (data.lightMap = this.lightMap.toJSON(meta).uuid, data.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (data.aoMap = this.aoMap.toJSON(meta).uuid, data.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (data.bumpMap = this.bumpMap.toJSON(meta).uuid, data.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (data.normalMap = this.normalMap.toJSON(meta).uuid, data.normalMapType = this.normalMapType, data.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (data.displacementMap = this.displacementMap.toJSON(meta).uuid, data.displacementScale = this.displacementScale, data.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (data.roughnessMap = this.roughnessMap.toJSON(meta).uuid), this.metalnessMap && this.metalnessMap.isTexture && (data.metalnessMap = this.metalnessMap.toJSON(meta).uuid), this.emissiveMap && this.emissiveMap.isTexture && (data.emissiveMap = this.emissiveMap.toJSON(meta).uuid), this.specularMap && this.specularMap.isTexture && (data.specularMap = this.specularMap.toJSON(meta).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid), this.specularTintMap && this.specularTintMap.isTexture && (data.specularTintMap = this.specularTintMap.toJSON(meta).uuid), this.envMap && this.envMap.isTexture && (data.envMap = this.envMap.toJSON(meta).uuid, void 0 !== this.combine && (data.combine = this.combine)), void 0 !== this.envMapIntensity && (data.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (data.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (data.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (data.gradientMap = this.gradientMap.toJSON(meta).uuid), void 0 !== this.transmission && (data.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (data.transmissionMap = this.transmissionMap.toJSON(meta).uuid), void 0 !== this.thickness && (data.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (data.thicknessMap = this.thicknessMap.toJSON(meta).uuid), void 0 !== this.attenuationDistance && (data.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationTint && (data.attenuationTint = this.attenuationTint.getHex()), void 0 !== this.size && (data.size = this.size), null !== this.shadowSide && (data.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (data.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (data.blending = this.blending), this.side !== r && (data.side = this.side), this.vertexColors && (data.vertexColors = !0), this.opacity < 1 && (data.opacity = this.opacity), !0 === this.transparent && (data.transparent = this.transparent), data.depthFunc = this.depthFunc, data.depthTest = this.depthTest, data.depthWrite = this.depthWrite, data.colorWrite = this.colorWrite, data.stencilWrite = this.stencilWrite, data.stencilWriteMask = this.stencilWriteMask, data.stencilFunc = this.stencilFunc, data.stencilRef = this.stencilRef, data.stencilFuncMask = this.stencilFuncMask, data.stencilFail = this.stencilFail, data.stencilZFail = this.stencilZFail, data.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (data.rotation = this.rotation), !0 === this.polygonOffset && (data.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (data.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (data.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (data.linewidth = this.linewidth), void 0 !== this.dashSize && (data.dashSize = this.dashSize), void 0 !== this.gapSize && (data.gapSize = this.gapSize), void 0 !== this.scale && (data.scale = this.scale), !0 === this.dithering && (data.dithering = !0), this.alphaTest > 0 && (data.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (data.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (data.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (data.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (data.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (data.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (data.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (data.flatShading = this.flatShading), !1 === this.visible && (data.visible = !1), !1 === this.toneMapped && (data.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (data.userData = this.userData), t) {
                    const t = e(meta.textures),
                        n = e(meta.images);
                    t.length > 0 && (data.textures = t), n.length > 0 && (data.images = n)
                }
                return data
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(source) {
                this.name = source.name, this.fog = source.fog, this.blending = source.blending, this.side = source.side, this.vertexColors = source.vertexColors, this.opacity = source.opacity, this.transparent = source.transparent, this.blendSrc = source.blendSrc, this.blendDst = source.blendDst, this.blendEquation = source.blendEquation, this.blendSrcAlpha = source.blendSrcAlpha, this.blendDstAlpha = source.blendDstAlpha, this.blendEquationAlpha = source.blendEquationAlpha, this.depthFunc = source.depthFunc, this.depthTest = source.depthTest, this.depthWrite = source.depthWrite, this.stencilWriteMask = source.stencilWriteMask, this.stencilFunc = source.stencilFunc, this.stencilRef = source.stencilRef, this.stencilFuncMask = source.stencilFuncMask, this.stencilFail = source.stencilFail, this.stencilZFail = source.stencilZFail, this.stencilZPass = source.stencilZPass, this.stencilWrite = source.stencilWrite;
                const t = source.clippingPlanes;
                let e = null;
                if (null !== t) {
                    const n = t.length;
                    e = new Array(n);
                    for (let i = 0; i !== n; ++i) e[i] = t[i].clone()
                }
                return this.clippingPlanes = e, this.clipIntersection = source.clipIntersection, this.clipShadows = source.clipShadows, this.shadowSide = source.shadowSide, this.colorWrite = source.colorWrite, this.precision = source.precision, this.polygonOffset = source.polygonOffset, this.polygonOffsetFactor = source.polygonOffsetFactor, this.polygonOffsetUnits = source.polygonOffsetUnits, this.dithering = source.dithering, this.alphaTest = source.alphaTest, this.alphaToCoverage = source.alphaToCoverage, this.premultipliedAlpha = source.premultipliedAlpha, this.visible = source.visible, this.toneMapped = source.toneMapped, this.userData = JSON.parse(JSON.stringify(source.userData)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        ze.prototype.isMaterial = !0;
        const Be = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            Ue = {
                h: 0,
                s: 0,
                l: 0
            },
            He = {
                h: 0,
                s: 0,
                l: 0
            };

        function je(p, q, t) {
            return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + 6 * (q - p) * (2 / 3 - t) : p
        }

        function Ve(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }

        function Ge(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        class We {
            constructor(t, g, b) {
                return void 0 === g && void 0 === b ? this.set(t) : this.setRGB(t, g, b)
            }
            set(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            }
            setScalar(t) {
                return this.r = t, this.g = t, this.b = t, this
            }
            setHex(t) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
            }
            setRGB(t, g, b) {
                return this.r = t, this.g = g, this.b = b, this
            }
            setHSL(t, s, e) {
                if (t = st(t, 1), s = at(s, 0, 1), e = at(e, 0, 1), 0 === s) this.r = this.g = this.b = e;
                else {
                    const p = e <= .5 ? e * (1 + s) : e + s - e * s,
                        q = 2 * e - p;
                    this.r = je(q, p, t + 1 / 3), this.g = je(q, p, t), this.b = je(q, p, t - 1 / 3)
                }
                return this
            }
            setStyle(style) {
                function t(t) {
                    void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + style + " will be ignored.")
                }
                let e;
                if (e = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
                    let n;
                    const r = e[1],
                        o = e[2];
                    switch (r) {
                        case "rgb":
                        case "rgba":
                            if (n = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[4]), this;
                            if (n = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[4]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (n = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) {
                                const e = parseFloat(n[1]) / 360,
                                    s = parseInt(n[2], 10) / 100,
                                    r = parseInt(n[3], 10) / 100;
                                return t(n[4]), this.setHSL(e, s, r)
                            }
                    }
                } else if (e = /^\#([A-Fa-f\d]+)$/.exec(style)) {
                    const t = e[1],
                        n = t.length;
                    if (3 === n) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                    if (6 === n) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                }
                return style && style.length > 0 ? this.setColorName(style) : this
            }
            setColorName(style) {
                const t = Be[style.toLowerCase()];
                return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + style), this
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }
            copy(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            }
            copyGammaToLinear(t, e = 2) {
                return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            }
            copyLinearToGamma(t, e = 2) {
                const n = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
            }
            convertGammaToLinear(t) {
                return this.copyGammaToLinear(this, t), this
            }
            convertLinearToGamma(t) {
                return this.copyLinearToGamma(this, t), this
            }
            copySRGBToLinear(t) {
                return this.r = Ve(t.r), this.g = Ve(t.g), this.b = Ve(t.b), this
            }
            copyLinearToSRGB(t) {
                return this.r = Ge(t.r), this.g = Ge(t.g), this.b = Ge(t.b), this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }
            getHex() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }
            getHexString() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }
            getHSL(t) {
                const e = this.r,
                    g = this.g,
                    b = this.b,
                    n = Math.max(e, g, b),
                    r = Math.min(e, g, b);
                let o, l;
                const c = (r + n) / 2;
                if (r === n) o = 0, l = 0;
                else {
                    const t = n - r;
                    switch (l = c <= .5 ? t / (n + r) : t / (2 - n - r), n) {
                        case e:
                            o = (g - b) / t + (g < b ? 6 : 0);
                            break;
                        case g:
                            o = (b - e) / t + 2;
                            break;
                        case b:
                            o = (e - g) / t + 4
                    }
                    o /= 6
                }
                return t.h = o, t.s = l, t.l = c, t
            }
            getStyle() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }
            offsetHSL(t, s, e) {
                return this.getHSL(Ue), Ue.h += t, Ue.s += s, Ue.l += e, this.setHSL(Ue.h, Ue.s, Ue.l), this
            }
            add(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            }
            addColors(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            }
            addScalar(s) {
                return this.r += s, this.g += s, this.b += s, this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            }
            multiply(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            }
            multiplyScalar(s) {
                return this.r *= s, this.g *= s, this.b *= s, this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            }
            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
            }
            lerpHSL(t, e) {
                this.getHSL(Ue), t.getHSL(He);
                const n = lt(Ue.h, He.h, e),
                    s = lt(Ue.s, He.s, e),
                    r = lt(Ue.l, He.l, e);
                return this.setHSL(n, s, r), this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e = 0) {
                return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            }
            toArray(t = [], e = 0) {
                return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
            }
            toJSON() {
                return this.getHex()
            }
        }
        We.NAMES = Be, We.prototype.isColor = !0, We.prototype.r = 1, We.prototype.g = 1, We.prototype.b = 1;
        class qe extends ze {
            constructor(t) {
                super(), this.type = "MeshBasicMaterial", this.color = new We(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.color.copy(source.color), this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this
            }
        }
        qe.prototype.isMeshBasicMaterial = !0;
        const Xe = new Mt,
            $e = new ht;
        class Ye {
            constructor(t, e, n) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = J, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t, this
            }
            copy(source) {
                return this.name = source.name, this.array = new source.array.constructor(source.array), this.itemSize = source.itemSize, this.count = source.count, this.normalized = source.normalized, this.usage = source.usage, this
            }
            copyAt(t, e, n) {
                t *= this.itemSize, n *= e.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                return this
            }
            copyArray(t) {
                return this.array.set(t), this
            }
            copyColorsArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new We), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                }
                return this
            }
            copyVector2sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new ht), e[n++] = r.x, e[n++] = r.y
                }
                return this
            }
            copyVector3sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Mt), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                }
                return this
            }
            copyVector4sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new _t), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                }
                return this
            }
            applyMatrix3(t) {
                if (2 === this.itemSize)
                    for (let i = 0, e = this.count; i < e; i++) $e.fromBufferAttribute(this, i), $e.applyMatrix3(t), this.setXY(i, $e.x, $e.y);
                else if (3 === this.itemSize)
                    for (let i = 0, e = this.count; i < e; i++) Xe.fromBufferAttribute(this, i), Xe.applyMatrix3(t), this.setXYZ(i, Xe.x, Xe.y, Xe.z);
                return this
            }
            applyMatrix4(t) {
                for (let i = 0, e = this.count; i < e; i++) Xe.x = this.getX(i), Xe.y = this.getY(i), Xe.z = this.getZ(i), Xe.applyMatrix4(t), this.setXYZ(i, Xe.x, Xe.y, Xe.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let i = 0, e = this.count; i < e; i++) Xe.x = this.getX(i), Xe.y = this.getY(i), Xe.z = this.getZ(i), Xe.applyNormalMatrix(t), this.setXYZ(i, Xe.x, Xe.y, Xe.z);
                return this
            }
            transformDirection(t) {
                for (let i = 0, e = this.count; i < e; i++) Xe.x = this.getX(i), Xe.y = this.getY(i), Xe.z = this.getZ(i), Xe.transformDirection(t), this.setXYZ(i, Xe.x, Xe.y, Xe.z);
                return this
            }
            set(t, e = 0) {
                return this.array.set(t, e), this
            }
            getX(t) {
                return this.array[t * this.itemSize]
            }
            setX(t, e) {
                return this.array[t * this.itemSize] = e, this
            }
            getY(t) {
                return this.array[t * this.itemSize + 1]
            }
            setY(t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            }
            getZ(t) {
                return this.array[t * this.itemSize + 2]
            }
            setZ(t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            }
            getW(t) {
                return this.array[t * this.itemSize + 3]
            }
            setW(t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            }
            setXY(t, e, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
            }
            setXYZ(t, e, n, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
            }
            setXYZW(t, e, n, r, o) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = o, this
            }
            onUpload(t) {
                return this.onUploadCallback = t, this
            }
            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
            toJSON() {
                const data = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (data.name = this.name), this.usage !== J && (data.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (data.updateRange = this.updateRange), data
            }
        }
        Ye.prototype.isBufferAttribute = !0;
        class Ze extends Ye {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        class Je extends Ye {
            constructor(t, e, n) {
                super(new Uint32Array(t), e, n)
            }
        }(class extends Ye {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }).prototype.isFloat16BufferAttribute = !0;
        class Ke extends Ye {
            constructor(t, e, n) {
                super(new Float32Array(t), e, n)
            }
        }

        function Qe(t) {
            if (0 === t.length) return -1 / 0;
            let e = t[0];
            for (let i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
            return e
        }
        Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
        let tn = 0;
        const en = new te,
            nn = new Te,
            rn = new Mt,
            on = new Et,
            an = new Et,
            sn = new Mt;
        class ln extends tt {
            constructor() {
                super(), Object.defineProperty(this, "id", {
                    value: tn++
                }), this.uuid = ot(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(t) {
                return Array.isArray(t) ? this.index = new(Qe(t) > 65535 ? Je : Ze)(t, 1) : this.index = t, this
            }
            getAttribute(t) {
                return this.attributes[t]
            }
            setAttribute(t, e) {
                return this.attributes[t] = e, this
            }
            deleteAttribute(t) {
                return delete this.attributes[t], this
            }
            hasAttribute(t) {
                return void 0 !== this.attributes[t]
            }
            addGroup(t, e, n = 0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            }
            applyMatrix4(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new pt).getNormalMatrix(t);
                    n.applyNormalMatrix(e), n.needsUpdate = !0
                }
                const r = this.attributes.tangent;
                return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }
            applyQuaternion(q) {
                return en.makeRotationFromQuaternion(q), this.applyMatrix4(en), this
            }
            rotateX(t) {
                return en.makeRotationX(t), this.applyMatrix4(en), this
            }
            rotateY(t) {
                return en.makeRotationY(t), this.applyMatrix4(en), this
            }
            rotateZ(t) {
                return en.makeRotationZ(t), this.applyMatrix4(en), this
            }
            translate(t, e, n) {
                return en.makeTranslation(t, e, n), this.applyMatrix4(en), this
            }
            scale(t, e, n) {
                return en.makeScale(t, e, n), this.applyMatrix4(en), this
            }
            lookAt(t) {
                return nn.lookAt(t), nn.updateMatrix(), this.applyMatrix4(nn.matrix), this
            }
            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(rn).negate(), this.translate(rn.x, rn.y, rn.z), this
            }
            setFromPoints(t) {
                const e = [];
                for (let i = 0, n = t.length; i < n; i++) {
                    const n = t[i];
                    e.push(n.x, n.y, n.z || 0)
                }
                return this.setAttribute("position", new Ke(e, 3)), this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new Et);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Mt(-1 / 0, -1 / 0, -1 / 0), new Mt(1 / 0, 1 / 0, 1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t), e)
                        for (let i = 0, t = e.length; i < t; i++) {
                            const t = e[i];
                            on.setFromBufferAttribute(t), this.morphTargetsRelative ? (sn.addVectors(this.boundingBox.min, on.min), this.boundingBox.expandByPoint(sn), sn.addVectors(this.boundingBox.max, on.max), this.boundingBox.expandByPoint(sn)) : (this.boundingBox.expandByPoint(on.min), this.boundingBox.expandByPoint(on.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Wt);
                const t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Mt, 1 / 0);
                if (t) {
                    const n = this.boundingSphere.center;
                    if (on.setFromBufferAttribute(t), e)
                        for (let i = 0, t = e.length; i < t; i++) {
                            const t = e[i];
                            an.setFromBufferAttribute(t), this.morphTargetsRelative ? (sn.addVectors(on.min, an.min), on.expandByPoint(sn), sn.addVectors(on.max, an.max), on.expandByPoint(sn)) : (on.expandByPoint(an.min), on.expandByPoint(an.max))
                        }
                    on.getCenter(n);
                    let r = 0;
                    for (let i = 0, e = t.count; i < e; i++) sn.fromBufferAttribute(t, i), r = Math.max(r, n.distanceToSquared(sn));
                    if (e)
                        for (let i = 0, o = e.length; i < o; i++) {
                            const o = e[i],
                                l = this.morphTargetsRelative;
                            for (let e = 0, c = o.count; e < c; e++) sn.fromBufferAttribute(o, e), l && (rn.fromBufferAttribute(t, e), sn.add(rn)), r = Math.max(r, n.distanceToSquared(sn))
                        }
                    this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeFaceNormals() {}
            computeTangents() {
                const t = this.index,
                    e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.array,
                    r = e.position.array,
                    o = e.normal.array,
                    l = e.uv.array,
                    c = r.length / 3;
                void 0 === e.tangent && this.setAttribute("tangent", new Ye(new Float32Array(4 * c), 4));
                const h = e.tangent.array,
                    d = [],
                    f = [];
                for (let i = 0; i < c; i++) d[i] = new Mt, f[i] = new Mt;
                const m = new Mt,
                    v = new Mt,
                    y = new Mt,
                    _ = new ht,
                    x = new ht,
                    w = new ht,
                    M = new Mt,
                    S = new Mt;

                function T(a, b, t) {
                    m.fromArray(r, 3 * a), v.fromArray(r, 3 * b), y.fromArray(r, 3 * t), _.fromArray(l, 2 * a), x.fromArray(l, 2 * b), w.fromArray(l, 2 * t), v.sub(m), y.sub(m), x.sub(_), w.sub(_);
                    const e = 1 / (x.x * w.y - w.x * x.y);
                    isFinite(e) && (M.copy(v).multiplyScalar(w.y).addScaledVector(y, -x.y).multiplyScalar(e), S.copy(y).multiplyScalar(x.x).addScaledVector(v, -w.x).multiplyScalar(e), d[a].add(M), d[b].add(M), d[t].add(M), f[a].add(S), f[b].add(S), f[t].add(S))
                }
                let E = this.groups;
                0 === E.length && (E = [{
                    start: 0,
                    count: n.length
                }]);
                for (let i = 0, t = E.length; i < t; ++i) {
                    const t = E[i],
                        e = t.start;
                    for (let r = e, o = e + t.count; r < o; r += 3) T(n[r + 0], n[r + 1], n[r + 2])
                }
                const A = new Mt,
                    C = new Mt,
                    L = new Mt,
                    k = new Mt;

                function R(t) {
                    L.fromArray(o, 3 * t), k.copy(L);
                    const e = d[t];
                    A.copy(e), A.sub(L.multiplyScalar(L.dot(e))).normalize(), C.crossVectors(k, e);
                    const n = C.dot(f[t]) < 0 ? -1 : 1;
                    h[4 * t] = A.x, h[4 * t + 1] = A.y, h[4 * t + 2] = A.z, h[4 * t + 3] = n
                }
                for (let i = 0, t = E.length; i < t; ++i) {
                    const t = E[i],
                        e = t.start;
                    for (let r = e, o = e + t.count; r < o; r += 3) R(n[r + 0]), R(n[r + 1]), R(n[r + 2])
                }
            }
            computeVertexNormals() {
                const t = this.index,
                    e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n) n = new Ye(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                    else
                        for (let i = 0, t = n.count; i < t; i++) n.setXYZ(i, 0, 0, 0);
                    const r = new Mt,
                        o = new Mt,
                        l = new Mt,
                        c = new Mt,
                        h = new Mt,
                        d = new Mt,
                        f = new Mt,
                        m = new Mt;
                    if (t)
                        for (let i = 0, v = t.count; i < v; i += 3) {
                            const v = t.getX(i + 0),
                                y = t.getX(i + 1),
                                _ = t.getX(i + 2);
                            r.fromBufferAttribute(e, v), o.fromBufferAttribute(e, y), l.fromBufferAttribute(e, _), f.subVectors(l, o), m.subVectors(r, o), f.cross(m), c.fromBufferAttribute(n, v), h.fromBufferAttribute(n, y), d.fromBufferAttribute(n, _), c.add(f), h.add(f), d.add(f), n.setXYZ(v, c.x, c.y, c.z), n.setXYZ(y, h.x, h.y, h.z), n.setXYZ(_, d.x, d.y, d.z)
                        } else
                            for (let i = 0, t = e.count; i < t; i += 3) r.fromBufferAttribute(e, i + 0), o.fromBufferAttribute(e, i + 1), l.fromBufferAttribute(e, i + 2), f.subVectors(l, o), m.subVectors(r, o), f.cross(m), n.setXYZ(i + 0, f.x, f.y, f.z), n.setXYZ(i + 1, f.x, f.y, f.z), n.setXYZ(i + 2, f.x, f.y, f.z);
                    this.normalizeNormals(), n.needsUpdate = !0
                }
            }
            merge(t, e) {
                if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                const n = this.attributes;
                for (const r in n) {
                    if (void 0 === t.attributes[r]) continue;
                    const o = n[r].array,
                        l = t.attributes[r],
                        c = l.array,
                        h = l.itemSize * e,
                        d = Math.min(c.length, o.length - h);
                    for (let i = 0, t = h; i < d; i++, t++) o[t] = c[i]
                }
                return this
            }
            normalizeNormals() {
                const t = this.attributes.normal;
                for (let i = 0, e = t.count; i < e; i++) sn.fromBufferAttribute(t, i), sn.normalize(), t.setXYZ(i, sn.x, sn.y, sn.z)
            }
            toNonIndexed() {
                function t(t, e) {
                    const n = t.array,
                        r = t.itemSize,
                        o = t.normalized,
                        l = new n.constructor(e.length * r);
                    let c = 0,
                        h = 0;
                    for (let i = 0, o = e.length; i < o; i++) {
                        c = t.isInterleavedBufferAttribute ? e[i] * t.data.stride + t.offset : e[i] * r;
                        for (let t = 0; t < r; t++) l[h++] = n[c++]
                    }
                    return new Ye(l, r, o)
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                const e = new ln,
                    n = this.index.array,
                    r = this.attributes;
                for (const o in r) {
                    const l = t(r[o], n);
                    e.setAttribute(o, l)
                }
                const o = this.morphAttributes;
                for (const r in o) {
                    const l = [],
                        c = o[r];
                    for (let i = 0, e = c.length; i < e; i++) {
                        const e = t(c[i], n);
                        l.push(e)
                    }
                    e.morphAttributes[r] = l
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const l = this.groups;
                for (let i = 0, t = l.length; i < t; i++) {
                    const t = l[i];
                    e.addGroup(t.start, t.count, t.materialIndex)
                }
                return e
            }
            toJSON() {
                const data = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), Object.keys(this.userData).length > 0 && (data.userData = this.userData), void 0 !== this.parameters) {
                    const t = this.parameters;
                    for (const e in t) void 0 !== t[e] && (data[e] = t[e]);
                    return data
                }
                data.data = {
                    attributes: {}
                };
                const t = this.index;
                null !== t && (data.data.index = {
                    type: t.array.constructor.name,
                    array: Array.prototype.slice.call(t.array)
                });
                const e = this.attributes;
                for (const t in e) {
                    const n = e[t];
                    data.data.attributes[t] = n.toJSON(data.data)
                }
                const n = {};
                let r = !1;
                for (const t in this.morphAttributes) {
                    const e = this.morphAttributes[t],
                        o = [];
                    for (let i = 0, t = e.length; i < t; i++) {
                        const t = e[i];
                        o.push(t.toJSON(data.data))
                    }
                    o.length > 0 && (n[t] = o, r = !0)
                }
                r && (data.data.morphAttributes = n, data.data.morphTargetsRelative = this.morphTargetsRelative);
                const o = this.groups;
                o.length > 0 && (data.data.groups = JSON.parse(JSON.stringify(o)));
                const l = this.boundingSphere;
                return null !== l && (data.data.boundingSphere = {
                    center: l.center.toArray(),
                    radius: l.radius
                }), data
            }
            clone() {
                return (new ln).copy(this)
            }
            copy(source) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const data = {};
                this.name = source.name;
                const t = source.index;
                null !== t && this.setIndex(t.clone(data));
                const e = source.attributes;
                for (const t in e) {
                    const n = e[t];
                    this.setAttribute(t, n.clone(data))
                }
                const n = source.morphAttributes;
                for (const t in n) {
                    const e = [],
                        r = n[t];
                    for (let i = 0, t = r.length; i < t; i++) e.push(r[i].clone(data));
                    this.morphAttributes[t] = e
                }
                this.morphTargetsRelative = source.morphTargetsRelative;
                const r = source.groups;
                for (let i = 0, t = r.length; i < t; i++) {
                    const t = r[i];
                    this.addGroup(t.start, t.count, t.materialIndex)
                }
                const o = source.boundingBox;
                null !== o && (this.boundingBox = o.clone());
                const l = source.boundingSphere;
                return null !== l && (this.boundingSphere = l.clone()), this.drawRange.start = source.drawRange.start, this.drawRange.count = source.drawRange.count, this.userData = source.userData, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        ln.prototype.isBufferGeometry = !0;
        const cn = new te,
            un = new Qt,
            hn = new Wt,
            dn = new Mt,
            pn = new Mt,
            fn = new Mt,
            mn = new Mt,
            gn = new Mt,
            vn = new Mt,
            yn = new Mt,
            _n = new Mt,
            xn = new Mt,
            bn = new ht,
            wn = new ht,
            Mn = new ht,
            Sn = new Mt,
            Tn = new Mt;
        class En extends Te {
            constructor(t = new ln, e = new qe) {
                super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(source) {
                return super.copy(source), void 0 !== source.morphTargetInfluences && (this.morphTargetInfluences = source.morphTargetInfluences.slice()), void 0 !== source.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary)), this.material = source.material, this.geometry = source.geometry, this
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes,
                        n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
            raycast(t, e) {
                const n = this.geometry,
                    r = this.material,
                    o = this.matrixWorld;
                if (void 0 === r) return;
                if (null === n.boundingSphere && n.computeBoundingSphere(), hn.copy(n.boundingSphere), hn.applyMatrix4(o), !1 === t.ray.intersectsSphere(hn)) return;
                if (cn.copy(o).invert(), un.copy(t.ray).applyMatrix4(cn), null !== n.boundingBox && !1 === un.intersectsBox(n.boundingBox)) return;
                let l;
                if (n.isBufferGeometry) {
                    const o = n.index,
                        c = n.attributes.position,
                        h = n.morphAttributes.position,
                        d = n.morphTargetsRelative,
                        f = n.attributes.uv,
                        m = n.attributes.uv2,
                        v = n.groups,
                        y = n.drawRange;
                    if (null !== o)
                        if (Array.isArray(r))
                            for (let i = 0, n = v.length; i < n; i++) {
                                const n = v[i],
                                    _ = r[n.materialIndex];
                                for (let r = Math.max(n.start, y.start), v = Math.min(n.start + n.count, y.start + y.count); r < v; r += 3) {
                                    const a = o.getX(r),
                                        b = o.getX(r + 1),
                                        v = o.getX(r + 2);
                                    l = An(this, _, t, un, c, h, d, f, m, a, b, v), l && (l.faceIndex = Math.floor(r / 3), l.face.materialIndex = n.materialIndex, e.push(l))
                                }
                            } else {
                                for (let i = Math.max(0, y.start), n = Math.min(o.count, y.start + y.count); i < n; i += 3) {
                                    const a = o.getX(i),
                                        b = o.getX(i + 1),
                                        n = o.getX(i + 2);
                                    l = An(this, r, t, un, c, h, d, f, m, a, b, n), l && (l.faceIndex = Math.floor(i / 3), e.push(l))
                                }
                            } else if (void 0 !== c)
                                if (Array.isArray(r))
                                    for (let i = 0, n = v.length; i < n; i++) {
                                        const n = v[i],
                                            o = r[n.materialIndex];
                                        for (let r = Math.max(n.start, y.start), v = Math.min(n.start + n.count, y.start + y.count); r < v; r += 3) {
                                            l = An(this, o, t, un, c, h, d, f, m, r, r + 1, r + 2), l && (l.faceIndex = Math.floor(r / 3), l.face.materialIndex = n.materialIndex, e.push(l))
                                        }
                                    } else {
                                        for (let i = Math.max(0, y.start), n = Math.min(c.count, y.start + y.count); i < n; i += 3) {
                                            l = An(this, r, t, un, c, h, d, f, m, i, i + 1, i + 2), l && (l.faceIndex = Math.floor(i / 3), e.push(l))
                                        }
                                    }
                } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }

        function An(object, t, e, n, r, l, c, h, d, a, b, f) {
            dn.fromBufferAttribute(r, a), pn.fromBufferAttribute(r, b), fn.fromBufferAttribute(r, f);
            const m = object.morphTargetInfluences;
            if (l && m) {
                yn.set(0, 0, 0), _n.set(0, 0, 0), xn.set(0, 0, 0);
                for (let i = 0, t = l.length; i < t; i++) {
                    const t = m[i],
                        e = l[i];
                    0 !== t && (mn.fromBufferAttribute(e, a), gn.fromBufferAttribute(e, b), vn.fromBufferAttribute(e, f), c ? (yn.addScaledVector(mn, t), _n.addScaledVector(gn, t), xn.addScaledVector(vn, t)) : (yn.addScaledVector(mn.sub(dn), t), _n.addScaledVector(gn.sub(pn), t), xn.addScaledVector(vn.sub(fn), t)))
                }
                dn.add(yn), pn.add(_n), fn.add(xn)
            }
            object.isSkinnedMesh && (object.boneTransform(a, dn), object.boneTransform(b, pn), object.boneTransform(f, fn));
            const v = function(object, t, e, n, r, l, c, h) {
                let d;
                if (d = t.side === o ? n.intersectTriangle(c, l, r, !0, h) : n.intersectTriangle(r, l, c, 2 !== t.side, h), null === d) return null;
                Tn.copy(h), Tn.applyMatrix4(object.matrixWorld);
                const f = e.ray.origin.distanceTo(Tn);
                return f < e.near || f > e.far ? null : {
                    distance: f,
                    point: Tn.clone(),
                    object: object
                }
            }(object, t, e, n, dn, pn, fn, Sn);
            if (v) {
                h && (bn.fromBufferAttribute(h, a), wn.fromBufferAttribute(h, b), Mn.fromBufferAttribute(h, f), v.uv = Ne.getUV(Sn, dn, pn, fn, bn, wn, Mn, new ht)), d && (bn.fromBufferAttribute(d, a), wn.fromBufferAttribute(d, b), Mn.fromBufferAttribute(d, f), v.uv2 = Ne.getUV(Sn, dn, pn, fn, bn, wn, Mn, new ht));
                const t = {
                    a: a,
                    b: b,
                    c: f,
                    normal: new Mt,
                    materialIndex: 0
                };
                Ne.getNormal(dn, pn, fn, t.normal), v.face = t
            }
            return v
        }
        En.prototype.isMesh = !0;
        class Cn extends ln {
            constructor(t = 1, e = 1, n = 1, r = 1, o = 1, l = 1) {
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: r,
                    heightSegments: o,
                    depthSegments: l
                };
                const c = this;
                r = Math.floor(r), o = Math.floor(o), l = Math.floor(l);
                const h = [],
                    d = [],
                    f = [],
                    m = [];
                let v = 0,
                    y = 0;

                function _(u, t, e, n, r, o, l, _, x, w, M) {
                    const S = o / x,
                        T = l / w,
                        E = o / 2,
                        A = l / 2,
                        C = _ / 2,
                        L = x + 1,
                        k = w + 1;
                    let R = 0,
                        P = 0;
                    const D = new Mt;
                    for (let o = 0; o < k; o++) {
                        const l = o * T - A;
                        for (let c = 0; c < L; c++) {
                            const h = c * S - E;
                            D[u] = h * n, D[t] = l * r, D[e] = C, d.push(D.x, D.y, D.z), D[u] = 0, D[t] = 0, D[e] = _ > 0 ? 1 : -1, f.push(D.x, D.y, D.z), m.push(c / x), m.push(1 - o / w), R += 1
                        }
                    }
                    for (let t = 0; t < w; t++)
                        for (let e = 0; e < x; e++) {
                            const a = v + e + L * t,
                                b = v + e + L * (t + 1),
                                n = v + (e + 1) + L * (t + 1),
                                r = v + (e + 1) + L * t;
                            h.push(a, b, r), h.push(b, n, r), P += 6
                        }
                    c.addGroup(y, P, M), y += P, v += R
                }
                _("z", "y", "x", -1, -1, n, e, t, l, o, 0), _("z", "y", "x", 1, -1, n, e, -t, l, o, 1), _("x", "z", "y", 1, 1, t, n, e, r, l, 2), _("x", "z", "y", 1, -1, t, n, -e, r, l, 3), _("x", "y", "z", 1, -1, t, e, n, r, o, 4), _("x", "y", "z", -1, -1, t, e, -n, r, o, 5), this.setIndex(h), this.setAttribute("position", new Ke(d, 3)), this.setAttribute("normal", new Ke(f, 3)), this.setAttribute("uv", new Ke(m, 2))
            }
            static fromJSON(data) {
                return new Cn(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments)
            }
        }

        function Ln(t) {
            const e = {};
            for (const u in t) {
                e[u] = {};
                for (const p in t[u]) {
                    const n = t[u][p];
                    n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? e[u][p] = n.clone() : Array.isArray(n) ? e[u][p] = n.slice() : e[u][p] = n
                }
            }
            return e
        }

        function kn(t) {
            const e = {};
            for (let u = 0; u < t.length; u++) {
                const n = Ln(t[u]);
                for (const p in n) e[p] = n[p]
            }
            return e
        }
        const Rn = {
            clone: Ln,
            merge: kn
        };
        class Pn extends ze {
            constructor(t) {
                super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }
            copy(source) {
                return super.copy(source), this.fragmentShader = source.fragmentShader, this.vertexShader = source.vertexShader, this.uniforms = Ln(source.uniforms), this.defines = Object.assign({}, source.defines), this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.lights = source.lights, this.clipping = source.clipping, this.extensions = Object.assign({}, source.extensions), this.glslVersion = source.glslVersion, this
            }
            toJSON(meta) {
                const data = super.toJSON(meta);
                data.glslVersion = this.glslVersion, data.uniforms = {};
                for (const t in this.uniforms) {
                    const e = this.uniforms[t].value;
                    e && e.isTexture ? data.uniforms[t] = {
                        type: "t",
                        value: e.toJSON(meta).uuid
                    } : e && e.isColor ? data.uniforms[t] = {
                        type: "c",
                        value: e.getHex()
                    } : e && e.isVector2 ? data.uniforms[t] = {
                        type: "v2",
                        value: e.toArray()
                    } : e && e.isVector3 ? data.uniforms[t] = {
                        type: "v3",
                        value: e.toArray()
                    } : e && e.isVector4 ? data.uniforms[t] = {
                        type: "v4",
                        value: e.toArray()
                    } : e && e.isMatrix3 ? data.uniforms[t] = {
                        type: "m3",
                        value: e.toArray()
                    } : e && e.isMatrix4 ? data.uniforms[t] = {
                        type: "m4",
                        value: e.toArray()
                    } : data.uniforms[t] = {
                        value: e
                    }
                }
                Object.keys(this.defines).length > 0 && (data.defines = this.defines), data.vertexShader = this.vertexShader, data.fragmentShader = this.fragmentShader;
                const t = {};
                for (const e in this.extensions) !0 === this.extensions[e] && (t[e] = !0);
                return Object.keys(t).length > 0 && (data.extensions = t), data
            }
        }
        Pn.prototype.isShaderMaterial = !0;
        class Dn extends Te {
            constructor() {
                super(), this.type = "Camera", this.matrixWorldInverse = new te, this.projectionMatrix = new te, this.projectionMatrixInverse = new te
            }
            copy(source, t) {
                return super.copy(source, t), this.matrixWorldInverse.copy(source.matrixWorldInverse), this.projectionMatrix.copy(source.projectionMatrix), this.projectionMatrixInverse.copy(source.projectionMatrixInverse), this
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(t, e) {
                super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        Dn.prototype.isCamera = !0;
        class On extends Dn {
            constructor(t = 50, e = 1, n = .1, r = 2e3) {
                super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            copy(source, t) {
                return super.copy(source, t), this.fov = source.fov, this.zoom = source.zoom, this.near = source.near, this.far = source.far, this.focus = source.focus, this.aspect = source.aspect, this.view = null === source.view ? null : Object.assign({}, source.view), this.filmGauge = source.filmGauge, this.filmOffset = source.filmOffset, this
            }
            setFocalLength(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * it * Math.atan(e), this.updateProjectionMatrix()
            }
            getFocalLength() {
                const t = Math.tan(.5 * nt * this.fov);
                return .5 * this.getFilmHeight() / t
            }
            getEffectiveFOV() {
                return 2 * it * Math.atan(Math.tan(.5 * nt * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(t, e, n, r, o, l) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = o, this.view.height = l, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = this.near;
                let e = t * Math.tan(.5 * nt * this.fov) / this.zoom,
                    n = 2 * e,
                    r = this.aspect * n,
                    o = -.5 * r;
                const view = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = view.fullWidth,
                        l = view.fullHeight;
                    o += view.offsetX * r / t, e -= view.offsetY * n / l, r *= view.width / t, n *= view.height / l
                }
                const l = this.filmOffset;
                0 !== l && (o += t * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(meta) {
                const data = super.toJSON(meta);
                return data.object.fov = this.fov, data.object.zoom = this.zoom, data.object.near = this.near, data.object.far = this.far, data.object.focus = this.focus, data.object.aspect = this.aspect, null !== this.view && (data.object.view = Object.assign({}, this.view)), data.object.filmGauge = this.filmGauge, data.object.filmOffset = this.filmOffset, data
            }
        }
        On.prototype.isPerspectiveCamera = !0;
        const In = 90;
        class Nn extends Te {
            constructor(t, e, n) {
                if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                this.renderTarget = n;
                const r = new On(In, 1, t, e);
                r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Mt(1, 0, 0)), this.add(r);
                const o = new On(In, 1, t, e);
                o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new Mt(-1, 0, 0)), this.add(o);
                const l = new On(In, 1, t, e);
                l.layers = this.layers, l.up.set(0, 0, 1), l.lookAt(new Mt(0, 1, 0)), this.add(l);
                const c = new On(In, 1, t, e);
                c.layers = this.layers, c.up.set(0, 0, -1), c.lookAt(new Mt(0, -1, 0)), this.add(c);
                const h = new On(In, 1, t, e);
                h.layers = this.layers, h.up.set(0, -1, 0), h.lookAt(new Mt(0, 0, 1)), this.add(h);
                const d = new On(In, 1, t, e);
                d.layers = this.layers, d.up.set(0, -1, 0), d.lookAt(new Mt(0, 0, -1)), this.add(d)
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const n = this.renderTarget,
                    [r, o, l, c, h, d] = this.children,
                    f = t.xr.enabled,
                    m = t.getRenderTarget();
                t.xr.enabled = !1;
                const v = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, o), t.setRenderTarget(n, 2), t.render(e, l), t.setRenderTarget(n, 3), t.render(e, c), t.setRenderTarget(n, 4), t.render(e, h), n.texture.generateMipmaps = v, t.setRenderTarget(n, 5), t.render(e, d), t.setRenderTarget(m), t.xr.enabled = f
            }
        }
        class Fn extends vt {
            constructor(t, e, n, r, o, l, h, d, f, m) {
                super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : c, n, r, o, l, h = void 0 !== h ? h : D, d, f, m), this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        Fn.prototype.isCubeTexture = !0;
        class zn extends xt {
            constructor(t, e, n) {
                Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new Fn(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : T, this.texture._needsFlipEnvMap = !1
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type, this.texture.format = O, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                const n = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                        fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                    },
                    r = new Cn(5, 5, 5),
                    l = new Pn({
                        name: "CubemapFromEquirect",
                        uniforms: Ln(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        side: o,
                        blending: 0
                    });
                l.uniforms.tEquirect.value = e;
                const c = new En(r, l),
                    h = e.minFilter;
                e.minFilter === E && (e.minFilter = T);
                return new Nn(1, 10, this).update(t, c), e.minFilter = h, c.geometry.dispose(), c.material.dispose(), this
            }
            clear(t, e, n, r) {
                const o = t.getRenderTarget();
                for (let i = 0; i < 6; i++) t.setRenderTarget(this, i), t.clear(e, n, r);
                t.setRenderTarget(o)
            }
        }
        zn.prototype.isWebGLCubeRenderTarget = !0;
        const Bn = new Mt,
            Un = new Mt,
            Hn = new pt;
        class jn {
            constructor(t = new Mt(1, 0, 0), e = 0) {
                this.normal = t, this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t), this.constant = e, this
            }
            setComponents(t, e, n, r) {
                return this.normal.set(t, e, n), this.constant = r, this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            }
            setFromCoplanarPoints(a, b, t) {
                const e = Bn.subVectors(t, b).cross(Un.subVectors(a, b)).normalize();
                return this.setFromNormalAndCoplanarPoint(e, a), this
            }
            copy(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            }
            intersectLine(line, t) {
                const e = line.delta(Bn),
                    n = this.normal.dot(e);
                if (0 === n) return 0 === this.distanceToPoint(line.start) ? t.copy(line.start) : null;
                const r = -(line.start.dot(this.normal) + this.constant) / n;
                return r < 0 || r > 1 ? null : t.copy(e).multiplyScalar(r).add(line.start)
            }
            intersectsLine(line) {
                const t = this.distanceToPoint(line.start),
                    e = this.distanceToPoint(line.end);
                return t < 0 && e > 0 || e < 0 && t > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || Hn.getNormalMatrix(t),
                    r = this.coplanarPoint(Bn).applyMatrix4(t),
                    o = this.normal.applyMatrix3(n).normalize();
                return this.constant = -r.dot(o), this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal), this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        jn.prototype.isPlane = !0;
        const Vn = new Wt,
            Gn = new Mt;
        class Wn {
            constructor(t = new jn, e = new jn, n = new jn, r = new jn, o = new jn, l = new jn) {
                this.planes = [t, e, n, r, o, l]
            }
            set(t, e, n, r, o, l) {
                const c = this.planes;
                return c[0].copy(t), c[1].copy(e), c[2].copy(n), c[3].copy(r), c[4].copy(o), c[5].copy(l), this
            }
            copy(t) {
                const e = this.planes;
                for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                return this
            }
            setFromProjectionMatrix(t) {
                const e = this.planes,
                    n = t.elements,
                    r = n[0],
                    o = n[1],
                    l = n[2],
                    c = n[3],
                    h = n[4],
                    d = n[5],
                    f = n[6],
                    m = n[7],
                    v = n[8],
                    y = n[9],
                    _ = n[10],
                    x = n[11],
                    w = n[12],
                    M = n[13],
                    S = n[14],
                    T = n[15];
                return e[0].setComponents(c - r, m - h, x - v, T - w).normalize(), e[1].setComponents(c + r, m + h, x + v, T + w).normalize(), e[2].setComponents(c + o, m + d, x + y, T + M).normalize(), e[3].setComponents(c - o, m - d, x - y, T - M).normalize(), e[4].setComponents(c - l, m - f, x - _, T - S).normalize(), e[5].setComponents(c + l, m + f, x + _, T + S).normalize(), this
            }
            intersectsObject(object) {
                const t = object.geometry;
                return null === t.boundingSphere && t.computeBoundingSphere(), Vn.copy(t.boundingSphere).applyMatrix4(object.matrixWorld), this.intersectsSphere(Vn)
            }
            intersectsSprite(t) {
                return Vn.center.set(0, 0, 0), Vn.radius = .7071067811865476, Vn.applyMatrix4(t.matrixWorld), this.intersectsSphere(Vn)
            }
            intersectsSphere(t) {
                const e = this.planes,
                    n = t.center,
                    r = -t.radius;
                for (let i = 0; i < 6; i++) {
                    if (e[i].distanceToPoint(n) < r) return !1
                }
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let i = 0; i < 6; i++) {
                    const n = e[i];
                    if (Gn.x = n.normal.x > 0 ? t.max.x : t.min.x, Gn.y = n.normal.y > 0 ? t.max.y : t.min.y, Gn.z = n.normal.z > 0 ? t.max.z : t.min.z, n.distanceToPoint(Gn) < 0) return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let i = 0; i < 6; i++)
                    if (e[i].distanceToPoint(t) < 0) return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }

        function qn() {
            let t = null,
                e = !1,
                n = null,
                r = null;

            function o(time, e) {
                n(time, e), r = t.requestAnimationFrame(o)
            }
            return {
                start: function() {
                    !0 !== e && null !== n && (r = t.requestAnimationFrame(o), e = !0)
                },
                stop: function() {
                    t.cancelAnimationFrame(r), e = !1
                },
                setAnimationLoop: function(t) {
                    n = t
                },
                setContext: function(e) {
                    t = e
                }
            }
        }

        function Xn(t, e) {
            const n = e.isWebGL2,
                r = new WeakMap;
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), r.get(t)
                },
                remove: function(e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const data = r.get(e);
                    data && (t.deleteBuffer(data.buffer), r.delete(e))
                },
                update: function(e, o) {
                    if (e.isGLBufferAttribute) {
                        const t = r.get(e);
                        return void((!t || t.version < e.version) && r.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const data = r.get(e);
                    void 0 === data ? r.set(e, function(e, r) {
                        const o = e.array,
                            l = e.usage,
                            c = t.createBuffer();
                        t.bindBuffer(r, c), t.bufferData(r, o, l), e.onUploadCallback();
                        let h = 5126;
                        return o instanceof Float32Array ? h = 5126 : o instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : o instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? h = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : h = 5123 : o instanceof Int16Array ? h = 5122 : o instanceof Uint32Array ? h = 5125 : o instanceof Int32Array ? h = 5124 : o instanceof Int8Array ? h = 5120 : (o instanceof Uint8Array || o instanceof Uint8ClampedArray) && (h = 5121), {
                            buffer: c,
                            type: h,
                            bytesPerElement: o.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(e, o)) : data.version < e.version && (! function(e, r, o) {
                        const l = r.array,
                            c = r.updateRange;
                        t.bindBuffer(o, e), -1 === c.count ? t.bufferSubData(o, 0, l) : (n ? t.bufferSubData(o, c.offset * l.BYTES_PER_ELEMENT, l, c.offset, c.count) : t.bufferSubData(o, c.offset * l.BYTES_PER_ELEMENT, l.subarray(c.offset, c.offset + c.count)), c.count = -1)
                    }(data.buffer, e, o), data.version = e.version)
                }
            }
        }
        class $n extends ln {
            constructor(t = 1, e = 1, n = 1, r = 1) {
                super(), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: r
                };
                const o = t / 2,
                    l = e / 2,
                    c = Math.floor(n),
                    h = Math.floor(r),
                    d = c + 1,
                    f = h + 1,
                    m = t / c,
                    v = e / h,
                    y = [],
                    _ = [],
                    x = [],
                    w = [];
                for (let t = 0; t < f; t++) {
                    const e = t * v - l;
                    for (let n = 0; n < d; n++) {
                        const r = n * m - o;
                        _.push(r, -e, 0), x.push(0, 0, 1), w.push(n / c), w.push(1 - t / h)
                    }
                }
                for (let t = 0; t < h; t++)
                    for (let e = 0; e < c; e++) {
                        const a = e + d * t,
                            b = e + d * (t + 1),
                            n = e + 1 + d * (t + 1),
                            r = e + 1 + d * t;
                        y.push(a, b, r), y.push(b, n, r)
                    }
                this.setIndex(y), this.setAttribute("position", new Ke(_, 3)), this.setAttribute("normal", new Ke(x, 3)), this.setAttribute("uv", new Ke(w, 2))
            }
            static fromJSON(data) {
                return new $n(data.width, data.height, data.widthSegments, data.heightSegments)
            }
        }
        const Yn = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( f90 - f0 ) * fresnel + f0;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\t#ifdef SPECULAR\n\t\tvec3 specularIntensityFactor = vec3( specularIntensity );\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\n\t#else\n\t\tvec3 specularIntensityFactor = vec3( 1.0 );\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularColorF90 = vec3( 1.0 );\n\t#endif\n\tmaterial.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularColorF90 = vec3( 1.0 );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n\tvec3 specularColorF90;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif",
                transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif",
                uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t\t#ifdef USE_TANGENT\n\t\t\tvTangent = normalize( transformedTangent );\n\t\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t\t#endif\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}",
                normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
            },
            Zn = {
                common: {
                    diffuse: {
                        value: new We(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new pt
                    },
                    uv2Transform: {
                        value: new pt
                    },
                    alphaMap: {
                        value: null
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    },
                    maxMipLevel: {
                        value: 0
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new ht(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new We(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new We(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    uvTransform: {
                        value: new pt
                    }
                },
                sprite: {
                    diffuse: {
                        value: new We(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new ht(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    uvTransform: {
                        value: new pt
                    }
                }
            },
            Jn = {
                basic: {
                    uniforms: kn([Zn.common, Zn.specularmap, Zn.envmap, Zn.aomap, Zn.lightmap, Zn.fog]),
                    vertexShader: Yn.meshbasic_vert,
                    fragmentShader: Yn.meshbasic_frag
                },
                lambert: {
                    uniforms: kn([Zn.common, Zn.specularmap, Zn.envmap, Zn.aomap, Zn.lightmap, Zn.emissivemap, Zn.fog, Zn.lights, {
                        emissive: {
                            value: new We(0)
                        }
                    }]),
                    vertexShader: Yn.meshlambert_vert,
                    fragmentShader: Yn.meshlambert_frag
                },
                phong: {
                    uniforms: kn([Zn.common, Zn.specularmap, Zn.envmap, Zn.aomap, Zn.lightmap, Zn.emissivemap, Zn.bumpmap, Zn.normalmap, Zn.displacementmap, Zn.fog, Zn.lights, {
                        emissive: {
                            value: new We(0)
                        },
                        specular: {
                            value: new We(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: Yn.meshphong_vert,
                    fragmentShader: Yn.meshphong_frag
                },
                standard: {
                    uniforms: kn([Zn.common, Zn.envmap, Zn.aomap, Zn.lightmap, Zn.emissivemap, Zn.bumpmap, Zn.normalmap, Zn.displacementmap, Zn.roughnessmap, Zn.metalnessmap, Zn.fog, Zn.lights, {
                        emissive: {
                            value: new We(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Yn.meshphysical_vert,
                    fragmentShader: Yn.meshphysical_frag
                },
                toon: {
                    uniforms: kn([Zn.common, Zn.aomap, Zn.lightmap, Zn.emissivemap, Zn.bumpmap, Zn.normalmap, Zn.displacementmap, Zn.gradientmap, Zn.fog, Zn.lights, {
                        emissive: {
                            value: new We(0)
                        }
                    }]),
                    vertexShader: Yn.meshtoon_vert,
                    fragmentShader: Yn.meshtoon_frag
                },
                matcap: {
                    uniforms: kn([Zn.common, Zn.bumpmap, Zn.normalmap, Zn.displacementmap, Zn.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: Yn.meshmatcap_vert,
                    fragmentShader: Yn.meshmatcap_frag
                },
                points: {
                    uniforms: kn([Zn.points, Zn.fog]),
                    vertexShader: Yn.points_vert,
                    fragmentShader: Yn.points_frag
                },
                dashed: {
                    uniforms: kn([Zn.common, Zn.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: Yn.linedashed_vert,
                    fragmentShader: Yn.linedashed_frag
                },
                depth: {
                    uniforms: kn([Zn.common, Zn.displacementmap]),
                    vertexShader: Yn.depth_vert,
                    fragmentShader: Yn.depth_frag
                },
                normal: {
                    uniforms: kn([Zn.common, Zn.bumpmap, Zn.normalmap, Zn.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Yn.normal_vert,
                    fragmentShader: Yn.normal_frag
                },
                sprite: {
                    uniforms: kn([Zn.sprite, Zn.fog]),
                    vertexShader: Yn.sprite_vert,
                    fragmentShader: Yn.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new pt
                        },
                        t2D: {
                            value: null
                        }
                    },
                    vertexShader: Yn.background_vert,
                    fragmentShader: Yn.background_frag
                },
                cube: {
                    uniforms: kn([Zn.envmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Yn.cube_vert,
                    fragmentShader: Yn.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: Yn.equirect_vert,
                    fragmentShader: Yn.equirect_frag
                },
                distanceRGBA: {
                    uniforms: kn([Zn.common, Zn.displacementmap, {
                        referencePosition: {
                            value: new Mt
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: Yn.distanceRGBA_vert,
                    fragmentShader: Yn.distanceRGBA_frag
                },
                shadow: {
                    uniforms: kn([Zn.lights, Zn.fog, {
                        color: {
                            value: new We(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Yn.shadow_vert,
                    fragmentShader: Yn.shadow_frag
                }
            };

        function Kn(t, e, n, l, c) {
            const h = new We(0);
            let d, f, v = 0,
                y = null,
                _ = 0,
                x = null;

            function w(t, e) {
                n.buffers.color.setClear(t.r, t.g, t.b, e, c)
            }
            return {
                getClearColor: function() {
                    return h
                },
                setClearColor: function(t, e = 1) {
                    h.set(t), v = e, w(h, v)
                },
                getClearAlpha: function() {
                    return v
                },
                setClearAlpha: function(t) {
                    v = t, w(h, v)
                },
                render: function(n, c) {
                    let M = !1,
                        S = !0 === c.isScene ? c.background : null;
                    S && S.isTexture && (S = e.get(S));
                    const T = t.xr,
                        E = T.getSession && T.getSession();
                    E && "additive" === E.environmentBlendMode && (S = null), null === S ? w(h, v) : S && S.isColor && (w(S, 1), M = !0), (t.autoClear || M) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), S && (S.isCubeTexture || S.mapping === m) ? (void 0 === f && (f = new En(new Cn(1, 1, 1), new Pn({
                        name: "BackgroundCubeMaterial",
                        uniforms: Ln(Jn.cube.uniforms),
                        vertexShader: Jn.cube.vertexShader,
                        fragmentShader: Jn.cube.fragmentShader,
                        side: o,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), f.geometry.deleteAttribute("normal"), f.geometry.deleteAttribute("uv"), f.onBeforeRender = function(t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(f.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }), l.update(f)), f.material.uniforms.envMap.value = S, f.material.uniforms.flipEnvMap.value = S.isCubeTexture && !1 === S.isRenderTargetTexture ? -1 : 1, y === S && _ === S.version && x === t.toneMapping || (f.material.needsUpdate = !0, y = S, _ = S.version, x = t.toneMapping), n.unshift(f, f.geometry, f.material, 0, 0, null)) : S && S.isTexture && (void 0 === d && (d = new En(new $n(2, 2), new Pn({
                        name: "BackgroundMaterial",
                        uniforms: Ln(Jn.background.uniforms),
                        vertexShader: Jn.background.vertexShader,
                        fragmentShader: Jn.background.fragmentShader,
                        side: r,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), d.geometry.deleteAttribute("normal"), Object.defineProperty(d.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }), l.update(d)), d.material.uniforms.t2D.value = S, !0 === S.matrixAutoUpdate && S.updateMatrix(), d.material.uniforms.uvTransform.value.copy(S.matrix), y === S && _ === S.version && x === t.toneMapping || (d.material.needsUpdate = !0, y = S, _ = S.version, x = t.toneMapping), n.unshift(d, d.geometry, d.material, 0, 0, null))
                }
            }
        }

        function Qn(t, e, n, r) {
            const o = t.getParameter(34921),
                l = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                c = r.isWebGL2 || null !== l,
                h = {},
                d = y(null);
            let f = d;

            function m(e) {
                return r.isWebGL2 ? t.bindVertexArray(e) : l.bindVertexArrayOES(e)
            }

            function v(e) {
                return r.isWebGL2 ? t.deleteVertexArray(e) : l.deleteVertexArrayOES(e)
            }

            function y(t) {
                const e = [],
                    n = [],
                    r = [];
                for (let i = 0; i < o; i++) e[i] = 0, n[i] = 0, r[i] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: r,
                    object: t,
                    attributes: {},
                    index: null
                }
            }

            function _() {
                const t = f.newAttributes;
                for (let i = 0, e = t.length; i < e; i++) t[i] = 0
            }

            function x(t) {
                w(t, 0)
            }

            function w(n, o) {
                const l = f.newAttributes,
                    c = f.enabledAttributes,
                    h = f.attributeDivisors;
                if (l[n] = 1, 0 === c[n] && (t.enableVertexAttribArray(n), c[n] = 1), h[n] !== o) {
                    (r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, o), h[n] = o
                }
            }

            function M() {
                const e = f.newAttributes,
                    n = f.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
            }

            function S(e, n, o, l, c, h) {
                !0 !== r.isWebGL2 || 5124 !== o && 5125 !== o ? t.vertexAttribPointer(e, n, o, l, c, h) : t.vertexAttribIPointer(e, n, o, c, h)
            }

            function T() {
                E(), f !== d && (f = d, m(f.object))
            }

            function E() {
                d.geometry = null, d.program = null, d.wireframe = !1
            }
            return {
                setup: function(object, o, d, v, T) {
                    let E = !1;
                    if (c) {
                        const e = function(e, n, o) {
                            const c = !0 === o.wireframe;
                            let d = h[e.id];
                            void 0 === d && (d = {}, h[e.id] = d);
                            let f = d[n.id];
                            void 0 === f && (f = {}, d[n.id] = f);
                            let m = f[c];
                            void 0 === m && (m = y(r.isWebGL2 ? t.createVertexArray() : l.createVertexArrayOES()), f[c] = m);
                            return m
                        }(v, d, o);
                        f !== e && (f = e, m(f.object)), E = function(t, e) {
                            const n = f.attributes,
                                r = t.attributes;
                            let o = 0;
                            for (const t in r) {
                                const e = n[t],
                                    l = r[t];
                                if (void 0 === e) return !0;
                                if (e.attribute !== l) return !0;
                                if (e.data !== l.data) return !0;
                                o++
                            }
                            return f.attributesNum !== o || f.index !== e
                        }(v, T), E && function(t, e) {
                            const n = {},
                                r = t.attributes;
                            let o = 0;
                            for (const t in r) {
                                const e = r[t],
                                    data = {};
                                data.attribute = e, e.data && (data.data = e.data), n[t] = data, o++
                            }
                            f.attributes = n, f.attributesNum = o, f.index = e
                        }(v, T)
                    } else {
                        const t = !0 === o.wireframe;
                        f.geometry === v.id && f.program === d.id && f.wireframe === t || (f.geometry = v.id, f.program = d.id, f.wireframe = t, E = !0)
                    }!0 === object.isInstancedMesh && (E = !0), null !== T && n.update(T, 34963), E && (! function(object, o, l, c) {
                        if (!1 === r.isWebGL2 && (object.isInstancedMesh || c.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                        _();
                        const h = c.attributes,
                            d = l.getAttributes(),
                            f = o.defaultAttributeValues;
                        for (const e in d) {
                            const r = d[e];
                            if (r >= 0) {
                                const o = h[e];
                                if (void 0 !== o) {
                                    const e = o.normalized,
                                        l = o.itemSize,
                                        h = n.get(o);
                                    if (void 0 === h) continue;
                                    const d = h.buffer,
                                        f = h.type,
                                        m = h.bytesPerElement;
                                    if (o.isInterleavedBufferAttribute) {
                                        const data = o.data,
                                            n = data.stride,
                                            h = o.offset;
                                        data && data.isInstancedInterleavedBuffer ? (w(r, data.meshPerAttribute), void 0 === c._maxInstanceCount && (c._maxInstanceCount = data.meshPerAttribute * data.count)) : x(r), t.bindBuffer(34962, d), S(r, l, f, e, n * m, h * m)
                                    } else o.isInstancedBufferAttribute ? (w(r, o.meshPerAttribute), void 0 === c._maxInstanceCount && (c._maxInstanceCount = o.meshPerAttribute * o.count)) : x(r), t.bindBuffer(34962, d), S(r, l, f, e, 0, 0)
                                } else if ("instanceMatrix" === e) {
                                    const e = n.get(object.instanceMatrix);
                                    if (void 0 === e) continue;
                                    const o = e.buffer,
                                        l = e.type;
                                    w(r + 0, 1), w(r + 1, 1), w(r + 2, 1), w(r + 3, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(r + 0, 4, l, !1, 64, 0), t.vertexAttribPointer(r + 1, 4, l, !1, 64, 16), t.vertexAttribPointer(r + 2, 4, l, !1, 64, 32), t.vertexAttribPointer(r + 3, 4, l, !1, 64, 48)
                                } else if ("instanceColor" === e) {
                                    const e = n.get(object.instanceColor);
                                    if (void 0 === e) continue;
                                    const o = e.buffer,
                                        l = e.type;
                                    w(r, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(r, 3, l, !1, 12, 0)
                                } else if (void 0 !== f) {
                                    const n = f[e];
                                    if (void 0 !== n) switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(r, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(r, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(r, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(r, n)
                                    }
                                }
                            }
                        }
                        M()
                    }(object, o, d, v), null !== T && t.bindBuffer(34963, n.get(T).buffer))
                },
                reset: T,
                resetDefaultState: E,
                dispose: function() {
                    T();
                    for (const t in h) {
                        const e = h[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n) v(n[t].object), delete n[t];
                            delete e[t]
                        }
                        delete h[t]
                    }
                },
                releaseStatesOfGeometry: function(t) {
                    if (void 0 === h[t.id]) return;
                    const e = h[t.id];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n) v(n[t].object), delete n[t];
                        delete e[t]
                    }
                    delete h[t.id]
                },
                releaseStatesOfProgram: function(t) {
                    for (const e in h) {
                        const n = h[e];
                        if (void 0 === n[t.id]) continue;
                        const r = n[t.id];
                        for (const t in r) v(r[t].object), delete r[t];
                        delete n[t.id]
                    }
                },
                initAttributes: _,
                enableAttribute: x,
                disableUnusedAttributes: M
            }
        }

        function er(t, e, n, r) {
            const o = r.isWebGL2;
            let l;
            this.setMode = function(t) {
                l = t
            }, this.render = function(e, r) {
                t.drawArrays(l, e, r), n.update(r, l, 1)
            }, this.renderInstances = function(r, c, h) {
                if (0 === h) return;
                let d, f;
                if (o) d = t, f = "drawArraysInstanced";
                else if (d = e.get("ANGLE_instanced_arrays"), f = "drawArraysInstancedANGLE", null === d) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                d[f](l, r, c, h), n.update(c, l, h)
            }
        }

        function nr(t, e, n) {
            let r;

            function o(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }
            const l = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
            let c = void 0 !== n.precision ? n.precision : "highp";
            const h = o(c);
            h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."), c = h);
            const d = l || e.has("WEBGL_draw_buffers"),
                f = !0 === n.logarithmicDepthBuffer,
                m = t.getParameter(34930),
                v = t.getParameter(35660),
                y = t.getParameter(3379),
                _ = t.getParameter(34076),
                x = t.getParameter(34921),
                w = t.getParameter(36347),
                M = t.getParameter(36348),
                S = t.getParameter(36349),
                T = v > 0,
                E = l || e.has("OES_texture_float");
            return {
                isWebGL2: l,
                drawBuffers: d,
                getMaxAnisotropy: function() {
                    if (void 0 !== r) return r;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const n = e.get("EXT_texture_filter_anisotropic");
                        r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else r = 0;
                    return r
                },
                getMaxPrecision: o,
                precision: c,
                logarithmicDepthBuffer: f,
                maxTextures: m,
                maxVertexTextures: v,
                maxTextureSize: y,
                maxCubemapSize: _,
                maxAttributes: x,
                maxVertexUniforms: w,
                maxVaryings: M,
                maxFragmentUniforms: S,
                vertexTextures: T,
                floatFragmentTextures: E,
                floatVertexTextures: T && E,
                maxSamples: l ? t.getParameter(36183) : 0
            }
        }

        function rr(t) {
            const e = this;
            let n = null,
                r = 0,
                o = !1,
                l = !1;
            const c = new jn,
                h = new pt,
                d = {
                    value: null,
                    needsUpdate: !1
                };

            function f() {
                d.value !== n && (d.value = n, d.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0
            }

            function m(t, n, r, o) {
                const l = null !== t ? t.length : 0;
                let f = null;
                if (0 !== l) {
                    if (f = d.value, !0 !== o || null === f) {
                        const e = r + 4 * l,
                            o = n.matrixWorldInverse;
                        h.getNormalMatrix(o), (null === f || f.length < e) && (f = new Float32Array(e));
                        for (let i = 0, e = r; i !== l; ++i, e += 4) c.copy(t[i]).applyMatrix4(o, h), c.normal.toArray(f, e), f[e + 3] = c.constant
                    }
                    d.value = f, d.needsUpdate = !0
                }
                return e.numPlanes = l, e.numIntersection = 0, f
            }
            this.uniform = d, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, l) {
                const c = 0 !== t.length || e || 0 !== r || o;
                return o = e, n = m(t, l, 0), r = t.length, c
            }, this.beginShadows = function() {
                l = !0, m(null)
            }, this.endShadows = function() {
                l = !1, f()
            }, this.setState = function(e, c, h) {
                const v = e.clippingPlanes,
                    y = e.clipIntersection,
                    _ = e.clipShadows,
                    x = t.get(e);
                if (!o || null === v || 0 === v.length || l && !_) l ? m(null) : f();
                else {
                    const t = l ? 0 : r,
                        e = 4 * t;
                    let o = x.clippingState || null;
                    d.value = o, o = m(v, c, e, h);
                    for (let i = 0; i !== e; ++i) o[i] = n[i];
                    x.clippingState = o, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += t
                }
            }
        }

        function ir(t) {
            let e = new WeakMap;

            function n(t, e) {
                return e === d ? t.mapping = c : e === f && (t.mapping = h), t
            }

            function r(t) {
                const n = t.target;
                n.removeEventListener("dispose", r);
                const o = e.get(n);
                void 0 !== o && (e.delete(n), o.dispose())
            }
            return {
                get: function(o) {
                    if (o && o.isTexture && !1 === o.isRenderTargetTexture) {
                        const l = o.mapping;
                        if (l === d || l === f) {
                            if (e.has(o)) {
                                return n(e.get(o).texture, o.mapping)
                            } {
                                const image = o.image;
                                if (image && image.height > 0) {
                                    const l = t.getRenderTarget(),
                                        c = new zn(image.height / 2);
                                    return c.fromEquirectangularTexture(t, o), e.set(o, c), t.setRenderTarget(l), o.addEventListener("dispose", r), n(c.texture, o.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return o
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        Jn.physical = {
            uniforms: kn([Jn.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new ht(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: new We(0)
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionSamplerSize: {
                    value: new ht
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationTint: {
                    value: new We(0)
                },
                specularIntensity: {
                    value: 0
                },
                specularIntensityMap: {
                    value: null
                },
                specularTint: {
                    value: new We(1, 1, 1)
                },
                specularTintMap: {
                    value: null
                }
            }]),
            vertexShader: Yn.meshphysical_vert,
            fragmentShader: Yn.meshphysical_frag
        };
        class or extends Dn {
            constructor(t = -1, e = 1, n = 1, r = -1, o = .1, l = 2e3) {
                super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = o, this.far = l, this.updateProjectionMatrix()
            }
            copy(source, t) {
                return super.copy(source, t), this.left = source.left, this.right = source.right, this.top = source.top, this.bottom = source.bottom, this.near = source.near, this.far = source.far, this.zoom = source.zoom, this.view = null === source.view ? null : Object.assign({}, source.view), this
            }
            setViewOffset(t, e, n, r, o, l) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = o, this.view.height = l, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    r = (this.top + this.bottom) / 2;
                let o = n - t,
                    l = n + t,
                    c = r + e,
                    h = r - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    o += t * this.view.offsetX, l = o + t * this.view.width, c -= e * this.view.offsetY, h = c - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(o, l, c, h, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(meta) {
                const data = super.toJSON(meta);
                return data.object.zoom = this.zoom, data.object.left = this.left, data.object.right = this.right, data.object.top = this.top, data.object.bottom = this.bottom, data.object.near = this.near, data.object.far = this.far, null !== this.view && (data.object.view = Object.assign({}, this.view)), data
            }
        }
        or.prototype.isOrthographicCamera = !0;
        class ar extends Pn {
            constructor(t) {
                super(t), this.type = "RawShaderMaterial"
            }
        }
        ar.prototype.isRawShaderMaterial = !0;
        const sr = Math.pow(2, 8),
            lr = [.125, .215, .35, .446, .526, .582],
            cr = 5 + lr.length,
            ur = 20,
            dr = {
                [W]: 0,
                [X]: 1,
                [Y]: 2,
                3004: 3,
                3005: 4,
                3006: 5,
                [$]: 6
            },
            pr = new qe({
                side: o,
                depthWrite: !1,
                depthTest: !1
            }),
            fr = new En(new Cn, pr),
            mr = new or,
            {
                _lodPlanes: gr,
                _sizeLods: vr,
                _sigmas: yr
            } = Cr(),
            _r = new We;
        let xr = null;
        const wr = (1 + Math.sqrt(5)) / 2,
            Mr = 1 / wr,
            Sr = [new Mt(1, 1, 1), new Mt(-1, 1, 1), new Mt(1, 1, -1), new Mt(-1, 1, -1), new Mt(0, wr, Mr), new Mt(0, wr, -Mr), new Mt(Mr, 0, wr), new Mt(-Mr, 0, wr), new Mt(wr, Mr, 0), new Mt(-wr, Mr, 0)];

        function Tr(t) {
            const e = Math.max(t.r, t.g, t.b),
                n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
            t.multiplyScalar(Math.pow(2, -n));
            return (n + 128) / 255
        }
        class Er {
            constructor(t) {
                this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function(t) {
                    const e = new Float32Array(t),
                        n = new Mt(0, 1, 0);
                    return new ar({
                        name: "SphericalGaussianBlur",
                        defines: {
                            n: t
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            samples: {
                                value: 1
                            },
                            weights: {
                                value: e
                            },
                            latitudinal: {
                                value: !1
                            },
                            dTheta: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            },
                            poleAxis: {
                                value: n
                            },
                            inputEncoding: {
                                value: dr[3e3]
                            },
                            outputEncoding: {
                                value: dr[3e3]
                            }
                        },
                        vertexShader: Dr(),
                        fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${Or()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }(ur), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
            }
            fromScene(t, e = 0, n = .1, r = 100) {
                xr = this._renderer.getRenderTarget();
                const o = this._allocateTargets();
                return this._sceneToCubeUV(t, n, r, o), e > 0 && this._blur(o, 0, 0, e), this._applyPMREM(o), this._cleanup(o), o
            }
            fromEquirectangular(t) {
                return this._fromTexture(t)
            }
            fromCubemap(t) {
                return this._fromTexture(t)
            }
            compileCubemapShader() {
                null === this._cubemapShader && (this._cubemapShader = Pr(), this._compileMaterial(this._cubemapShader))
            }
            compileEquirectangularShader() {
                null === this._equirectShader && (this._equirectShader = Rr(), this._compileMaterial(this._equirectShader))
            }
            dispose() {
                this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
                for (let i = 0; i < gr.length; i++) gr[i].dispose()
            }
            _cleanup(t) {
                this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(xr), t.scissorTest = !1, kr(t, 0, 0, t.width, t.height)
            }
            _fromTexture(t) {
                xr = this._renderer.getRenderTarget();
                const e = this._allocateTargets(t);
                return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
            }
            _allocateTargets(t) {
                const e = {
                        magFilter: w,
                        minFilter: w,
                        generateMipmaps: !1,
                        type: A,
                        format: I,
                        encoding: Ar(t) ? t.encoding : Y,
                        depthBuffer: !1
                    },
                    n = Lr(e);
                return n.depthBuffer = !t, this._pingPongRenderTarget = Lr(e), n
            }
            _compileMaterial(t) {
                const e = new En(gr[0], t);
                this._renderer.compile(e, mr)
            }
            _sceneToCubeUV(t, e, n, r) {
                const o = new On(90, 1, e, n),
                    l = [1, -1, 1, 1, 1, 1],
                    c = [1, 1, 1, -1, -1, -1],
                    h = this._renderer,
                    d = h.autoClear,
                    f = h.outputEncoding,
                    m = h.toneMapping;
                h.getClearColor(_r), h.toneMapping = 0, h.outputEncoding = W, h.autoClear = !1;
                let v = !1;
                const y = t.background;
                if (y) {
                    if (y.isColor) {
                        pr.color.copy(y).convertSRGBToLinear(), t.background = null;
                        const e = Tr(pr.color);
                        pr.opacity = e, v = !0
                    }
                } else {
                    pr.color.copy(_r).convertSRGBToLinear();
                    const t = Tr(pr.color);
                    pr.opacity = t, v = !0
                }
                for (let i = 0; i < 6; i++) {
                    const col = i % 3;
                    0 == col ? (o.up.set(0, l[i], 0), o.lookAt(c[i], 0, 0)) : 1 == col ? (o.up.set(0, 0, l[i]), o.lookAt(0, c[i], 0)) : (o.up.set(0, l[i], 0), o.lookAt(0, 0, c[i])), kr(r, col * sr, i > 2 ? sr : 0, sr, sr), h.setRenderTarget(r), v && h.render(fr, o), h.render(t, o)
                }
                h.toneMapping = m, h.outputEncoding = f, h.autoClear = d
            }
            _textureToCubeUV(t, e) {
                const n = this._renderer;
                t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Pr()) : null == this._equirectShader && (this._equirectShader = Rr());
                const r = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
                    o = new En(gr[0], r),
                    l = r.uniforms;
                l.envMap.value = t, t.isCubeTexture || l.texelSize.value.set(1 / t.image.width, 1 / t.image.height), l.inputEncoding.value = dr[t.encoding], l.outputEncoding.value = dr[e.texture.encoding], kr(e, 0, 0, 3 * sr, 2 * sr), n.setRenderTarget(e), n.render(o, mr)
            }
            _applyPMREM(t) {
                const e = this._renderer,
                    n = e.autoClear;
                e.autoClear = !1;
                for (let i = 1; i < cr; i++) {
                    const e = Math.sqrt(yr[i] * yr[i] - yr[i - 1] * yr[i - 1]),
                        n = Sr[(i - 1) % Sr.length];
                    this._blur(t, i - 1, i, e, n)
                }
                e.autoClear = n
            }
            _blur(t, e, n, r, o) {
                const l = this._pingPongRenderTarget;
                this._halfBlur(t, l, e, n, r, "latitudinal", o), this._halfBlur(l, t, n, n, r, "longitudinal", o)
            }
            _halfBlur(t, e, n, r, o, l, c) {
                const h = this._renderer,
                    d = this._blurMaterial;
                "latitudinal" !== l && "longitudinal" !== l && console.error("blur direction must be either latitudinal or longitudinal!");
                const f = new En(gr[r], d),
                    m = d.uniforms,
                    v = vr[n] - 1,
                    y = isFinite(o) ? Math.PI / (2 * v) : 2 * Math.PI / 39,
                    _ = o / y,
                    x = isFinite(o) ? 1 + Math.floor(3 * _) : ur;
                x > ur && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${x} samples when the maximum is set to 20`);
                const w = [];
                let M = 0;
                for (let i = 0; i < ur; ++i) {
                    const t = i / _,
                        e = Math.exp(-t * t / 2);
                    w.push(e), 0 == i ? M += e : i < x && (M += 2 * e)
                }
                for (let i = 0; i < w.length; i++) w[i] = w[i] / M;
                m.envMap.value = t.texture, m.samples.value = x, m.weights.value = w, m.latitudinal.value = "latitudinal" === l, c && (m.poleAxis.value = c), m.dTheta.value = y, m.mipInt.value = 8 - n, m.inputEncoding.value = dr[t.texture.encoding], m.outputEncoding.value = dr[t.texture.encoding];
                const S = vr[r];
                kr(e, 3 * Math.max(0, sr - 2 * S), (0 === r ? 0 : 2 * sr) + 2 * S * (r > 4 ? r - 8 + 4 : 0), 3 * S, 2 * S), h.setRenderTarget(e), h.render(f, mr)
            }
        }

        function Ar(t) {
            return void 0 !== t && t.type === A && (t.encoding === W || t.encoding === X || t.encoding === $)
        }

        function Cr() {
            const t = [],
                e = [],
                n = [];
            let r = 8;
            for (let i = 0; i < cr; i++) {
                const o = Math.pow(2, r);
                e.push(o);
                let l = 1 / o;
                i > 4 ? l = lr[i - 8 + 4 - 1] : 0 == i && (l = 0), n.push(l);
                const c = 1 / (o - 1),
                    h = -c / 2,
                    d = 1 + c / 2,
                    f = [h, h, d, h, d, d, h, h, d, d, h, d],
                    m = 6,
                    v = 6,
                    y = 3,
                    _ = 2,
                    x = 1,
                    w = new Float32Array(y * v * m),
                    M = new Float32Array(_ * v * m),
                    S = new Float32Array(x * v * m);
                for (let t = 0; t < m; t++) {
                    const e = t % 3 * 2 / 3 - 1,
                        n = t > 2 ? 0 : -1,
                        r = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                    w.set(r, y * v * t), M.set(f, _ * v * t);
                    const o = [t, t, t, t, t, t];
                    S.set(o, x * v * t)
                }
                const T = new ln;
                T.setAttribute("position", new Ye(w, y)), T.setAttribute("uv", new Ye(M, _)), T.setAttribute("faceIndex", new Ye(S, x)), t.push(T), r > 4 && r--
            }
            return {
                _lodPlanes: t,
                _sizeLods: e,
                _sigmas: n
            }
        }

        function Lr(t) {
            const e = new xt(3 * sr, 3 * sr, t);
            return e.texture.mapping = m, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
        }

        function kr(t, e, n, r, o) {
            t.viewport.set(e, n, r, o), t.scissor.set(e, n, r, o)
        }

        function Rr() {
            const t = new ht(1, 1);
            return new ar({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    texelSize: {
                        value: t
                    },
                    inputEncoding: {
                        value: dr[3e3]
                    },
                    outputEncoding: {
                        value: dr[3e3]
                    }
                },
                vertexShader: Dr(),
                fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${Or()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Pr() {
            return new ar({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    inputEncoding: {
                        value: dr[3e3]
                    },
                    outputEncoding: {
                        value: dr[3e3]
                    }
                },
                vertexShader: Dr(),
                fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${Or()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Dr() {
            return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
        }

        function Or() {
            return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
        }

        function Ir(t) {
            let e = new WeakMap,
                n = null;

            function r(t) {
                const n = t.target;
                n.removeEventListener("dispose", r);
                const o = e.get(n);
                void 0 !== o && (o.delete(n), o.dispose())
            }
            return {
                get: function(o) {
                    if (o && o.isTexture && !1 === o.isRenderTargetTexture) {
                        const l = o.mapping,
                            m = l === d || l === f,
                            v = l === c || l === h;
                        if (m || v) {
                            if (e.has(o)) return e.get(o).texture; {
                                const image = o.image;
                                if (m && image && image.height > 0 || v && image && function(image) {
                                        let t = 0;
                                        const e = 6;
                                        for (let i = 0; i < e; i++) void 0 !== image[i] && t++;
                                        return t === e
                                    }(image)) {
                                    const l = t.getRenderTarget();
                                    null === n && (n = new Er(t));
                                    const c = m ? n.fromEquirectangular(o) : n.fromCubemap(o);
                                    return e.set(o, c), t.setRenderTarget(l), o.addEventListener("dispose", r), c.texture
                                }
                                return null
                            }
                        }
                    }
                    return o
                },
                dispose: function() {
                    e = new WeakMap, null !== n && (n.dispose(), n = null)
                }
            }
        }

        function Nr(t) {
            const e = {};

            function n(n) {
                if (void 0 !== e[n]) return e[n];
                let r;
                switch (n) {
                    case "WEBGL_depth_texture":
                        r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        r = t.getExtension(n)
                }
                return e[n] = r, r
            }
            return {
                has: function(t) {
                    return null !== n(t)
                },
                init: function(t) {
                    t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float")
                },
                get: function(t) {
                    const e = n(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                }
            }
        }

        function Fr(t, e, n, r) {
            const o = {},
                l = new WeakMap;

            function c(t) {
                const h = t.target;
                null !== h.index && e.remove(h.index);
                for (const t in h.attributes) e.remove(h.attributes[t]);
                h.removeEventListener("dispose", c), delete o[h.id];
                const d = l.get(h);
                d && (e.remove(d), l.delete(h)), r.releaseStatesOfGeometry(h), !0 === h.isInstancedBufferGeometry && delete h._maxInstanceCount, n.memory.geometries--
            }

            function h(t) {
                const n = [],
                    r = t.index,
                    o = t.attributes.position;
                let c = 0;
                if (null !== r) {
                    const t = r.array;
                    c = r.version;
                    for (let i = 0, e = t.length; i < e; i += 3) {
                        const a = t[i + 0],
                            b = t[i + 1],
                            e = t[i + 2];
                        n.push(a, b, b, e, e, a)
                    }
                } else {
                    const t = o.array;
                    c = o.version;
                    for (let i = 0, e = t.length / 3 - 1; i < e; i += 3) {
                        const a = i + 0,
                            b = i + 1,
                            t = i + 2;
                        n.push(a, b, b, t, t, a)
                    }
                }
                const h = new(Qe(n) > 65535 ? Je : Ze)(n, 1);
                h.version = c;
                const d = l.get(t);
                d && e.remove(d), l.set(t, h)
            }
            return {
                get: function(object, t) {
                    return !0 === o[t.id] || (t.addEventListener("dispose", c), o[t.id] = !0, n.memory.geometries++), t
                },
                update: function(t) {
                    const n = t.attributes;
                    for (const t in n) e.update(n[t], 34962);
                    const r = t.morphAttributes;
                    for (const t in r) {
                        const n = r[t];
                        for (let i = 0, t = n.length; i < t; i++) e.update(n[i], 34962)
                    }
                },
                getWireframeAttribute: function(t) {
                    const e = l.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && h(t)
                    } else h(t);
                    return l.get(t)
                }
            }
        }

        function zr(t, e, n, r) {
            const o = r.isWebGL2;
            let l, c, h;
            this.setMode = function(t) {
                l = t
            }, this.setIndex = function(t) {
                c = t.type, h = t.bytesPerElement
            }, this.render = function(e, r) {
                t.drawElements(l, r, c, e * h), n.update(r, l, 1)
            }, this.renderInstances = function(r, d, f) {
                if (0 === f) return;
                let m, v;
                if (o) m = t, v = "drawElementsInstanced";
                else if (m = e.get("ANGLE_instanced_arrays"), v = "drawElementsInstancedANGLE", null === m) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                m[v](l, d, c, r * h, f), n.update(d, l, f)
            }
        }

        function Br(t) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function() {
                    e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                },
                update: function(t, n, r) {
                    switch (e.calls++, n) {
                        case 4:
                            e.triangles += r * (t / 3);
                            break;
                        case 1:
                            e.lines += r * (t / 2);
                            break;
                        case 3:
                            e.lines += r * (t - 1);
                            break;
                        case 2:
                            e.lines += r * t;
                            break;
                        case 0:
                            e.points += r * t;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                    }
                }
            }
        }

        function Ur(a, b) {
            return a[0] - b[0]
        }

        function Hr(a, b) {
            return Math.abs(b[1]) - Math.abs(a[1])
        }

        function jr(t) {
            const e = {},
                n = new Float32Array(8),
                r = [];
            for (let i = 0; i < 8; i++) r[i] = [i, 0];
            return {
                update: function(object, o, l, c) {
                    const h = object.morphTargetInfluences,
                        d = void 0 === h ? 0 : h.length;
                    let f = e[o.id];
                    if (void 0 === f || f.length !== d) {
                        f = [];
                        for (let i = 0; i < d; i++) f[i] = [i, 0];
                        e[o.id] = f
                    }
                    for (let i = 0; i < d; i++) {
                        const t = f[i];
                        t[0] = i, t[1] = h[i]
                    }
                    f.sort(Hr);
                    for (let i = 0; i < 8; i++) i < d && f[i][1] ? (r[i][0] = f[i][0], r[i][1] = f[i][1]) : (r[i][0] = Number.MAX_SAFE_INTEGER, r[i][1] = 0);
                    r.sort(Ur);
                    const m = o.morphAttributes.position,
                        v = o.morphAttributes.normal;
                    let y = 0;
                    for (let i = 0; i < 8; i++) {
                        const t = r[i],
                            e = t[0],
                            l = t[1];
                        e !== Number.MAX_SAFE_INTEGER && l ? (m && o.getAttribute("morphTarget" + i) !== m[e] && o.setAttribute("morphTarget" + i, m[e]), v && o.getAttribute("morphNormal" + i) !== v[e] && o.setAttribute("morphNormal" + i, v[e]), n[i] = l, y += l) : (m && !0 === o.hasAttribute("morphTarget" + i) && o.deleteAttribute("morphTarget" + i), v && !0 === o.hasAttribute("morphNormal" + i) && o.deleteAttribute("morphNormal" + i), n[i] = 0)
                    }
                    const _ = o.morphTargetsRelative ? 1 : 1 - y;
                    c.getUniforms().setValue(t, "morphTargetBaseInfluence", _), c.getUniforms().setValue(t, "morphTargetInfluences", n)
                }
            }
        }

        function Vr(t, e, n, r) {
            let o = new WeakMap;

            function l(t) {
                const e = t.target;
                e.removeEventListener("dispose", l), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
            }
            return {
                update: function(object) {
                    const t = r.render.frame,
                        c = object.geometry,
                        h = e.get(object, c);
                    return o.get(h) !== t && (e.update(h), o.set(h, t)), object.isInstancedMesh && (!1 === object.hasEventListener("dispose", l) && object.addEventListener("dispose", l), n.update(object.instanceMatrix, 34962), null !== object.instanceColor && n.update(object.instanceColor, 34962)), h
                },
                dispose: function() {
                    o = new WeakMap
                }
            }
        }
        class Gr extends vt {
            constructor(data = null, t = 1, e = 1, n = 1) {
                super(null), this.image = {
                    data: data,
                    width: t,
                    height: e,
                    depth: n
                }, this.magFilter = w, this.minFilter = w, this.wrapR = _, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
        }
        Gr.prototype.isDataTexture2DArray = !0;
        class Wr extends vt {
            constructor(data = null, t = 1, e = 1, n = 1) {
                super(null), this.image = {
                    data: data,
                    width: t,
                    height: e,
                    depth: n
                }, this.magFilter = w, this.minFilter = w, this.wrapR = _, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
        }
        Wr.prototype.isDataTexture3D = !0;
        const qr = new vt,
            Xr = new Gr,
            $r = new Wr,
            Yr = new Fn,
            Zr = [],
            Jr = [],
            Kr = new Float32Array(16),
            Qr = new Float32Array(9),
            ti = new Float32Array(4);

        function ei(t, e, n) {
            const r = t[0];
            if (r <= 0 || r > 0) return t;
            const o = e * n;
            let l = Zr[o];
            if (void 0 === l && (l = new Float32Array(o), Zr[o] = l), 0 !== e) {
                r.toArray(l, 0);
                for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(l, r)
            }
            return l
        }

        function ni(a, b) {
            if (a.length !== b.length) return !1;
            for (let i = 0, t = a.length; i < t; i++)
                if (a[i] !== b[i]) return !1;
            return !0
        }

        function ri(a, b) {
            for (let i = 0, t = b.length; i < t; i++) a[i] = b[i]
        }

        function ii(t, e) {
            let n = Jr[e];
            void 0 === n && (n = new Int32Array(e), Jr[e] = n);
            for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
            return n
        }

        function oi(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
        }

        function ai(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
            else {
                if (ni(n, e)) return;
                t.uniform2fv(this.addr, e), ri(n, e)
            }
        }

        function si(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
            else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
            else {
                if (ni(n, e)) return;
                t.uniform3fv(this.addr, e), ri(n, e)
            }
        }

        function ci(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
            else {
                if (ni(n, e)) return;
                t.uniform4fv(this.addr, e), ri(n, e)
            }
        }

        function ui(t, e) {
            const n = this.cache,
                r = e.elements;
            if (void 0 === r) {
                if (ni(n, e)) return;
                t.uniformMatrix2fv(this.addr, !1, e), ri(n, e)
            } else {
                if (ni(n, r)) return;
                ti.set(r), t.uniformMatrix2fv(this.addr, !1, ti), ri(n, r)
            }
        }

        function hi(t, e) {
            const n = this.cache,
                r = e.elements;
            if (void 0 === r) {
                if (ni(n, e)) return;
                t.uniformMatrix3fv(this.addr, !1, e), ri(n, e)
            } else {
                if (ni(n, r)) return;
                Qr.set(r), t.uniformMatrix3fv(this.addr, !1, Qr), ri(n, r)
            }
        }

        function di(t, e) {
            const n = this.cache,
                r = e.elements;
            if (void 0 === r) {
                if (ni(n, e)) return;
                t.uniformMatrix4fv(this.addr, !1, e), ri(n, e)
            } else {
                if (ni(n, r)) return;
                Kr.set(r), t.uniformMatrix4fv(this.addr, !1, Kr), ri(n, r)
            }
        }

        function pi(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
        }

        function fi(t, e) {
            const n = this.cache;
            ni(n, e) || (t.uniform2iv(this.addr, e), ri(n, e))
        }

        function mi(t, e) {
            const n = this.cache;
            ni(n, e) || (t.uniform3iv(this.addr, e), ri(n, e))
        }

        function gi(t, e) {
            const n = this.cache;
            ni(n, e) || (t.uniform4iv(this.addr, e), ri(n, e))
        }

        function vi(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
        }

        function yi(t, e) {
            const n = this.cache;
            ni(n, e) || (t.uniform2uiv(this.addr, e), ri(n, e))
        }

        function _i(t, e) {
            const n = this.cache;
            ni(n, e) || (t.uniform3uiv(this.addr, e), ri(n, e))
        }

        function xi(t, e) {
            const n = this.cache;
            ni(n, e) || (t.uniform4uiv(this.addr, e), ri(n, e))
        }

        function bi(t, e, n) {
            const r = this.cache,
                o = n.allocateTextureUnit();
            r[0] !== o && (t.uniform1i(this.addr, o), r[0] = o), n.safeSetTexture2D(e || qr, o)
        }

        function wi(t, e, n) {
            const r = this.cache,
                o = n.allocateTextureUnit();
            r[0] !== o && (t.uniform1i(this.addr, o), r[0] = o), n.setTexture3D(e || $r, o)
        }

        function Mi(t, e, n) {
            const r = this.cache,
                o = n.allocateTextureUnit();
            r[0] !== o && (t.uniform1i(this.addr, o), r[0] = o), n.safeSetTextureCube(e || Yr, o)
        }

        function Si(t, e, n) {
            const r = this.cache,
                o = n.allocateTextureUnit();
            r[0] !== o && (t.uniform1i(this.addr, o), r[0] = o), n.setTexture2DArray(e || Xr, o)
        }

        function Ti(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function Ei(t, e) {
            const data = ei(e, this.size, 2);
            t.uniform2fv(this.addr, data)
        }

        function Ai(t, e) {
            const data = ei(e, this.size, 3);
            t.uniform3fv(this.addr, data)
        }

        function Ci(t, e) {
            const data = ei(e, this.size, 4);
            t.uniform4fv(this.addr, data)
        }

        function Li(t, e) {
            const data = ei(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, data)
        }

        function ki(t, e) {
            const data = ei(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, data)
        }

        function Ri(t, e) {
            const data = ei(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, data)
        }

        function Pi(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function Di(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function Oi(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function Ii(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function Ni(t, e) {
            t.uniform1uiv(this.addr, e)
        }

        function Fi(t, e) {
            t.uniform2uiv(this.addr, e)
        }

        function zi(t, e) {
            t.uniform3uiv(this.addr, e)
        }

        function Bi(t, e) {
            t.uniform4uiv(this.addr, e)
        }

        function Ui(t, e, n) {
            const r = e.length,
                o = ii(n, r);
            t.uniform1iv(this.addr, o);
            for (let i = 0; i !== r; ++i) n.safeSetTexture2D(e[i] || qr, o[i])
        }

        function Hi(t, e, n) {
            const r = e.length,
                o = ii(n, r);
            t.uniform1iv(this.addr, o);
            for (let i = 0; i !== r; ++i) n.safeSetTextureCube(e[i] || Yr, o[i])
        }

        function ji(t, e, n) {
            this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                switch (t) {
                    case 5126:
                        return oi;
                    case 35664:
                        return ai;
                    case 35665:
                        return si;
                    case 35666:
                        return ci;
                    case 35674:
                        return ui;
                    case 35675:
                        return hi;
                    case 35676:
                        return di;
                    case 5124:
                    case 35670:
                        return pi;
                    case 35667:
                    case 35671:
                        return fi;
                    case 35668:
                    case 35672:
                        return mi;
                    case 35669:
                    case 35673:
                        return gi;
                    case 5125:
                        return vi;
                    case 36294:
                        return yi;
                    case 36295:
                        return _i;
                    case 36296:
                        return xi;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return bi;
                    case 35679:
                    case 36299:
                    case 36307:
                        return wi;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Mi;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return Si
                }
            }(e.type)
        }

        function Vi(t, e, n) {
            this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                switch (t) {
                    case 5126:
                        return Ti;
                    case 35664:
                        return Ei;
                    case 35665:
                        return Ai;
                    case 35666:
                        return Ci;
                    case 35674:
                        return Li;
                    case 35675:
                        return ki;
                    case 35676:
                        return Ri;
                    case 5124:
                    case 35670:
                        return Pi;
                    case 35667:
                    case 35671:
                        return Di;
                    case 35668:
                    case 35672:
                        return Oi;
                    case 35669:
                    case 35673:
                        return Ii;
                    case 5125:
                        return Ni;
                    case 36294:
                        return Fi;
                    case 36295:
                        return zi;
                    case 36296:
                        return Bi;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Ui;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Hi
                }
            }(e.type)
        }

        function Gi(t) {
            this.id = t, this.seq = [], this.map = {}
        }
        Vi.prototype.updateCache = function(data) {
            const t = this.cache;
            data instanceof Float32Array && t.length !== data.length && (this.cache = new Float32Array(data.length)), ri(t, data)
        }, Gi.prototype.setValue = function(t, e, n) {
            const r = this.seq;
            for (let i = 0, o = r.length; i !== o; ++i) {
                const u = r[i];
                u.setValue(t, e[u.id], n)
            }
        };
        const Wi = /(\w+)(\])?(\[|\.)?/g;

        function qi(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function Xi(t, e, n) {
            const path = t.name,
                r = path.length;
            for (Wi.lastIndex = 0;;) {
                const o = Wi.exec(path),
                    l = Wi.lastIndex;
                let c = o[1];
                const h = "]" === o[2],
                    d = o[3];
                if (h && (c |= 0), void 0 === d || "[" === d && l + 2 === r) {
                    qi(n, void 0 === d ? new ji(c, t, e) : new Vi(c, t, e));
                    break
                } {
                    let t = n.map[c];
                    void 0 === t && (t = new Gi(c), qi(n, t)), n = t
                }
            }
        }

        function $i(t, e) {
            this.seq = [], this.map = {};
            const n = t.getProgramParameter(e, 35718);
            for (let i = 0; i < n; ++i) {
                const n = t.getActiveUniform(e, i);
                Xi(n, t.getUniformLocation(e, n.name), this)
            }
        }

        function Yi(t, e, n) {
            const r = t.createShader(e);
            return t.shaderSource(r, n), t.compileShader(r), r
        }
        $i.prototype.setValue = function(t, e, n, r) {
            const u = this.map[e];
            void 0 !== u && u.setValue(t, n, r)
        }, $i.prototype.setOptional = function(t, object, e) {
            const n = object[e];
            void 0 !== n && this.setValue(t, e, n)
        }, $i.upload = function(t, e, n, r) {
            for (let i = 0, o = e.length; i !== o; ++i) {
                const u = e[i],
                    o = n[u.id];
                !1 !== o.needsUpdate && u.setValue(t, o.value, r)
            }
        }, $i.seqWithValue = function(t, e) {
            const n = [];
            for (let i = 0, r = t.length; i !== r; ++i) {
                const u = t[i];
                u.id in e && n.push(u)
            }
            return n
        };
        let Zi = 0;

        function Ji(t) {
            switch (t) {
                case W:
                    return ["Linear", "( value )"];
                case X:
                    return ["sRGB", "( value )"];
                case Y:
                    return ["RGBE", "( value )"];
                case 3004:
                    return ["RGBM", "( value, 7.0 )"];
                case 3005:
                    return ["RGBM", "( value, 16.0 )"];
                case 3006:
                    return ["RGBD", "( value, 256.0 )"];
                case $:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                case 3003:
                    return ["LogLuv", "( value )"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
            }
        }

        function Ki(t, e, n) {
            const r = t.getShaderParameter(e, 35713),
                o = t.getShaderInfoLog(e).trim();
            if (r && "" === o) return "";
            return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + o + function(t) {
                const e = t.split("\n");
                for (let i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
                return e.join("\n")
            }(t.getShaderSource(e))
        }

        function Qi(t, e) {
            const n = Ji(e);
            return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
        }

        function to(t, e) {
            const n = Ji(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }

        function eo(t, e) {
            let n;
            switch (e) {
                case 1:
                    n = "Linear";
                    break;
                case 2:
                    n = "Reinhard";
                    break;
                case 3:
                    n = "OptimizedCineon";
                    break;
                case 4:
                    n = "ACESFilmic";
                    break;
                case 5:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function no(t) {
            return "" !== t
        }

        function ro(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function io(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const oo = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function ao(t) {
            return t.replace(oo, so)
        }

        function so(t, e) {
            const n = Yn[e];
            if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
            return ao(n)
        }
        const lo = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            co = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function uo(t) {
            return t.replace(co, po).replace(lo, ho)
        }

        function ho(t, e, n, r) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), po(t, e, n, r)
        }

        function po(t, e, n, r) {
            let o = "";
            for (let i = parseInt(e); i < parseInt(n); i++) o += r.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
            return o
        }

        function fo(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
        }

        function mo(t, e, n, r) {
            const o = t.getContext(),
                l = n.defines;
            let d = n.vertexShader,
                f = n.fragmentShader;
            const y = function(t) {
                    let e = "SHADOWMAP_TYPE_BASIC";
                    return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
                }(n),
                _ = function(t) {
                    let e = "ENVMAP_TYPE_CUBE";
                    if (t.envMap) switch (t.envMapMode) {
                        case c:
                        case h:
                            e = "ENVMAP_TYPE_CUBE";
                            break;
                        case m:
                        case v:
                            e = "ENVMAP_TYPE_CUBE_UV"
                    }
                    return e
                }(n),
                x = function(t) {
                    let e = "ENVMAP_MODE_REFLECTION";
                    if (t.envMap) switch (t.envMapMode) {
                        case h:
                        case v:
                            e = "ENVMAP_MODE_REFRACTION"
                    }
                    return e
                }(n),
                w = function(t) {
                    let e = "ENVMAP_BLENDING_NONE";
                    if (t.envMap) switch (t.combine) {
                        case 0:
                            e = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case 1:
                            e = "ENVMAP_BLENDING_MIX";
                            break;
                        case 2:
                            e = "ENVMAP_BLENDING_ADD"
                    }
                    return e
                }(n),
                M = t.gammaFactor > 0 ? t.gammaFactor : 1,
                S = n.isWebGL2 ? "" : function(t) {
                    return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission > 0) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(no).join("\n")
                }(n),
                T = function(t) {
                    const e = [];
                    for (const n in t) {
                        const r = t[n];
                        !1 !== r && e.push("#define " + n + " " + r)
                    }
                    return e.join("\n")
                }(l),
                E = o.createProgram();
            let A, C, L = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (A = [T].filter(no).join("\n"), A.length > 0 && (A += "\n"), C = [S, T].filter(no).join("\n"), C.length > 0 && (C += "\n")) : (A = [fo(n), "#define SHADER_NAME " + n.shaderName, T, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + M, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + x : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + y : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(no).join("\n"), C = [S, fo(n), "#define SHADER_NAME " + n.shaderName, T, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + M, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + _ : "", n.envMap ? "#define " + x : "", n.envMap ? "#define " + w : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + y : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Yn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? eo("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", Yn.encodings_pars_fragment, n.map ? Qi("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Qi("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Qi("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Qi("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularTintMap ? Qi("specularTintMapTexelToLinear", n.specularTintMapEncoding) : "", n.lightMap ? Qi("lightMapTexelToLinear", n.lightMapEncoding) : "", to("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(no).join("\n")), d = ao(d), d = ro(d, n), d = io(d, n), f = ao(f), f = ro(f, n), f = io(f, n), d = uo(d), f = uo(f), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (L = "#version 300 es\n", A = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + A, C = ["#define varying in", n.glslVersion === Q ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === Q ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + C);
            const k = L + C + f,
                R = Yi(o, 35633, L + A + d),
                P = Yi(o, 35632, k);
            if (o.attachShader(E, R), o.attachShader(E, P), void 0 !== n.index0AttributeName ? o.bindAttribLocation(E, 0, n.index0AttributeName) : !0 === n.morphTargets && o.bindAttribLocation(E, 0, "position"), o.linkProgram(E), t.debug.checkShaderErrors) {
                const t = o.getProgramInfoLog(E).trim(),
                    e = o.getShaderInfoLog(R).trim(),
                    n = o.getShaderInfoLog(P).trim();
                let r = !0,
                    l = !0;
                if (!1 === o.getProgramParameter(E, 35714)) {
                    r = !1;
                    const e = Ki(o, R, "vertex"),
                        n = Ki(o, P, "fragment");
                    console.error("THREE.WebGLProgram: shader error: ", o.getError(), "35715", o.getProgramParameter(E, 35715), "gl.getProgramInfoLog", t, e, n)
                } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (l = !1);
                l && (this.diagnostics = {
                    runnable: r,
                    programLog: t,
                    vertexShader: {
                        log: e,
                        prefix: A
                    },
                    fragmentShader: {
                        log: n,
                        prefix: C
                    }
                })
            }
            let D, O;
            return o.deleteShader(R), o.deleteShader(P), this.getUniforms = function() {
                return void 0 === D && (D = new $i(o, E)), D
            }, this.getAttributes = function() {
                return void 0 === O && (O = function(t, e) {
                    const n = {},
                        r = t.getProgramParameter(e, 35721);
                    for (let i = 0; i < r; i++) {
                        const r = t.getActiveAttrib(e, i).name;
                        n[r] = t.getAttribLocation(e, r)
                    }
                    return n
                }(o, E)), O
            }, this.destroy = function() {
                r.releaseStatesOfProgram(this), o.deleteProgram(E), this.program = void 0
            }, this.name = n.shaderName, this.id = Zi++, this.cacheKey = e, this.usedTimes = 1, this.program = E, this.vertexShader = R, this.fragmentShader = P, this
        }

        function go(t, e, n, r, l, c, h) {
            const d = [],
                f = l.isWebGL2,
                y = l.logarithmicDepthBuffer,
                _ = l.floatVertexTextures,
                x = l.maxVertexUniforms,
                w = l.vertexTextures;
            let M = l.precision;
            const S = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                },
                T = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"];

            function E(map) {
                let t;
                return map && map.isTexture ? t = map.encoding : map && map.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = map.texture.encoding) : t = W, t
            }
            return {
                getParameters: function(c, d, T, A, object) {
                    const C = A.fog,
                        L = c.isMeshStandardMaterial ? A.environment : null,
                        k = (c.isMeshStandardMaterial ? n : e).get(c.envMap || L),
                        R = S[c.type],
                        P = object.isSkinnedMesh ? function(object) {
                            const t = object.skeleton.bones;
                            if (_) return 1024; {
                                const e = x,
                                    n = Math.floor((e - 20) / 4),
                                    r = Math.min(n, t.length);
                                return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."), 0) : r
                            }
                        }(object) : 0;
                    let D, O;
                    if (null !== c.precision && (M = l.getMaxPrecision(c.precision), M !== c.precision && console.warn("THREE.WebGLProgram.getParameters:", c.precision, "not supported, using", M, "instead.")), R) {
                        const t = Jn[R];
                        D = t.vertexShader, O = t.fragmentShader
                    } else D = c.vertexShader, O = c.fragmentShader;
                    const I = t.getRenderTarget();
                    return {
                        isWebGL2: f,
                        shaderID: R,
                        shaderName: c.type,
                        vertexShader: D,
                        fragmentShader: O,
                        defines: c.defines,
                        isRawShaderMaterial: !0 === c.isRawShaderMaterial,
                        glslVersion: c.glslVersion,
                        precision: M,
                        instancing: !0 === object.isInstancedMesh,
                        instancingColor: !0 === object.isInstancedMesh && null !== object.instanceColor,
                        supportsVertexTextures: w,
                        outputEncoding: null !== I ? E(I.texture) : t.outputEncoding,
                        map: !!c.map,
                        mapEncoding: E(c.map),
                        matcap: !!c.matcap,
                        matcapEncoding: E(c.matcap),
                        envMap: !!k,
                        envMapMode: k && k.mapping,
                        envMapEncoding: E(k),
                        envMapCubeUV: !!k && (k.mapping === m || k.mapping === v),
                        lightMap: !!c.lightMap,
                        lightMapEncoding: E(c.lightMap),
                        aoMap: !!c.aoMap,
                        emissiveMap: !!c.emissiveMap,
                        emissiveMapEncoding: E(c.emissiveMap),
                        bumpMap: !!c.bumpMap,
                        normalMap: !!c.normalMap,
                        objectSpaceNormalMap: 1 === c.normalMapType,
                        tangentSpaceNormalMap: 0 === c.normalMapType,
                        clearcoatMap: !!c.clearcoatMap,
                        clearcoatRoughnessMap: !!c.clearcoatRoughnessMap,
                        clearcoatNormalMap: !!c.clearcoatNormalMap,
                        displacementMap: !!c.displacementMap,
                        roughnessMap: !!c.roughnessMap,
                        metalnessMap: !!c.metalnessMap,
                        specularMap: !!c.specularMap,
                        specularIntensityMap: !!c.specularIntensityMap,
                        specularTintMap: !!c.specularTintMap,
                        specularTintMapEncoding: E(c.specularTintMap),
                        alphaMap: !!c.alphaMap,
                        gradientMap: !!c.gradientMap,
                        sheen: !!c.sheen,
                        transmission: !!c.transmission,
                        transmissionMap: !!c.transmissionMap,
                        thicknessMap: !!c.thicknessMap,
                        combine: c.combine,
                        vertexTangents: !!c.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
                        vertexColors: c.vertexColors,
                        vertexAlphas: !0 === c.vertexColors && !!object.geometry && !!object.geometry.attributes.color && 4 === object.geometry.attributes.color.itemSize,
                        vertexUvs: !!(c.map || c.bumpMap || c.normalMap || c.specularMap || c.alphaMap || c.emissiveMap || c.roughnessMap || c.metalnessMap || c.clearcoatMap || c.clearcoatRoughnessMap || c.clearcoatNormalMap || c.displacementMap || c.transmissionMap || c.thicknessMap || c.specularIntensityMap || c.specularTintMap),
                        uvsVertexOnly: !(c.map || c.bumpMap || c.normalMap || c.specularMap || c.alphaMap || c.emissiveMap || c.roughnessMap || c.metalnessMap || c.clearcoatNormalMap || c.transmission || c.transmissionMap || c.thicknessMap || c.specularIntensityMap || c.specularTintMap || !c.displacementMap),
                        fog: !!C,
                        useFog: c.fog,
                        fogExp2: C && C.isFogExp2,
                        flatShading: !!c.flatShading,
                        sizeAttenuation: c.sizeAttenuation,
                        logarithmicDepthBuffer: y,
                        skinning: !0 === object.isSkinnedMesh && P > 0,
                        maxBones: P,
                        useVertexTexture: _,
                        morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
                        morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
                        numDirLights: d.directional.length,
                        numPointLights: d.point.length,
                        numSpotLights: d.spot.length,
                        numRectAreaLights: d.rectArea.length,
                        numHemiLights: d.hemi.length,
                        numDirLightShadows: d.directionalShadowMap.length,
                        numPointLightShadows: d.pointShadowMap.length,
                        numSpotLightShadows: d.spotShadowMap.length,
                        numClippingPlanes: h.numPlanes,
                        numClipIntersection: h.numIntersection,
                        dithering: c.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && T.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: c.toneMapped ? t.toneMapping : 0,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: c.premultipliedAlpha,
                        alphaTest: c.alphaTest,
                        doubleSided: 2 === c.side,
                        flipSided: c.side === o,
                        depthPacking: void 0 !== c.depthPacking && c.depthPacking,
                        index0AttributeName: c.index0AttributeName,
                        extensionDerivatives: c.extensions && c.extensions.derivatives,
                        extensionFragDepth: c.extensions && c.extensions.fragDepth,
                        extensionDrawBuffers: c.extensions && c.extensions.drawBuffers,
                        extensionShaderTextureLOD: c.extensions && c.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: f || r.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: f || r.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: f || r.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: c.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                        for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                    if (!1 === e.isRawShaderMaterial) {
                        for (let i = 0; i < T.length; i++) n.push(e[T[i]]);
                        n.push(t.outputEncoding), n.push(t.gammaFactor)
                    }
                    return n.push(e.customProgramCacheKey), n.join()
                },
                getUniforms: function(t) {
                    const e = S[t.type];
                    let n;
                    if (e) {
                        const t = Jn[e];
                        n = Rn.clone(t.uniforms)
                    } else n = t.uniforms;
                    return n
                },
                acquireProgram: function(e, n) {
                    let r;
                    for (let p = 0, t = d.length; p < t; p++) {
                        const t = d[p];
                        if (t.cacheKey === n) {
                            r = t, ++r.usedTimes;
                            break
                        }
                    }
                    return void 0 === r && (r = new mo(t, n, e, c), d.push(r)), r
                },
                releaseProgram: function(t) {
                    if (0 == --t.usedTimes) {
                        const i = d.indexOf(t);
                        d[i] = d[d.length - 1], d.pop(), t.destroy()
                    }
                },
                programs: d
            }
        }

        function vo() {
            let t = new WeakMap;
            return {
                get: function(object) {
                    let map = t.get(object);
                    return void 0 === map && (map = {}, t.set(object, map)), map
                },
                remove: function(object) {
                    t.delete(object)
                },
                update: function(object, e, n) {
                    t.get(object)[e] = n
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }

        function yo(a, b) {
            return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
        }

        function _o(a, b) {
            return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
        }

        function xo(t) {
            const e = [];
            let n = 0;
            const r = [],
                o = [],
                l = [],
                c = {
                    id: -1
                };

            function h(object, r, o, l, h, d) {
                let f = e[n];
                const m = t.get(o);
                return void 0 === f ? (f = {
                    id: object.id,
                    object: object,
                    geometry: r,
                    material: o,
                    program: m.program || c,
                    groupOrder: l,
                    renderOrder: object.renderOrder,
                    z: h,
                    group: d
                }, e[n] = f) : (f.id = object.id, f.object = object, f.geometry = r, f.material = o, f.program = m.program || c, f.groupOrder = l, f.renderOrder = object.renderOrder, f.z = h, f.group = d), n++, f
            }
            return {
                opaque: r,
                transmissive: o,
                transparent: l,
                init: function() {
                    n = 0, r.length = 0, o.length = 0, l.length = 0
                },
                push: function(object, t, e, n, c, d) {
                    const f = h(object, t, e, n, c, d);
                    e.transmission > 0 ? o.push(f) : !0 === e.transparent ? l.push(f) : r.push(f)
                },
                unshift: function(object, t, e, n, c, d) {
                    const f = h(object, t, e, n, c, d);
                    e.transmission > 0 ? o.unshift(f) : !0 === e.transparent ? l.unshift(f) : r.unshift(f)
                },
                finish: function() {
                    for (let i = n, t = e.length; i < t; i++) {
                        const t = e[i];
                        if (null === t.id) break;
                        t.id = null, t.object = null, t.geometry = null, t.material = null, t.program = null, t.group = null
                    }
                },
                sort: function(t, e) {
                    r.length > 1 && r.sort(t || yo), o.length > 1 && o.sort(e || _o), l.length > 1 && l.sort(e || _o)
                }
            }
        }

        function bo(t) {
            let e = new WeakMap;
            return {
                get: function(n, r) {
                    let o;
                    return !1 === e.has(n) ? (o = new xo(t), e.set(n, [o])) : r >= e.get(n).length ? (o = new xo(t), e.get(n).push(o)) : o = e.get(n)[r], o
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }

        function wo() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    let n;
                    switch (e.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new Mt,
                                color: new We
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new Mt,
                                direction: new Mt,
                                color: new We,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new Mt,
                                color: new We,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new Mt,
                                skyColor: new We,
                                groundColor: new We
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new We,
                                position: new Mt,
                                halfWidth: new Mt,
                                halfHeight: new Mt
                            }
                    }
                    return t[e.id] = n, n
                }
            }
        }
        let Mo = 0;

        function So(t, e) {
            return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }

        function To(t, e) {
            const n = new wo,
                r = function() {
                    const t = {};
                    return {
                        get: function(e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new ht
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new ht,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }(),
                o = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                };
            for (let i = 0; i < 9; i++) o.probe.push(new Mt);
            const l = new Mt,
                c = new te,
                h = new te;
            return {
                setup: function(l) {
                    let c = 0,
                        g = 0,
                        b = 0;
                    for (let i = 0; i < 9; i++) o.probe[i].set(0, 0, 0);
                    let h = 0,
                        d = 0,
                        f = 0,
                        m = 0,
                        v = 0,
                        y = 0,
                        _ = 0,
                        x = 0;
                    l.sort(So);
                    for (let i = 0, t = l.length; i < t; i++) {
                        const t = l[i],
                            e = t.color,
                            w = t.intensity,
                            M = t.distance,
                            S = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                        if (t.isAmbientLight) c += e.r * w, g += e.g * w, b += e.b * w;
                        else if (t.isLightProbe)
                            for (let e = 0; e < 9; e++) o.probe[e].addScaledVector(t.sh.coefficients[e], w);
                        else if (t.isDirectionalLight) {
                            const e = n.get(t);
                            if (e.color.copy(t.color).multiplyScalar(t.intensity), t.castShadow) {
                                const shadow = t.shadow,
                                    e = r.get(t);
                                e.shadowBias = shadow.bias, e.shadowNormalBias = shadow.normalBias, e.shadowRadius = shadow.radius, e.shadowMapSize = shadow.mapSize, o.directionalShadow[h] = e, o.directionalShadowMap[h] = S, o.directionalShadowMatrix[h] = t.shadow.matrix, y++
                            }
                            o.directional[h] = e, h++
                        } else if (t.isSpotLight) {
                            const l = n.get(t);
                            if (l.position.setFromMatrixPosition(t.matrixWorld), l.color.copy(e).multiplyScalar(w), l.distance = M, l.coneCos = Math.cos(t.angle), l.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), l.decay = t.decay, t.castShadow) {
                                const shadow = t.shadow,
                                    e = r.get(t);
                                e.shadowBias = shadow.bias, e.shadowNormalBias = shadow.normalBias, e.shadowRadius = shadow.radius, e.shadowMapSize = shadow.mapSize, o.spotShadow[f] = e, o.spotShadowMap[f] = S, o.spotShadowMatrix[f] = t.shadow.matrix, x++
                            }
                            o.spot[f] = l, f++
                        } else if (t.isRectAreaLight) {
                            const r = n.get(t);
                            r.color.copy(e).multiplyScalar(w), r.halfWidth.set(.5 * t.width, 0, 0), r.halfHeight.set(0, .5 * t.height, 0), o.rectArea[m] = r, m++
                        } else if (t.isPointLight) {
                            const e = n.get(t);
                            if (e.color.copy(t.color).multiplyScalar(t.intensity), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
                                const shadow = t.shadow,
                                    e = r.get(t);
                                e.shadowBias = shadow.bias, e.shadowNormalBias = shadow.normalBias, e.shadowRadius = shadow.radius, e.shadowMapSize = shadow.mapSize, e.shadowCameraNear = shadow.camera.near, e.shadowCameraFar = shadow.camera.far, o.pointShadow[d] = e, o.pointShadowMap[d] = S, o.pointShadowMatrix[d] = t.shadow.matrix, _++
                            }
                            o.point[d] = e, d++
                        } else if (t.isHemisphereLight) {
                            const e = n.get(t);
                            e.skyColor.copy(t.color).multiplyScalar(w), e.groundColor.copy(t.groundColor).multiplyScalar(w), o.hemi[v] = e, v++
                        }
                    }
                    m > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (o.rectAreaLTC1 = Zn.LTC_FLOAT_1, o.rectAreaLTC2 = Zn.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (o.rectAreaLTC1 = Zn.LTC_HALF_1, o.rectAreaLTC2 = Zn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), o.ambient[0] = c, o.ambient[1] = g, o.ambient[2] = b;
                    const w = o.hash;
                    w.directionalLength === h && w.pointLength === d && w.spotLength === f && w.rectAreaLength === m && w.hemiLength === v && w.numDirectionalShadows === y && w.numPointShadows === _ && w.numSpotShadows === x || (o.directional.length = h, o.spot.length = f, o.rectArea.length = m, o.point.length = d, o.hemi.length = v, o.directionalShadow.length = y, o.directionalShadowMap.length = y, o.pointShadow.length = _, o.pointShadowMap.length = _, o.spotShadow.length = x, o.spotShadowMap.length = x, o.directionalShadowMatrix.length = y, o.pointShadowMatrix.length = _, o.spotShadowMatrix.length = x, w.directionalLength = h, w.pointLength = d, w.spotLength = f, w.rectAreaLength = m, w.hemiLength = v, w.numDirectionalShadows = y, w.numPointShadows = _, w.numSpotShadows = x, o.version = Mo++)
                },
                setupView: function(t, e) {
                    let n = 0,
                        r = 0,
                        d = 0,
                        f = 0,
                        m = 0;
                    const v = e.matrixWorldInverse;
                    for (let i = 0, e = t.length; i < e; i++) {
                        const e = t[i];
                        if (e.isDirectionalLight) {
                            const t = o.directional[n];
                            t.direction.setFromMatrixPosition(e.matrixWorld), l.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(l), t.direction.transformDirection(v), n++
                        } else if (e.isSpotLight) {
                            const t = o.spot[d];
                            t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(v), t.direction.setFromMatrixPosition(e.matrixWorld), l.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(l), t.direction.transformDirection(v), d++
                        } else if (e.isRectAreaLight) {
                            const t = o.rectArea[f];
                            t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(v), h.identity(), c.copy(e.matrixWorld), c.premultiply(v), h.extractRotation(c), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), t.halfWidth.applyMatrix4(h), t.halfHeight.applyMatrix4(h), f++
                        } else if (e.isPointLight) {
                            const t = o.point[r];
                            t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(v), r++
                        } else if (e.isHemisphereLight) {
                            const t = o.hemi[m];
                            t.direction.setFromMatrixPosition(e.matrixWorld), t.direction.transformDirection(v), t.direction.normalize(), m++
                        }
                    }
                },
                state: o
            }
        }

        function Eo(t, e) {
            const n = new To(t, e),
                r = [],
                o = [];
            return {
                init: function() {
                    r.length = 0, o.length = 0
                },
                state: {
                    lightsArray: r,
                    shadowsArray: o,
                    lights: n
                },
                setupLights: function() {
                    n.setup(r)
                },
                setupLightsView: function(t) {
                    n.setupView(r, t)
                },
                pushLight: function(t) {
                    r.push(t)
                },
                pushShadow: function(t) {
                    o.push(t)
                }
            }
        }

        function Ao(t, e) {
            let n = new WeakMap;
            return {
                get: function(r, o = 0) {
                    let l;
                    return !1 === n.has(r) ? (l = new Eo(t, e), n.set(r, [l])) : o >= n.get(r).length ? (l = new Eo(t, e), n.get(r).push(l)) : l = n.get(r)[o], l
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }
        class Co extends ze {
            constructor(t) {
                super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.depthPacking = source.depthPacking, this.map = source.map, this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this
            }
        }
        Co.prototype.isMeshDepthMaterial = !0;
        class Lo extends ze {
            constructor(t) {
                super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Mt, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.referencePosition.copy(source.referencePosition), this.nearDistance = source.nearDistance, this.farDistance = source.farDistance, this.map = source.map, this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this
            }
        }
        Lo.prototype.isMeshDistanceMaterial = !0;

        function ko(t, e, n) {
            let l = new Wn;
            const c = new ht,
                h = new ht,
                d = new _t,
                f = new Co({
                    depthPacking: 3201
                }),
                m = new Lo,
                v = {},
                y = n.maxTextureSize,
                _ = {
                    0: o,
                    1: r,
                    2: 2
                },
                x = new Pn({
                    defines: {
                        SAMPLE_RATE: 2 / 8,
                        HALF_SAMPLE_RATE: 1 / 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new ht
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                }),
                M = x.clone();
            M.defines.HORIZONTAL_PASS = 1;
            const S = new ln;
            S.setAttribute("position", new Ye(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const E = new En(S, x),
                A = this;

            function C(shadow, n) {
                const r = e.update(E);
                x.uniforms.shadow_pass.value = shadow.map.texture, x.uniforms.resolution.value = shadow.mapSize, x.uniforms.radius.value = shadow.radius, t.setRenderTarget(shadow.mapPass), t.clear(), t.renderBufferDirect(n, null, r, x, E, null), M.uniforms.shadow_pass.value = shadow.mapPass.texture, M.uniforms.resolution.value = shadow.mapSize, M.uniforms.radius.value = shadow.radius, t.setRenderTarget(shadow.map), t.clear(), t.renderBufferDirect(n, null, r, M, E, null)
            }

            function L(object, e, n, r, o, l, c) {
                let h = null;
                const d = !0 === r.isPointLight ? object.customDistanceMaterial : object.customDepthMaterial;
                if (h = void 0 !== d ? d : !0 === r.isPointLight ? m : f, t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                    const t = h.uuid,
                        e = n.uuid;
                    let r = v[t];
                    void 0 === r && (r = {}, v[t] = r);
                    let o = r[e];
                    void 0 === o && (o = h.clone(), r[e] = o), h = o
                }
                return h.visible = n.visible, h.wireframe = n.wireframe, h.side = 3 === c ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : _[n.side], h.clipShadows = n.clipShadows, h.clippingPlanes = n.clippingPlanes, h.clipIntersection = n.clipIntersection, h.wireframeLinewidth = n.wireframeLinewidth, h.linewidth = n.linewidth, !0 === r.isPointLight && !0 === h.isMeshDistanceMaterial && (h.referencePosition.setFromMatrixPosition(r.matrixWorld), h.nearDistance = o, h.farDistance = l), h
            }

            function k(object, n, r, o, c) {
                if (!1 === object.visible) return;
                if (object.layers.test(n.layers) && (object.isMesh || object.isLine || object.isPoints) && (object.castShadow || object.receiveShadow && 3 === c) && (!object.frustumCulled || l.intersectsObject(object))) {
                    object.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, object.matrixWorld);
                    const n = e.update(object),
                        l = object.material;
                    if (Array.isArray(l)) {
                        const e = n.groups;
                        for (let h = 0, d = e.length; h < d; h++) {
                            const d = e[h],
                                f = l[d.materialIndex];
                            if (f && f.visible) {
                                const e = L(object, 0, f, o, r.near, r.far, c);
                                t.renderBufferDirect(r, null, n, e, object, d)
                            }
                        }
                    } else if (l.visible) {
                        const e = L(object, 0, l, o, r.near, r.far, c);
                        t.renderBufferDirect(r, null, n, e, object, null)
                    }
                }
                const h = object.children;
                for (let i = 0, t = h.length; i < t; i++) k(h[i], n, r, o, c)
            }
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, n, r) {
                if (!1 === A.enabled) return;
                if (!1 === A.autoUpdate && !1 === A.needsUpdate) return;
                if (0 === e.length) return;
                const o = t.getRenderTarget(),
                    f = t.getActiveCubeFace(),
                    m = t.getActiveMipmapLevel(),
                    v = t.state;
                v.setBlending(0), v.buffers.color.setClear(1, 1, 1, 1), v.buffers.depth.setTest(!0), v.setScissorTest(!1);
                for (let i = 0, o = e.length; i < o; i++) {
                    const o = e[i],
                        shadow = o.shadow;
                    if (void 0 === shadow) {
                        console.warn("THREE.WebGLShadowMap:", o, "has no shadow.");
                        continue
                    }
                    if (!1 === shadow.autoUpdate && !1 === shadow.needsUpdate) continue;
                    c.copy(shadow.mapSize);
                    const f = shadow.getFrameExtents();
                    if (c.multiply(f), h.copy(shadow.mapSize), (c.x > y || c.y > y) && (c.x > y && (h.x = Math.floor(y / f.x), c.x = h.x * f.x, shadow.mapSize.x = h.x), c.y > y && (h.y = Math.floor(y / f.y), c.y = h.y * f.y, shadow.mapSize.y = h.y)), null === shadow.map && !shadow.isPointLightShadow && 3 === this.type) {
                        const t = {
                            minFilter: T,
                            magFilter: T,
                            format: O
                        };
                        shadow.map = new xt(c.x, c.y, t), shadow.map.texture.name = o.name + ".shadowMap", shadow.mapPass = new xt(c.x, c.y, t), shadow.camera.updateProjectionMatrix()
                    }
                    if (null === shadow.map) {
                        const t = {
                            minFilter: w,
                            magFilter: w,
                            format: O
                        };
                        shadow.map = new xt(c.x, c.y, t), shadow.map.texture.name = o.name + ".shadowMap", shadow.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(shadow.map), t.clear();
                    const m = shadow.getViewportCount();
                    for (let t = 0; t < m; t++) {
                        const e = shadow.getViewport(t);
                        d.set(h.x * e.x, h.y * e.y, h.x * e.z, h.y * e.w), v.viewport(d), shadow.updateMatrices(o, t), l = shadow.getFrustum(), k(n, r, shadow.camera, o, this.type)
                    }
                    shadow.isPointLightShadow || 3 !== this.type || C(shadow, r), shadow.needsUpdate = !1
                }
                A.needsUpdate = !1, t.setRenderTarget(o, f, m)
            }
        }

        function Ro(t, e, n) {
            const r = n.isWebGL2;
            const c = new function() {
                    let e = !1;
                    const n = new _t;
                    let r = null;
                    const o = new _t(0, 0, 0, 0);
                    return {
                        setMask: function(n) {
                            r === n || e || (t.colorMask(n, n, n, n), r = n)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e, g, b, a, r) {
                            !0 === r && (e *= a, g *= a, b *= a), n.set(e, g, b, a), !1 === o.equals(n) && (t.clearColor(e, g, b, a), o.copy(n))
                        },
                        reset: function() {
                            e = !1, r = null, o.set(-1, 0, 0, 0)
                        }
                    }
                },
                h = new function() {
                    let e = !1,
                        n = null,
                        r = null,
                        o = null;
                    return {
                        setTest: function(t) {
                            t ? X(2929) : $(2929)
                        },
                        setMask: function(r) {
                            n === r || e || (t.depthMask(r), n = r)
                        },
                        setFunc: function(e) {
                            if (r !== e) {
                                if (e) switch (e) {
                                    case 0:
                                        t.depthFunc(512);
                                        break;
                                    case 1:
                                        t.depthFunc(519);
                                        break;
                                    case 2:
                                        t.depthFunc(513);
                                        break;
                                    case 3:
                                        t.depthFunc(515);
                                        break;
                                    case 4:
                                        t.depthFunc(514);
                                        break;
                                    case 5:
                                        t.depthFunc(518);
                                        break;
                                    case 6:
                                        t.depthFunc(516);
                                        break;
                                    case 7:
                                        t.depthFunc(517);
                                        break;
                                    default:
                                        t.depthFunc(515)
                                } else t.depthFunc(515);
                                r = e
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            o !== e && (t.clearDepth(e), o = e)
                        },
                        reset: function() {
                            e = !1, n = null, r = null, o = null
                        }
                    }
                },
                d = new function() {
                    let e = !1,
                        n = null,
                        r = null,
                        o = null,
                        l = null,
                        c = null,
                        h = null,
                        d = null,
                        f = null;
                    return {
                        setTest: function(t) {
                            e || (t ? X(2960) : $(2960))
                        },
                        setMask: function(r) {
                            n === r || e || (t.stencilMask(r), n = r)
                        },
                        setFunc: function(e, n, c) {
                            r === e && o === n && l === c || (t.stencilFunc(e, n, c), r = e, o = n, l = c)
                        },
                        setOp: function(e, n, r) {
                            c === e && h === n && d === r || (t.stencilOp(e, n, r), c = e, h = n, d = r)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            f !== e && (t.clearStencil(e), f = e)
                        },
                        reset: function() {
                            e = !1, n = null, r = null, o = null, l = null, c = null, h = null, d = null, f = null
                        }
                    }
                };
            let f = {},
                m = null,
                v = {},
                y = null,
                _ = !1,
                x = null,
                w = null,
                M = null,
                S = null,
                T = null,
                E = null,
                A = null,
                C = !1,
                L = null,
                k = null,
                R = null,
                P = null,
                D = null;
            const O = t.getParameter(35661);
            let I = !1,
                N = 0;
            const F = t.getParameter(7938); - 1 !== F.indexOf("WebGL") ? (N = parseFloat(/^WebGL (\d)/.exec(F)[1]), I = N >= 1) : -1 !== F.indexOf("OpenGL ES") && (N = parseFloat(/^OpenGL ES (\d)/.exec(F)[1]), I = N >= 2);
            let z = null,
                B = {};
            const U = t.getParameter(3088),
                H = t.getParameter(2978),
                j = (new _t).fromArray(U),
                V = (new _t).fromArray(H);

            function G(e, n, r) {
                const data = new Uint8Array(4),
                    o = t.createTexture();
                t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                for (let i = 0; i < r; i++) t.texImage2D(n + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
                return o
            }
            const W = {};

            function X(e) {
                !0 !== f[e] && (t.enable(e), f[e] = !0)
            }

            function $(e) {
                !1 !== f[e] && (t.disable(e), f[e] = !1)
            }
            W[3553] = G(3553, 3553, 1), W[34067] = G(34067, 34069, 6), c.setClear(0, 0, 0, 1), h.setClear(1), d.setClear(0), X(2929), h.setFunc(3), K(!1), Q(1), X(2884), J(0);
            const Y = {
                [l]: 32774,
                101: 32778,
                102: 32779
            };
            if (r) Y[103] = 32775, Y[104] = 32776;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (Y[103] = t.MIN_EXT, Y[104] = t.MAX_EXT)
            }
            const Z = {
                200: 0,
                201: 1,
                202: 768,
                204: 770,
                210: 776,
                208: 774,
                206: 772,
                203: 769,
                205: 771,
                209: 775,
                207: 773
            };

            function J(e, n, r, o, c, h, d, f) {
                if (0 !== e) {
                    if (!1 === _ && (X(3042), _ = !0), 5 === e) c = c || n, h = h || r, d = d || o, n === w && c === T || (t.blendEquationSeparate(Y[n], Y[c]), w = n, T = c), r === M && o === S && h === E && d === A || (t.blendFuncSeparate(Z[r], Z[o], Z[h], Z[d]), M = r, S = o, E = h, A = d), x = e, C = null;
                    else if (e !== x || f !== C) {
                        if (w === l && T === l || (t.blendEquation(32774), w = l, T = l), f) switch (e) {
                            case 1:
                                t.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(1, 1);
                                break;
                            case 3:
                                t.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case 4:
                                t.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        } else switch (e) {
                            case 1:
                                t.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(770, 1);
                                break;
                            case 3:
                                t.blendFunc(0, 769);
                                break;
                            case 4:
                                t.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                        M = null, S = null, E = null, A = null, x = e, C = f
                    }
                } else !0 === _ && ($(3042), _ = !1)
            }

            function K(e) {
                L !== e && (e ? t.frontFace(2304) : t.frontFace(2305), L = e)
            }

            function Q(e) {
                0 !== e ? (X(2884), e !== k && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : $(2884), k = e
            }

            function tt(e, n, r) {
                e ? (X(32823), P === n && D === r || (t.polygonOffset(n, r), P = n, D = r)) : $(32823)
            }

            function et(e) {
                void 0 === e && (e = 33984 + O - 1), z !== e && (t.activeTexture(e), z = e)
            }
            return {
                buffers: {
                    color: c,
                    depth: h,
                    stencil: d
                },
                enable: X,
                disable: $,
                bindFramebuffer: function(e, n) {
                    return null === n && null !== m && (n = m), v[e] !== n && (t.bindFramebuffer(e, n), v[e] = n, r && (36009 === e && (v[36160] = n), 36160 === e && (v[36009] = n)), !0)
                },
                bindXRFramebuffer: function(e) {
                    e !== m && (t.bindFramebuffer(36160, e), m = e)
                },
                useProgram: function(e) {
                    return y !== e && (t.useProgram(e), y = e, !0)
                },
                setBlending: J,
                setMaterial: function(t, e) {
                    2 === t.side ? $(2884) : X(2884);
                    let n = t.side === o;
                    e && (n = !n), K(n), 1 === t.blending && !1 === t.transparent ? J(0) : J(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), h.setFunc(t.depthFunc), h.setTest(t.depthTest), h.setMask(t.depthWrite), c.setMask(t.colorWrite);
                    const r = t.stencilWrite;
                    d.setTest(r), r && (d.setMask(t.stencilWriteMask), d.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), d.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), tt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? X(32926) : $(32926)
                },
                setFlipSided: K,
                setCullFace: Q,
                setLineWidth: function(e) {
                    e !== R && (I && t.lineWidth(e), R = e)
                },
                setPolygonOffset: tt,
                setScissorTest: function(t) {
                    t ? X(3089) : $(3089)
                },
                activeTexture: et,
                bindTexture: function(e, n) {
                    null === z && et();
                    let r = B[z];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    }, B[z] = r), r.type === e && r.texture === n || (t.bindTexture(e, n || W[e]), r.type = e, r.texture = n)
                },
                unbindTexture: function() {
                    const e = B[z];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function() {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(e) {
                    !1 === j.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), j.copy(e))
                },
                viewport: function(e) {
                    !1 === V.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), V.copy(e))
                },
                reset: function() {
                    t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === r && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), f = {}, z = null, B = {}, m = null, v = {}, y = null, _ = !1, x = null, w = null, M = null, S = null, T = null, E = null, A = null, C = !1, L = null, k = null, R = null, P = null, D = null, j.set(0, 0, t.canvas.width, t.canvas.height), V.set(0, 0, t.canvas.width, t.canvas.height), c.reset(), h.reset(), d.reset()
                }
            }
        }

        function Po(t, e, n, r, o, l, c) {
            const h = o.isWebGL2,
                d = o.maxTextures,
                f = o.maxCubemapSize,
                m = o.maxTextureSize,
                v = o.maxSamples,
                A = new WeakMap;
            let I, z = !1;
            try {
                z = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (t) {}

            function B(t, e) {
                return z ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }

            function U(image, t, e, n) {
                let r = 1;
                if ((image.width > n || image.height > n) && (r = n / Math.max(image.width, image.height)), r < 1 || !0 === t) {
                    if ("undefined" != typeof HTMLImageElement && image instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && image instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && image instanceof ImageBitmap) {
                        const n = t ? ut : Math.floor,
                            o = n(r * image.width),
                            l = n(r * image.height);
                        void 0 === I && (I = B(o, l));
                        const canvas = e ? B(o, l) : I;
                        canvas.width = o, canvas.height = l;
                        return canvas.getContext("2d").drawImage(image, 0, 0, o, l), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + o + "x" + l + ")."), canvas
                    }
                    return "data" in image && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ")."), image
                }
                return image
            }

            function H(image) {
                return ct(image.width) && ct(image.height)
            }

            function j(t, e) {
                return t.generateMipmaps && e && t.minFilter !== w && t.minFilter !== T
            }

            function V(e, n, o, l, c = 1) {
                t.generateMipmap(e);
                r.get(n).__maxMipLevel = Math.log2(Math.max(o, l, c))
            }

            function G(n, r, o) {
                if (!1 === h) return r;
                if (null !== n) {
                    if (void 0 !== t[n]) return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let l = r;
                return 6403 === r && (5126 === o && (l = 33326), 5131 === o && (l = 33325), 5121 === o && (l = 33321)), 6407 === r && (5126 === o && (l = 34837), 5131 === o && (l = 34843), 5121 === o && (l = 32849)), 6408 === r && (5126 === o && (l = 34836), 5131 === o && (l = 34842), 5121 === o && (l = 32856)), 33325 !== l && 33326 !== l && 34842 !== l && 34836 !== l || e.get("EXT_color_buffer_float"), l
            }

            function W(t) {
                return t === w || t === M || t === S ? 9728 : 9729
            }

            function X(e) {
                const n = e.target;
                n.removeEventListener("dispose", X),
                    function(e) {
                        const n = r.get(e);
                        if (void 0 === n.__webglInit) return;
                        t.deleteTexture(n.__webglTexture), r.remove(e)
                    }(n), n.isVideoTexture && A.delete(n), c.memory.textures--
            }

            function $(e) {
                const n = e.target;
                n.removeEventListener("dispose", $),
                    function(e) {
                        const n = e.texture,
                            o = r.get(e),
                            l = r.get(n);
                        if (!e) return;
                        void 0 !== l.__webglTexture && (t.deleteTexture(l.__webglTexture), c.memory.textures--);
                        e.depthTexture && e.depthTexture.dispose();
                        if (e.isWebGLCubeRenderTarget)
                            for (let i = 0; i < 6; i++) t.deleteFramebuffer(o.__webglFramebuffer[i]), o.__webglDepthbuffer && t.deleteRenderbuffer(o.__webglDepthbuffer[i]);
                        else t.deleteFramebuffer(o.__webglFramebuffer), o.__webglDepthbuffer && t.deleteRenderbuffer(o.__webglDepthbuffer), o.__webglMultisampledFramebuffer && t.deleteFramebuffer(o.__webglMultisampledFramebuffer), o.__webglColorRenderbuffer && t.deleteRenderbuffer(o.__webglColorRenderbuffer), o.__webglDepthRenderbuffer && t.deleteRenderbuffer(o.__webglDepthRenderbuffer);
                        if (e.isWebGLMultipleRenderTargets)
                            for (let i = 0, e = n.length; i < e; i++) {
                                const e = r.get(n[i]);
                                e.__webglTexture && (t.deleteTexture(e.__webglTexture), c.memory.textures--), r.remove(n[i])
                            }
                        r.remove(n), r.remove(e)
                    }(n)
            }
            let Y = 0;

            function Z(t, slot) {
                const e = r.get(t);
                if (t.isVideoTexture && function(t) {
                        const e = c.render.frame;
                        A.get(t) !== e && (A.set(t, e), t.update())
                    }(t), t.version > 0 && e.__version !== t.version) {
                    const image = t.image;
                    if (void 0 === image) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                    else {
                        if (!1 !== image.complete) return void nt(e, t, slot);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.activeTexture(33984 + slot), n.bindTexture(3553, e.__webglTexture)
            }

            function J(e, slot) {
                const o = r.get(e);
                e.version > 0 && o.__version !== e.version ? function(e, r, slot) {
                    if (6 !== r.image.length) return;
                    et(e, r), n.activeTexture(33984 + slot), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
                    const o = r && (r.isCompressedTexture || r.image[0].isCompressedTexture),
                        c = r.image[0] && r.image[0].isDataTexture,
                        d = [];
                    for (let i = 0; i < 6; i++) d[i] = o || c ? c ? r.image[i].image : r.image[i] : U(r.image[i], !1, !0, f);
                    const image = d[0],
                        m = H(image) || h,
                        v = l.convert(r.format),
                        y = l.convert(r.type),
                        _ = G(r.internalFormat, v, y);
                    let x;
                    if (tt(34067, r, m), o) {
                        for (let i = 0; i < 6; i++) {
                            x = d[i].mipmaps;
                            for (let t = 0; t < x.length; t++) {
                                const e = x[t];
                                r.format !== O && r.format !== D ? null !== v ? n.compressedTexImage2D(34069 + i, t, _, e.width, e.height, 0, e.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + i, t, _, e.width, e.height, 0, v, y, e.data)
                            }
                        }
                        e.__maxMipLevel = x.length - 1
                    } else {
                        x = r.mipmaps;
                        for (let i = 0; i < 6; i++)
                            if (c) {
                                n.texImage2D(34069 + i, 0, _, d[i].width, d[i].height, 0, v, y, d[i].data);
                                for (let t = 0; t < x.length; t++) {
                                    const e = x[t].image[i].image;
                                    n.texImage2D(34069 + i, t + 1, _, e.width, e.height, 0, v, y, e.data)
                                }
                            } else {
                                n.texImage2D(34069 + i, 0, _, v, y, d[i]);
                                for (let t = 0; t < x.length; t++) {
                                    const e = x[t];
                                    n.texImage2D(34069 + i, t + 1, _, v, y, e.image[i])
                                }
                            }
                        e.__maxMipLevel = x.length
                    }
                    j(r, m) && V(34067, r, image.width, image.height);
                    e.__version = r.version, r.onUpdate && r.onUpdate(r)
                }(o, e, slot) : (n.activeTexture(33984 + slot), n.bindTexture(34067, o.__webglTexture))
            }
            const K = {
                    [y]: 10497,
                    [_]: 33071,
                    [x]: 33648
                },
                Q = {
                    [w]: 9728,
                    [M]: 9984,
                    [S]: 9986,
                    [T]: 9729,
                    1007: 9985,
                    [E]: 9987
                };

            function tt(n, l, c) {
                if (c ? (t.texParameteri(n, 10242, K[l.wrapS]), t.texParameteri(n, 10243, K[l.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, K[l.wrapR]), t.texParameteri(n, 10240, Q[l.magFilter]), t.texParameteri(n, 10241, Q[l.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), l.wrapS === _ && l.wrapT === _ || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, W(l.magFilter)), t.texParameteri(n, 10241, W(l.minFilter)), l.minFilter !== w && l.minFilter !== T && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                    const c = e.get("EXT_texture_filter_anisotropic");
                    if (l.type === k && !1 === e.has("OES_texture_float_linear")) return;
                    if (!1 === h && l.type === R && !1 === e.has("OES_texture_half_float_linear")) return;
                    (l.anisotropy > 1 || r.get(l).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(l.anisotropy, o.getMaxAnisotropy())), r.get(l).__currentAnisotropy = l.anisotropy)
                }
            }

            function et(e, n) {
                void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", X), e.__webglTexture = t.createTexture(), c.memory.textures++)
            }

            function nt(e, r, slot) {
                let o = 3553;
                r.isDataTexture2DArray && (o = 35866), r.isDataTexture3D && (o = 32879), et(e, r), n.activeTexture(33984 + slot), n.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
                const c = function(t) {
                        return !h && (t.wrapS !== _ || t.wrapT !== _ || t.minFilter !== w && t.minFilter !== T)
                    }(r) && !1 === H(r.image),
                    image = U(r.image, c, !1, m),
                    d = H(image) || h,
                    f = l.convert(r.format);
                let v, y = l.convert(r.type),
                    x = G(r.internalFormat, f, y);
                tt(o, r, d);
                const M = r.mipmaps;
                if (r.isDepthTexture) x = 6402, h ? x = r.type === k ? 36012 : r.type === L ? 33190 : r.type === P ? 35056 : 33189 : r.type === k && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === N && 6402 === x && r.type !== C && r.type !== L && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = C, y = l.convert(r.type)), r.format === F && 6402 === x && (x = 34041, r.type !== P && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = P, y = l.convert(r.type))), n.texImage2D(3553, 0, x, image.width, image.height, 0, f, y, null);
                else if (r.isDataTexture)
                    if (M.length > 0 && d) {
                        for (let i = 0, t = M.length; i < t; i++) v = M[i], n.texImage2D(3553, i, x, v.width, v.height, 0, f, y, v.data);
                        r.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
                    } else n.texImage2D(3553, 0, x, image.width, image.height, 0, f, y, image.data), e.__maxMipLevel = 0;
                else if (r.isCompressedTexture) {
                    for (let i = 0, t = M.length; i < t; i++) v = M[i], r.format !== O && r.format !== D ? null !== f ? n.compressedTexImage2D(3553, i, x, v.width, v.height, 0, v.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, i, x, v.width, v.height, 0, f, y, v.data);
                    e.__maxMipLevel = M.length - 1
                } else if (r.isDataTexture2DArray) n.texImage3D(35866, 0, x, image.width, image.height, image.depth, 0, f, y, image.data), e.__maxMipLevel = 0;
                else if (r.isDataTexture3D) n.texImage3D(32879, 0, x, image.width, image.height, image.depth, 0, f, y, image.data), e.__maxMipLevel = 0;
                else if (M.length > 0 && d) {
                    for (let i = 0, t = M.length; i < t; i++) v = M[i], n.texImage2D(3553, i, x, f, y, v);
                    r.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
                } else n.texImage2D(3553, 0, x, f, y, image), e.__maxMipLevel = 0;
                j(r, d) && V(o, r, image.width, image.height), e.__version = r.version, r.onUpdate && r.onUpdate(r)
            }

            function it(e, o, c, h, d) {
                const f = l.convert(c.format),
                    m = l.convert(c.type),
                    v = G(c.internalFormat, f, m);
                32879 === d || 35866 === d ? n.texImage3D(d, 0, v, o.width, o.height, o.depth, 0, f, m, null) : n.texImage2D(d, 0, v, o.width, o.height, 0, f, m, null), n.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, h, d, r.get(c).__webglTexture, 0), n.bindFramebuffer(36160, null)
            }

            function ot(e, n, r) {
                if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                    let o = 33189;
                    if (r) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (e.type === k ? o = 36012 : e.type === L && (o = 33190));
                        const r = st(n);
                        t.renderbufferStorageMultisample(36161, r, o, n.width, n.height)
                    } else t.renderbufferStorage(36161, o, n.width, n.height);
                    t.framebufferRenderbuffer(36160, 36096, 36161, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    if (r) {
                        const e = st(n);
                        t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                    } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                    t.framebufferRenderbuffer(36160, 33306, 36161, e)
                } else {
                    const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                        o = l.convert(e.format),
                        c = l.convert(e.type),
                        h = G(e.internalFormat, o, c);
                    if (r) {
                        const e = st(n);
                        t.renderbufferStorageMultisample(36161, e, h, n.width, n.height)
                    } else t.renderbufferStorage(36161, h, n.width, n.height)
                }
                t.bindRenderbuffer(36161, null)
            }

            function at(e) {
                const o = r.get(e),
                    l = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture) {
                    if (l) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function(e, o) {
                        if (o && o.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(36160, e), !o.depthTexture || !o.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        r.get(o.depthTexture).__webglTexture && o.depthTexture.image.width === o.width && o.depthTexture.image.height === o.height || (o.depthTexture.image.width = o.width, o.depthTexture.image.height = o.height, o.depthTexture.needsUpdate = !0), Z(o.depthTexture, 0);
                        const l = r.get(o.depthTexture).__webglTexture;
                        if (o.depthTexture.format === N) t.framebufferTexture2D(36160, 36096, 3553, l, 0);
                        else {
                            if (o.depthTexture.format !== F) throw new Error("Unknown depthTexture format");
                            t.framebufferTexture2D(36160, 33306, 3553, l, 0)
                        }
                    }(o.__webglFramebuffer, e)
                } else if (l) {
                    o.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, o.__webglFramebuffer[i]), o.__webglDepthbuffer[i] = t.createRenderbuffer(), ot(o.__webglDepthbuffer[i], e, !1)
                } else n.bindFramebuffer(36160, o.__webglFramebuffer), o.__webglDepthbuffer = t.createRenderbuffer(), ot(o.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(36160, null)
            }

            function st(t) {
                return h && t.isWebGLMultisampleRenderTarget ? Math.min(v, t.samples) : 0
            }
            let lt = !1,
                ht = !1;
            this.allocateTextureUnit = function() {
                const t = Y;
                return t >= d && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + d), Y += 1, t
            }, this.resetTextureUnits = function() {
                Y = 0
            }, this.setTexture2D = Z, this.setTexture2DArray = function(t, slot) {
                const e = r.get(t);
                t.version > 0 && e.__version !== t.version ? nt(e, t, slot) : (n.activeTexture(33984 + slot), n.bindTexture(35866, e.__webglTexture))
            }, this.setTexture3D = function(t, slot) {
                const e = r.get(t);
                t.version > 0 && e.__version !== t.version ? nt(e, t, slot) : (n.activeTexture(33984 + slot), n.bindTexture(32879, e.__webglTexture))
            }, this.setTextureCube = J, this.setupRenderTarget = function(e) {
                const d = e.texture,
                    f = r.get(e),
                    m = r.get(d);
                e.addEventListener("dispose", $), !0 !== e.isWebGLMultipleRenderTargets && (m.__webglTexture = t.createTexture(), m.__version = d.version, c.memory.textures++);
                const v = !0 === e.isWebGLCubeRenderTarget,
                    y = !0 === e.isWebGLMultipleRenderTargets,
                    _ = !0 === e.isWebGLMultisampleRenderTarget,
                    x = d.isDataTexture3D || d.isDataTexture2DArray,
                    w = H(e) || h;
                if (!h || d.format !== D || d.type !== k && d.type !== R || (d.format = O, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), v) {
                    f.__webglFramebuffer = [];
                    for (let i = 0; i < 6; i++) f.__webglFramebuffer[i] = t.createFramebuffer()
                } else if (f.__webglFramebuffer = t.createFramebuffer(), y)
                    if (o.drawBuffers) {
                        const n = e.texture;
                        for (let i = 0, e = n.length; i < e; i++) {
                            const e = r.get(n[i]);
                            void 0 === e.__webglTexture && (e.__webglTexture = t.createTexture(), c.memory.textures++)
                        }
                    } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                else if (_)
                    if (h) {
                        f.__webglMultisampledFramebuffer = t.createFramebuffer(), f.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, f.__webglColorRenderbuffer);
                        const r = l.convert(d.format),
                            o = l.convert(d.type),
                            c = G(d.internalFormat, r, o),
                            h = st(e);
                        t.renderbufferStorageMultisample(36161, h, c, e.width, e.height), n.bindFramebuffer(36160, f.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, f.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (f.__webglDepthRenderbuffer = t.createRenderbuffer(), ot(f.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                if (v) {
                    n.bindTexture(34067, m.__webglTexture), tt(34067, d, w);
                    for (let i = 0; i < 6; i++) it(f.__webglFramebuffer[i], e, d, 36064, 34069 + i);
                    j(d, w) && V(34067, d, e.width, e.height), n.bindTexture(34067, null)
                } else if (y) {
                    const t = e.texture;
                    for (let i = 0, o = t.length; i < o; i++) {
                        const o = t[i],
                            l = r.get(o);
                        n.bindTexture(3553, l.__webglTexture), tt(3553, o, w), it(f.__webglFramebuffer, e, o, 36064 + i, 3553), j(o, w) && V(3553, o, e.width, e.height)
                    }
                    n.bindTexture(3553, null)
                } else {
                    let t = 3553;
                    if (x)
                        if (h) {
                            t = d.isDataTexture3D ? 32879 : 35866
                        } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                    n.bindTexture(t, m.__webglTexture), tt(t, d, w), it(f.__webglFramebuffer, e, d, 36064, t), j(d, w) && V(t, d, e.width, e.height, e.depth), n.bindTexture(t, null)
                }
                e.depthBuffer && at(e)
            }, this.updateRenderTargetMipmap = function(t) {
                const e = H(t) || h,
                    o = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                for (let i = 0, l = o.length; i < l; i++) {
                    const l = o[i];
                    if (j(l, e)) {
                        const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                            o = r.get(l).__webglTexture;
                        n.bindTexture(e, o), V(e, l, t.width, t.height), n.bindTexture(e, null)
                    }
                }
            }, this.updateMultisampleRenderTarget = function(e) {
                if (e.isWebGLMultisampleRenderTarget)
                    if (h) {
                        const o = e.width,
                            l = e.height;
                        let mask = 16384;
                        e.depthBuffer && (mask |= 256), e.stencilBuffer && (mask |= 1024);
                        const c = r.get(e);
                        n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, c.__webglFramebuffer), t.blitFramebuffer(0, 0, o, l, 0, 0, o, l, mask, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }, this.safeSetTexture2D = function(t, slot) {
                t && t.isWebGLRenderTarget && (!1 === lt && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), lt = !0), t = t.texture), Z(t, slot)
            }, this.safeSetTextureCube = function(t, slot) {
                t && t.isWebGLCubeRenderTarget && (!1 === ht && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), ht = !0), t = t.texture), J(t, slot)
            }
        }

        function Do(t, e, n) {
            const r = n.isWebGL2;
            return {
                convert: function(p) {
                    let t;
                    if (p === A) return 5121;
                    if (1017 === p) return 32819;
                    if (1018 === p) return 32820;
                    if (1019 === p) return 33635;
                    if (1010 === p) return 5120;
                    if (1011 === p) return 5122;
                    if (p === C) return 5123;
                    if (1013 === p) return 5124;
                    if (p === L) return 5125;
                    if (p === k) return 5126;
                    if (p === R) return r ? 5131 : (t = e.get("OES_texture_half_float"), null !== t ? t.HALF_FLOAT_OES : null);
                    if (1021 === p) return 6406;
                    if (p === D) return 6407;
                    if (p === O) return 6408;
                    if (1024 === p) return 6409;
                    if (1025 === p) return 6410;
                    if (p === N) return 6402;
                    if (p === F) return 34041;
                    if (1028 === p) return 6403;
                    if (1029 === p) return 36244;
                    if (1030 === p) return 33319;
                    if (1031 === p) return 33320;
                    if (1032 === p) return 36248;
                    if (1033 === p) return 36249;
                    if (33776 === p || 33777 === p || 33778 === p || 33779 === p) {
                        if (t = e.get("WEBGL_compressed_texture_s3tc"), null === t) return null;
                        if (33776 === p) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === p) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === p) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === p) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (35840 === p || 35841 === p || 35842 === p || 35843 === p) {
                        if (t = e.get("WEBGL_compressed_texture_pvrtc"), null === t) return null;
                        if (35840 === p) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === p) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === p) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === p) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === p) return t = e.get("WEBGL_compressed_texture_etc1"), null !== t ? t.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if ((37492 === p || 37496 === p) && (t = e.get("WEBGL_compressed_texture_etc"), null !== t)) {
                        if (37492 === p) return t.COMPRESSED_RGB8_ETC2;
                        if (37496 === p) return t.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    return 37808 === p || 37809 === p || 37810 === p || 37811 === p || 37812 === p || 37813 === p || 37814 === p || 37815 === p || 37816 === p || 37817 === p || 37818 === p || 37819 === p || 37820 === p || 37821 === p || 37840 === p || 37841 === p || 37842 === p || 37843 === p || 37844 === p || 37845 === p || 37846 === p || 37847 === p || 37848 === p || 37849 === p || 37850 === p || 37851 === p || 37852 === p || 37853 === p ? (t = e.get("WEBGL_compressed_texture_astc"), null !== t ? p : null) : 36492 === p ? (t = e.get("EXT_texture_compression_bptc"), null !== t ? p : null) : p === P ? r ? 34042 : (t = e.get("WEBGL_depth_texture"), null !== t ? t.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                }
            }
        }
        class Oo extends On {
            constructor(t = []) {
                super(), this.cameras = t
            }
        }
        Oo.prototype.isArrayCamera = !0;
        class Io extends Te {
            constructor() {
                super(), this.type = "Group"
            }
        }
        Io.prototype.isGroup = !0;
        const No = {
            type: "move"
        };
        class Fo {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new Io, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                    pinching: !1
                }), this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new Io, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Mt, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Mt), this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new Io, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Mt, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Mt), this._grip
            }
            dispatchEvent(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
            }
            disconnect(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            }
            update(t, e, n) {
                let r = null,
                    o = null,
                    l = null;
                const c = this._targetRay,
                    h = this._grip,
                    d = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState)
                    if (null !== c && (r = e.getPose(t.targetRaySpace, n), null !== r && (c.matrix.fromArray(r.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), r.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(r.linearVelocity)) : c.hasLinearVelocity = !1, r.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(r.angularVelocity)) : c.hasAngularVelocity = !1, this.dispatchEvent(No))), d && t.hand) {
                        l = !0;
                        for (const r of t.hand.values()) {
                            const t = e.getJointPose(r, n);
                            if (void 0 === d.joints[r.jointName]) {
                                const t = new Io;
                                t.matrixAutoUpdate = !1, t.visible = !1, d.joints[r.jointName] = t, d.add(t)
                            }
                            const o = d.joints[r.jointName];
                            null !== t && (o.matrix.fromArray(t.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.jointRadius = t.radius), o.visible = null !== t
                        }
                        const r = d.joints["index-finger-tip"],
                            o = d.joints["thumb-tip"],
                            c = r.position.distanceTo(o.position),
                            h = .02,
                            f = .005;
                        d.inputState.pinching && c > h + f ? (d.inputState.pinching = !1, this.dispatchEvent({
                            type: "pinchend",
                            handedness: t.handedness,
                            target: this
                        })) : !d.inputState.pinching && c <= h - f && (d.inputState.pinching = !0, this.dispatchEvent({
                            type: "pinchstart",
                            handedness: t.handedness,
                            target: this
                        }))
                    } else null !== h && t.gripSpace && (o = e.getPose(t.gripSpace, n), null !== o && (h.matrix.fromArray(o.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), o.linearVelocity ? (h.hasLinearVelocity = !0, h.linearVelocity.copy(o.linearVelocity)) : h.hasLinearVelocity = !1, o.angularVelocity ? (h.hasAngularVelocity = !0, h.angularVelocity.copy(o.angularVelocity)) : h.hasAngularVelocity = !1));
                return null !== c && (c.visible = null !== r), null !== h && (h.visible = null !== o), null !== d && (d.visible = null !== l), this
            }
        }
        class zo extends tt {
            constructor(t, e) {
                super();
                const n = this,
                    r = t.state;
                let o = null,
                    l = 1,
                    c = null,
                    h = "local-floor",
                    d = null,
                    f = null,
                    m = null,
                    v = null,
                    y = null;
                const _ = [],
                    x = new Map,
                    w = new On;
                w.layers.enable(1), w.viewport = new _t;
                const M = new On;
                M.layers.enable(2), M.viewport = new _t;
                const S = [w, M],
                    T = new Oo;
                T.layers.enable(1), T.layers.enable(2);
                let E = null,
                    A = null;

                function C(t) {
                    const e = x.get(t.inputSource);
                    e && e.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    })
                }

                function L() {
                    x.forEach((function(t, e) {
                        t.disconnect(e)
                    })), x.clear(), E = null, A = null, r.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), I.stop(), n.isPresenting = !1, n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function k(t) {
                    const e = o.inputSources;
                    for (let i = 0; i < _.length; i++) x.set(e[i], _[i]);
                    for (let i = 0; i < t.removed.length; i++) {
                        const e = t.removed[i],
                            n = x.get(e);
                        n && (n.dispatchEvent({
                            type: "disconnected",
                            data: e
                        }), x.delete(e))
                    }
                    for (let i = 0; i < t.added.length; i++) {
                        const e = t.added[i],
                            n = x.get(e);
                        n && n.dispatchEvent({
                            type: "connected",
                            data: e
                        })
                    }
                }
                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                    let e = _[t];
                    return void 0 === e && (e = new Fo, _[t] = e), e.getTargetRaySpace()
                }, this.getControllerGrip = function(t) {
                    let e = _[t];
                    return void 0 === e && (e = new Fo, _[t] = e), e.getGripSpace()
                }, this.getHand = function(t) {
                    let e = _[t];
                    return void 0 === e && (e = new Fo, _[t] = e), e.getHandSpace()
                }, this.setFramebufferScaleFactor = function(t) {
                    l = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function(t) {
                    h = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function() {
                    return c
                }, this.getSession = function() {
                    return o
                }, this.setSession = async function(t) {
                    if (o = t, null !== o) {
                        o.addEventListener("select", C), o.addEventListener("selectstart", C), o.addEventListener("selectend", C), o.addEventListener("squeeze", C), o.addEventListener("squeezestart", C), o.addEventListener("squeezeend", C), o.addEventListener("end", L), o.addEventListener("inputsourceschange", k);
                        const t = e.getContextAttributes();
                        if (!0 !== t.xrCompatible && await e.makeXRCompatible(), void 0 === o.renderState.layers) {
                            const n = {
                                antialias: t.antialias,
                                alpha: t.alpha,
                                depth: t.depth,
                                stencil: t.stencil,
                                framebufferScaleFactor: l
                            };
                            y = new XRWebGLLayer(o, e, n), o.updateRenderState({
                                baseLayer: y
                            })
                        } else {
                            let n = 0;
                            if (t.antialias) {
                                const n = {
                                    antialias: !0,
                                    alpha: t.alpha,
                                    depth: t.depth,
                                    stencil: t.stencil,
                                    framebufferScaleFactor: l
                                };
                                y = new XRWebGLLayer(o, e, n), o.updateRenderState({
                                    layers: [y]
                                })
                            } else {
                                t.depth && (n = t.stencil ? 34041 : 6402);
                                const r = {
                                    colorFormat: t.alpha ? 6408 : 6407,
                                    depthFormat: n,
                                    scaleFactor: l
                                };
                                f = new XRWebGLBinding(o, e), v = f.createProjectionLayer(r), m = e.createFramebuffer(), o.updateRenderState({
                                    layers: [v]
                                })
                            }
                        }
                        c = await o.requestReferenceSpace(h), I.setContext(o), I.start(), n.isPresenting = !0, n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                };
                const R = new Mt,
                    P = new Mt;

                function D(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }
                this.updateCamera = function(t) {
                    if (null === o) return;
                    T.near = M.near = w.near = t.near, T.far = M.far = w.far = t.far, E === T.near && A === T.far || (o.updateRenderState({
                        depthNear: T.near,
                        depthFar: T.far
                    }), E = T.near, A = T.far);
                    const e = t.parent,
                        n = T.cameras;
                    D(T, e);
                    for (let i = 0; i < n.length; i++) D(n[i], e);
                    T.matrixWorld.decompose(T.position, T.quaternion, T.scale), t.position.copy(T.position), t.quaternion.copy(T.quaternion), t.scale.copy(T.scale), t.matrix.copy(T.matrix), t.matrixWorld.copy(T.matrixWorld);
                    const r = t.children;
                    for (let i = 0, t = r.length; i < t; i++) r[i].updateMatrixWorld(!0);
                    2 === n.length ? function(t, e, n) {
                        R.setFromMatrixPosition(e.matrixWorld), P.setFromMatrixPosition(n.matrixWorld);
                        const r = R.distanceTo(P),
                            o = e.projectionMatrix.elements,
                            l = n.projectionMatrix.elements,
                            c = o[14] / (o[10] - 1),
                            h = o[14] / (o[10] + 1),
                            d = (o[9] + 1) / o[5],
                            f = (o[9] - 1) / o[5],
                            m = (o[8] - 1) / o[0],
                            v = (l[8] + 1) / l[0],
                            y = c * m,
                            _ = c * v,
                            x = r / (-m + v),
                            w = x * -m;
                        e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(w), t.translateZ(x), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                        const M = c + x,
                            S = h + x,
                            T = y - w,
                            E = _ + (r - w),
                            A = d * h / S * M,
                            C = f * h / S * M;
                        t.projectionMatrix.makePerspective(T, E, A, C, M, S)
                    }(T, w, M) : T.projectionMatrix.copy(w.projectionMatrix)
                }, this.getCamera = function() {
                    return T
                }, this.getFoveation = function() {
                    return null !== v ? v.fixedFoveation : null !== y ? y.fixedFoveation : void 0
                }, this.setFoveation = function(t) {
                    null !== v && (v.fixedFoveation = t), null !== y && void 0 !== y.fixedFoveation && (y.fixedFoveation = t)
                };
                let O = null;
                const I = new qn;
                I.setAnimationLoop((function(time, t) {
                    if (d = t.getViewerPose(c), null !== d) {
                        const t = d.views;
                        null !== y && r.bindXRFramebuffer(y.framebuffer);
                        let n = !1;
                        t.length !== T.cameras.length && (T.cameras.length = 0, n = !0);
                        for (let i = 0; i < t.length; i++) {
                            const view = t[i];
                            let o = null;
                            if (null !== y) o = y.getViewport(view);
                            else {
                                const t = f.getViewSubImage(v, view);
                                r.bindXRFramebuffer(m), void 0 !== t.depthStencilTexture && e.framebufferTexture2D(36160, 36096, 3553, t.depthStencilTexture, 0), e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0), o = t.viewport
                            }
                            const l = S[i];
                            l.matrix.fromArray(view.transform.matrix), l.projectionMatrix.fromArray(view.projectionMatrix), l.viewport.set(o.x, o.y, o.width, o.height), 0 === i && T.matrix.copy(l.matrix), !0 === n && T.cameras.push(l)
                        }
                    }
                    const n = o.inputSources;
                    for (let i = 0; i < _.length; i++) {
                        const e = _[i],
                            r = n[i];
                        e.update(r, t, c)
                    }
                    O && O(time, t)
                })), this.setAnimationLoop = function(t) {
                    O = t
                }, this.dispose = function() {}
            }
        }

        function Bo(t) {
            function e(e, n) {
                e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
                const r = t.get(n).envMap;
                if (r) {
                    e.envMap.value = r, e.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio;
                    const o = t.get(r).__maxMipLevel;
                    void 0 !== o && (e.maxMipLevel.value = o)
                }
                let o, l;
                n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? o = n.map : n.specularMap ? o = n.specularMap : n.displacementMap ? o = n.displacementMap : n.normalMap ? o = n.normalMap : n.bumpMap ? o = n.bumpMap : n.roughnessMap ? o = n.roughnessMap : n.metalnessMap ? o = n.metalnessMap : n.alphaMap ? o = n.alphaMap : n.emissiveMap ? o = n.emissiveMap : n.clearcoatMap ? o = n.clearcoatMap : n.clearcoatNormalMap ? o = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? o = n.clearcoatRoughnessMap : n.specularIntensityMap ? o = n.specularIntensityMap : n.specularTintMap && (o = n.specularTintMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), e.uvTransform.value.copy(o.matrix)), n.aoMap ? l = n.aoMap : n.lightMap && (l = n.lightMap), void 0 !== l && (l.isWebGLRenderTarget && (l = l.texture), !0 === l.matrixAutoUpdate && l.updateMatrix(), e.uv2Transform.value.copy(l.matrix))
            }

            function n(e, n) {
                e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === o && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === o && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias);
                t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
            }
            return {
                refreshFogUniforms: function(t, e) {
                    t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                },
                refreshMaterialUniforms: function(t, r, l, c, h) {
                    r.isMeshBasicMaterial ? e(t, r) : r.isMeshLambertMaterial ? (e(t, r), function(t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(t, r)) : r.isMeshToonMaterial ? (e(t, r), function(t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap);
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === o && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === o && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, r)) : r.isMeshPhongMaterial ? (e(t, r), function(t, e) {
                        t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === o && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === o && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, r)) : r.isMeshStandardMaterial ? (e(t, r), r.isMeshPhysicalMaterial ? function(t, e, r) {
                        n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                        e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                        e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                        e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === o && t.clearcoatNormalScale.value.negate());
                        t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap);
                        e.transmission > 0 && (t.transmissionSamplerMap.value = r.texture, t.transmissionSamplerSize.value.set(r.width, r.height));
                        t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap);
                        t.attenuationDistance.value = e.attenuationDistance, t.attenuationTint.value.copy(e.attenuationTint), t.specularIntensity.value = e.specularIntensity, t.specularTint.value.copy(e.specularTint), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap);
                        e.specularTintMap && (t.specularTintMap.value = e.specularTintMap)
                    }(t, r, h) : n(t, r)) : r.isMeshMatcapMaterial ? (e(t, r), function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === o && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === o && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, r)) : r.isMeshDepthMaterial ? (e(t, r), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, r)) : r.isMeshDistanceMaterial ? (e(t, r), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                        t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(t, r)) : r.isMeshNormalMaterial ? (e(t, r), function(t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === o && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === o && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, r)) : r.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                    }(t, r), r.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(t, r)) : r.isPointsMaterial ? function(t, e, n, r) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * r, e.map && (t.map.value = e.map);
                        e.alphaMap && (t.alphaMap.value = e.alphaMap);
                        let o;
                        e.map ? o = e.map : e.alphaMap && (o = e.alphaMap);
                        void 0 !== o && (!0 === o.matrixAutoUpdate && o.updateMatrix(), t.uvTransform.value.copy(o.matrix))
                    }(t, r, l, c) : r.isSpriteMaterial ? function(t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                        e.alphaMap && (t.alphaMap.value = e.alphaMap);
                        let n;
                        e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                        void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                    }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                }
            }
        }

        function Uo(t = {}) {
            const e = void 0 !== t.canvas ? t.canvas : function() {
                    const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    return canvas.style.display = "block", canvas
                }(),
                n = void 0 !== t.context ? t.context : null,
                l = void 0 !== t.alpha && t.alpha,
                c = void 0 === t.depth || t.depth,
                h = void 0 === t.stencil || t.stencil,
                d = void 0 !== t.antialias && t.antialias,
                f = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                m = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                v = void 0 !== t.powerPreference ? t.powerPreference : "default",
                y = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
            let x = null,
                M = null;
            const S = [],
                T = [];
            this.domElement = e, this.debug = {
                checkShaderErrors: !0
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = W, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
            const C = this;
            let L = !1,
                P = 0,
                D = 0,
                I = null,
                N = -1,
                F = null;
            const z = new _t,
                B = new _t;
            let U = null,
                H = e.width,
                j = e.height,
                V = 1,
                G = null,
                X = null;
            const $ = new _t(0, 0, H, j),
                Y = new _t(0, 0, H, j);
            let Z = !1;
            const J = [],
                K = new Wn;
            let Q = !1,
                tt = !1,
                et = null;
            const nt = new te,
                it = new Mt,
                ot = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };

            function at() {
                return null === I ? V : 1
            }
            let st, lt, ct, ut, ht, pt, ft, mt, gt, vt, yt, wt, St, Tt, Et, At, Ct, Lt, kt, Rt, Pt, Dt, Ot, It = n;

            function Nt(t, n) {
                for (let i = 0; i < t.length; i++) {
                    const r = t[i],
                        o = e.getContext(r, n);
                    if (null !== o) return o
                }
                return null
            }
            try {
                const t = {
                    alpha: l,
                    depth: c,
                    stencil: h,
                    antialias: d,
                    premultipliedAlpha: f,
                    preserveDrawingBuffer: m,
                    powerPreference: v,
                    failIfMajorPerformanceCaveat: y
                };
                if (e.addEventListener("webglcontextlost", Bt, !1), e.addEventListener("webglcontextrestored", Ut, !1), null === It) {
                    const e = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === C.isWebGL1Renderer && e.shift(), It = Nt(e, t), null === It) throw Nt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                void 0 === It.getShaderPrecisionFormat && (It.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (t) {
                throw console.error("THREE.WebGLRenderer: " + t.message), t
            }

            function Ft() {
                st = new Nr(It), lt = new nr(It, st, t), st.init(lt), Dt = new Do(It, st, lt), ct = new Ro(It, st, lt), J[0] = 1029, ut = new Br(It), ht = new vo, pt = new Po(It, st, ct, ht, lt, Dt, ut), ft = new ir(C), mt = new Ir(C), gt = new Xn(It, lt), Ot = new Qn(It, st, gt, lt), vt = new Fr(It, gt, ut, Ot), yt = new Vr(It, vt, gt, ut), kt = new jr(It), At = new rr(ht), wt = new go(C, ft, mt, st, lt, Ot, At), St = new Bo(ht), Tt = new bo(ht), Et = new Ao(st, lt), Lt = new Kn(C, ft, ct, yt, f), Ct = new ko(C, yt, lt), Rt = new er(It, st, ut, lt), Pt = new zr(It, st, ut, lt), ut.programs = wt.programs, C.capabilities = lt, C.extensions = st, C.properties = ht, C.renderLists = Tt, C.shadowMap = Ct, C.state = ct, C.info = ut
            }
            Ft();
            const zt = new zo(C, It);

            function Bt(t) {
                t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), L = !0
            }

            function Ut() {
                console.log("THREE.WebGLRenderer: Context Restored."), L = !1;
                const t = ut.autoReset,
                    e = Ct.enabled,
                    n = Ct.autoUpdate,
                    r = Ct.needsUpdate,
                    o = Ct.type;
                Ft(), ut.autoReset = t, Ct.enabled = e, Ct.autoUpdate = n, Ct.needsUpdate = r, Ct.type = o
            }

            function Ht(t) {
                const e = t.target;
                e.removeEventListener("dispose", Ht),
                    function(t) {
                        (function(t) {
                            const e = ht.get(t).programs;
                            void 0 !== e && e.forEach((function(t) {
                                wt.releaseProgram(t)
                            }))
                        })(t), ht.remove(t)
                    }(e)
            }
            this.xr = zt, this.getContext = function() {
                return It
            }, this.getContextAttributes = function() {
                return It.getContextAttributes()
            }, this.forceContextLoss = function() {
                const t = st.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function() {
                const t = st.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function() {
                return V
            }, this.setPixelRatio = function(t) {
                void 0 !== t && (V = t, this.setSize(H, j, !1))
            }, this.getSize = function(t) {
                return t.set(H, j)
            }, this.setSize = function(t, n, r) {
                zt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (H = t, j = n, e.width = Math.floor(t * V), e.height = Math.floor(n * V), !1 !== r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
            }, this.getDrawingBufferSize = function(t) {
                return t.set(H * V, j * V).floor()
            }, this.setDrawingBufferSize = function(t, n, r) {
                H = t, j = n, V = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n)
            }, this.getCurrentViewport = function(t) {
                return t.copy(z)
            }, this.getViewport = function(t) {
                return t.copy($)
            }, this.setViewport = function(t, e, n, r) {
                t.isVector4 ? $.set(t.x, t.y, t.z, t.w) : $.set(t, e, n, r), ct.viewport(z.copy($).multiplyScalar(V).floor())
            }, this.getScissor = function(t) {
                return t.copy(Y)
            }, this.setScissor = function(t, e, n, r) {
                t.isVector4 ? Y.set(t.x, t.y, t.z, t.w) : Y.set(t, e, n, r), ct.scissor(B.copy(Y).multiplyScalar(V).floor())
            }, this.getScissorTest = function() {
                return Z
            }, this.setScissorTest = function(t) {
                ct.setScissorTest(Z = t)
            }, this.setOpaqueSort = function(t) {
                G = t
            }, this.setTransparentSort = function(t) {
                X = t
            }, this.getClearColor = function(t) {
                return t.copy(Lt.getClearColor())
            }, this.setClearColor = function() {
                Lt.setClearColor.apply(Lt, arguments)
            }, this.getClearAlpha = function() {
                return Lt.getClearAlpha()
            }, this.setClearAlpha = function() {
                Lt.setClearAlpha.apply(Lt, arguments)
            }, this.clear = function(t, e, n) {
                let r = 0;
                (void 0 === t || t) && (r |= 16384), (void 0 === e || e) && (r |= 256), (void 0 === n || n) && (r |= 1024), It.clear(r)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.dispose = function() {
                e.removeEventListener("webglcontextlost", Bt, !1), e.removeEventListener("webglcontextrestored", Ut, !1), Tt.dispose(), Et.dispose(), ht.dispose(), ft.dispose(), mt.dispose(), yt.dispose(), Ot.dispose(), zt.dispose(), zt.removeEventListener("sessionstart", Vt), zt.removeEventListener("sessionend", Gt), et && (et.dispose(), et = null), Wt.stop()
            }, this.renderBufferImmediate = function(object, t) {
                Ot.initAttributes();
                const e = ht.get(object);
                object.hasPositions && !e.position && (e.position = It.createBuffer()), object.hasNormals && !e.normal && (e.normal = It.createBuffer()), object.hasUvs && !e.uv && (e.uv = It.createBuffer()), object.hasColors && !e.color && (e.color = It.createBuffer());
                const n = t.getAttributes();
                object.hasPositions && (It.bindBuffer(34962, e.position), It.bufferData(34962, object.positionArray, 35048), Ot.enableAttribute(n.position), It.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), object.hasNormals && (It.bindBuffer(34962, e.normal), It.bufferData(34962, object.normalArray, 35048), Ot.enableAttribute(n.normal), It.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), object.hasUvs && (It.bindBuffer(34962, e.uv), It.bufferData(34962, object.uvArray, 35048), Ot.enableAttribute(n.uv), It.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), object.hasColors && (It.bindBuffer(34962, e.color), It.bufferData(34962, object.colorArray, 35048), Ot.enableAttribute(n.color), It.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), Ot.disableUnusedAttributes(), It.drawArrays(4, 0, object.count), object.count = 0
            }, this.renderBufferDirect = function(t, e, n, r, object, o) {
                null === e && (e = ot);
                const l = object.isMesh && object.matrixWorld.determinant() < 0,
                    c = Jt(t, e, r, object);
                ct.setMaterial(r, l);
                let h = n.index;
                const d = n.attributes.position;
                if (null === h) {
                    if (void 0 === d || 0 === d.count) return
                } else if (0 === h.count) return;
                let f, m = 1;
                !0 === r.wireframe && (h = vt.getWireframeAttribute(n), m = 2), void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || kt.update(object, n, r, c), Ot.setup(object, r, c, n, h);
                let v = Rt;
                null !== h && (f = gt.get(h), v = Pt, v.setIndex(f));
                const y = null !== h ? h.count : d.count,
                    _ = n.drawRange.start * m,
                    x = n.drawRange.count * m,
                    w = null !== o ? o.start * m : 0,
                    M = null !== o ? o.count * m : 1 / 0,
                    S = Math.max(_, w),
                    T = Math.min(y, _ + x, w + M) - 1,
                    E = Math.max(0, T - S + 1);
                if (0 !== E) {
                    if (object.isMesh) !0 === r.wireframe ? (ct.setLineWidth(r.wireframeLinewidth * at()), v.setMode(1)) : v.setMode(4);
                    else if (object.isLine) {
                        let t = r.linewidth;
                        void 0 === t && (t = 1), ct.setLineWidth(t * at()), object.isLineSegments ? v.setMode(1) : object.isLineLoop ? v.setMode(2) : v.setMode(3)
                    } else object.isPoints ? v.setMode(0) : object.isSprite && v.setMode(4);
                    if (object.isInstancedMesh) v.renderInstances(S, E, object.count);
                    else if (n.isInstancedBufferGeometry) {
                        const t = Math.min(n.instanceCount, n._maxInstanceCount);
                        v.renderInstances(S, E, t)
                    } else v.render(S, E)
                }
            }, this.compile = function(t, e) {
                M = Et.get(t), M.init(), T.push(M), t.traverseVisible((function(object) {
                    object.isLight && object.layers.test(e.layers) && (M.pushLight(object), object.castShadow && M.pushShadow(object))
                })), M.setupLights(), t.traverse((function(object) {
                    const e = object.material;
                    if (e)
                        if (Array.isArray(e))
                            for (let i = 0; i < e.length; i++) {
                                Yt(e[i], t, object)
                            } else Yt(e, t, object)
                })), T.pop(), M = null
            };
            let jt = null;

            function Vt() {
                Wt.stop()
            }

            function Gt() {
                Wt.start()
            }
            const Wt = new qn;

            function qt(object, t, e, n) {
                if (!1 === object.visible) return;
                if (object.layers.test(t.layers))
                    if (object.isGroup) e = object.renderOrder;
                    else if (object.isLOD) !0 === object.autoUpdate && object.update(t);
                else if (object.isLight) M.pushLight(object), object.castShadow && M.pushShadow(object);
                else if (object.isSprite) {
                    if (!object.frustumCulled || K.intersectsSprite(object)) {
                        n && it.setFromMatrixPosition(object.matrixWorld).applyMatrix4(nt);
                        const t = yt.update(object),
                            r = object.material;
                        r.visible && x.push(object, t, r, e, it.z, null)
                    }
                } else if (object.isImmediateRenderObject) n && it.setFromMatrixPosition(object.matrixWorld).applyMatrix4(nt), x.push(object, null, object.material, e, it.z, null);
                else if ((object.isMesh || object.isLine || object.isPoints) && (object.isSkinnedMesh && object.skeleton.frame !== ut.render.frame && (object.skeleton.update(), object.skeleton.frame = ut.render.frame), !object.frustumCulled || K.intersectsObject(object))) {
                    n && it.setFromMatrixPosition(object.matrixWorld).applyMatrix4(nt);
                    const t = yt.update(object),
                        r = object.material;
                    if (Array.isArray(r)) {
                        const n = t.groups;
                        for (let i = 0, o = n.length; i < o; i++) {
                            const o = n[i],
                                l = r[o.materialIndex];
                            l && l.visible && x.push(object, t, l, e, it.z, o)
                        }
                    } else r.visible && x.push(object, t, r, e, it.z, null)
                }
                const r = object.children;
                for (let i = 0, o = r.length; i < o; i++) qt(r[i], t, e, n)
            }

            function Xt(t, e, n) {
                const r = !0 === e.isScene ? e.overrideMaterial : null;
                if (n.isArrayCamera) {
                    const o = n.cameras;
                    for (let i = 0, n = o.length; i < n; i++) {
                        const n = o[i];
                        ct.viewport(z.copy(n.viewport)), M.setupLightsView(n);
                        for (let o = 0, l = t.length; o < l; o++) {
                            const l = t[o],
                                object = l.object,
                                c = l.geometry,
                                h = null === r ? l.material : r,
                                d = l.group;
                            object.layers.test(n.layers) && $t(object, e, n, c, h, d)
                        }
                    }
                } else
                    for (let o = 0, l = t.length; o < l; o++) {
                        const l = t[o];
                        $t(l.object, e, n, l.geometry, null === r ? l.material : r, l.group)
                    }
            }

            function $t(object, t, e, n, l, c) {
                if (object.onBeforeRender(C, t, e, n, l, c), object.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, object.matrixWorld), object.normalMatrix.getNormalMatrix(object.modelViewMatrix), object.isImmediateRenderObject) {
                    const n = Jt(e, t, l, object);
                    ct.setMaterial(l), Ot.reset(),
                        function(object, t) {
                            object.render((function(object) {
                                C.renderBufferImmediate(object, t)
                            }))
                        }(object, n)
                } else !0 === l.transparent && 2 === l.side ? (l.side = o, l.needsUpdate = !0, C.renderBufferDirect(e, t, n, l, object, c), l.side = r, l.needsUpdate = !0, C.renderBufferDirect(e, t, n, l, object, c), l.side = 2) : C.renderBufferDirect(e, t, n, l, object, c);
                object.onAfterRender(C, t, e, n, l, c)
            }

            function Yt(t, e, object) {
                !0 !== e.isScene && (e = ot);
                const n = ht.get(t),
                    r = M.state.lights,
                    o = M.state.shadowsArray,
                    l = r.state.version,
                    c = wt.getParameters(t, r.state, o, e, object),
                    h = wt.getProgramCacheKey(c);
                let d = n.programs;
                n.environment = t.isMeshStandardMaterial ? e.environment : null, n.fog = e.fog, n.envMap = (t.isMeshStandardMaterial ? mt : ft).get(t.envMap || n.environment), void 0 === d && (t.addEventListener("dispose", Ht), d = new Map, n.programs = d);
                let f = d.get(h);
                if (void 0 !== f) {
                    if (n.currentProgram === f && n.lightsStateVersion === l) return Zt(t, c), f
                } else c.uniforms = wt.getUniforms(t), t.onBuild(c, C), t.onBeforeCompile(c, C), f = wt.acquireProgram(c, h), d.set(h, f), n.uniforms = c.uniforms;
                const m = n.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (m.clippingPlanes = At.uniform), Zt(t, c), n.needsLights = function(t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }(t), n.lightsStateVersion = l, n.needsLights && (m.ambientLightColor.value = r.state.ambient, m.lightProbe.value = r.state.probe, m.directionalLights.value = r.state.directional, m.directionalLightShadows.value = r.state.directionalShadow, m.spotLights.value = r.state.spot, m.spotLightShadows.value = r.state.spotShadow, m.rectAreaLights.value = r.state.rectArea, m.ltc_1.value = r.state.rectAreaLTC1, m.ltc_2.value = r.state.rectAreaLTC2, m.pointLights.value = r.state.point, m.pointLightShadows.value = r.state.pointShadow, m.hemisphereLights.value = r.state.hemi, m.directionalShadowMap.value = r.state.directionalShadowMap, m.directionalShadowMatrix.value = r.state.directionalShadowMatrix, m.spotShadowMap.value = r.state.spotShadowMap, m.spotShadowMatrix.value = r.state.spotShadowMatrix, m.pointShadowMap.value = r.state.pointShadowMap, m.pointShadowMatrix.value = r.state.pointShadowMatrix);
                const v = f.getUniforms(),
                    y = $i.seqWithValue(v.seq, m);
                return n.currentProgram = f, n.uniformsList = y, f
            }

            function Zt(t, e) {
                const n = ht.get(t);
                n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents
            }

            function Jt(t, e, n, object) {
                !0 !== e.isScene && (e = ot), pt.resetTextureUnits();
                const r = e.fog,
                    o = n.isMeshStandardMaterial ? e.environment : null,
                    l = null === I ? C.outputEncoding : I.texture.encoding,
                    c = (n.isMeshStandardMaterial ? mt : ft).get(n.envMap || o),
                    h = !0 === n.vertexColors && !!object.geometry && !!object.geometry.attributes.color && 4 === object.geometry.attributes.color.itemSize,
                    d = !!object.geometry && !!object.geometry.attributes.tangent,
                    f = !!object.geometry && !!object.geometry.morphAttributes.position,
                    m = !!object.geometry && !!object.geometry.morphAttributes.normal,
                    v = ht.get(n),
                    y = M.state.lights;
                if (!0 === Q && (!0 === tt || t !== F)) {
                    const e = t === F && n.id === N;
                    At.setState(n, t, e)
                }
                let _ = !1;
                n.version === v.__version ? v.needsLights && v.lightsStateVersion !== y.state.version || v.outputEncoding !== l || object.isInstancedMesh && !1 === v.instancing ? _ = !0 : object.isInstancedMesh || !0 !== v.instancing ? object.isSkinnedMesh && !1 === v.skinning ? _ = !0 : object.isSkinnedMesh || !0 !== v.skinning ? v.envMap !== c || n.fog && v.fog !== r ? _ = !0 : void 0 === v.numClippingPlanes || v.numClippingPlanes === At.numPlanes && v.numIntersection === At.numIntersection ? (v.vertexAlphas !== h || v.vertexTangents !== d || v.morphTargets !== f || v.morphNormals !== m) && (_ = !0) : _ = !0 : _ = !0 : _ = !0 : (_ = !0, v.__version = n.version);
                let x = v.currentProgram;
                !0 === _ && (x = Yt(n, e, object));
                let w = !1,
                    S = !1,
                    T = !1;
                const E = x.getUniforms(),
                    A = v.uniforms;
                if (ct.useProgram(x.program) && (w = !0, S = !0, T = !0), n.id !== N && (N = n.id, S = !0), w || F !== t) {
                    if (E.setValue(It, "projectionMatrix", t.projectionMatrix), lt.logarithmicDepthBuffer && E.setValue(It, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), F !== t && (F = t, S = !0, T = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                        const e = E.map.cameraPosition;
                        void 0 !== e && e.setValue(It, it.setFromMatrixPosition(t.matrixWorld))
                    }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && E.setValue(It, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || object.isSkinnedMesh) && E.setValue(It, "viewMatrix", t.matrixWorldInverse)
                }
                if (object.isSkinnedMesh) {
                    E.setOptional(It, object, "bindMatrix"), E.setOptional(It, object, "bindMatrixInverse");
                    const t = object.skeleton;
                    t && (lt.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), E.setValue(It, "boneTexture", t.boneTexture, pt), E.setValue(It, "boneTextureSize", t.boneTextureSize)) : E.setOptional(It, t, "boneMatrices"))
                }
                var L, k;
                return (S || v.receiveShadow !== object.receiveShadow) && (v.receiveShadow = object.receiveShadow, E.setValue(It, "receiveShadow", object.receiveShadow)), S && (E.setValue(It, "toneMappingExposure", C.toneMappingExposure), v.needsLights && (k = T, (L = A).ambientLightColor.needsUpdate = k, L.lightProbe.needsUpdate = k, L.directionalLights.needsUpdate = k, L.directionalLightShadows.needsUpdate = k, L.pointLights.needsUpdate = k, L.pointLightShadows.needsUpdate = k, L.spotLights.needsUpdate = k, L.spotLightShadows.needsUpdate = k, L.rectAreaLights.needsUpdate = k, L.hemisphereLights.needsUpdate = k), r && n.fog && St.refreshFogUniforms(A, r), St.refreshMaterialUniforms(A, n, V, j, et), $i.upload(It, v.uniformsList, A, pt)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && ($i.upload(It, v.uniformsList, A, pt), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && E.setValue(It, "center", object.center), E.setValue(It, "modelViewMatrix", object.modelViewMatrix), E.setValue(It, "normalMatrix", object.normalMatrix), E.setValue(It, "modelMatrix", object.matrixWorld), x
            }
            Wt.setAnimationLoop((function(time) {
                jt && jt(time)
            })), "undefined" != typeof window && Wt.setContext(window), this.setAnimationLoop = function(t) {
                jt = t, zt.setAnimationLoop(t), null === t ? Wt.stop() : Wt.start()
            }, zt.addEventListener("sessionstart", Vt), zt.addEventListener("sessionend", Gt), this.render = function(t, e) {
                if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                if (!0 === L) return;
                !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === zt.enabled && !0 === zt.isPresenting && (!0 === zt.cameraAutoUpdate && zt.updateCamera(e), e = zt.getCamera()), !0 === t.isScene && t.onBeforeRender(C, t, e, I), M = Et.get(t, T.length), M.init(), T.push(M), nt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), K.setFromProjectionMatrix(nt), tt = this.localClippingEnabled, Q = At.init(this.clippingPlanes, tt, e), x = Tt.get(t, S.length), x.init(), S.push(x), qt(t, e, 0, C.sortObjects), x.finish(), !0 === C.sortObjects && x.sort(G, X), !0 === Q && At.beginShadows();
                const n = M.state.shadowsArray;
                Ct.render(n, t, e), M.setupLights(), M.setupLightsView(e), !0 === Q && At.endShadows(), !0 === this.info.autoReset && this.info.reset(), Lt.render(x, t);
                const r = x.opaque,
                    o = x.transmissive,
                    l = x.transparent;
                r.length > 0 && Xt(r, t, e), o.length > 0 && function(t, e, n, r) {
                    if (null === et) {
                        const t = !0 === d && !0 === lt.isWebGL2;
                        et = new(t ? bt : xt)(1024, 1024, {
                            generateMipmaps: !0,
                            type: null !== Dt.convert(R) ? R : A,
                            minFilter: E,
                            magFilter: w,
                            wrapS: _,
                            wrapT: _
                        })
                    }
                    const o = C.getRenderTarget();
                    C.setRenderTarget(et), C.clear();
                    const l = C.toneMapping;
                    C.toneMapping = 0, Xt(t, n, r), C.toneMapping = l, pt.updateMultisampleRenderTarget(et), pt.updateRenderTargetMipmap(et), C.setRenderTarget(o), Xt(e, n, r)
                }(r, o, t, e), l.length > 0 && Xt(l, t, e), null !== I && (pt.updateMultisampleRenderTarget(I), pt.updateRenderTargetMipmap(I)), !0 === t.isScene && t.onAfterRender(C, t, e), ct.buffers.depth.setTest(!0), ct.buffers.depth.setMask(!0), ct.buffers.color.setMask(!0), ct.setPolygonOffset(!1), Ot.resetDefaultState(), N = -1, F = null, T.pop(), M = T.length > 0 ? T[T.length - 1] : null, S.pop(), x = S.length > 0 ? S[S.length - 1] : null
            }, this.getActiveCubeFace = function() {
                return P
            }, this.getActiveMipmapLevel = function() {
                return D
            }, this.getRenderTarget = function() {
                return I
            }, this.setRenderTarget = function(t, e = 0, n = 0) {
                I = t, P = e, D = n, t && void 0 === ht.get(t).__webglFramebuffer && pt.setupRenderTarget(t);
                let r = null,
                    o = !1,
                    l = !1;
                if (t) {
                    const n = t.texture;
                    (n.isDataTexture3D || n.isDataTexture2DArray) && (l = !0);
                    const c = ht.get(t).__webglFramebuffer;
                    t.isWebGLCubeRenderTarget ? (r = c[e], o = !0) : r = t.isWebGLMultisampleRenderTarget ? ht.get(t).__webglMultisampledFramebuffer : c, z.copy(t.viewport), B.copy(t.scissor), U = t.scissorTest
                } else z.copy($).multiplyScalar(V).floor(), B.copy(Y).multiplyScalar(V).floor(), U = Z;
                if (ct.bindFramebuffer(36160, r) && lt.drawBuffers) {
                    let e = !1;
                    if (t)
                        if (t.isWebGLMultipleRenderTargets) {
                            const n = t.texture;
                            if (J.length !== n.length || 36064 !== J[0]) {
                                for (let i = 0, t = n.length; i < t; i++) J[i] = 36064 + i;
                                J.length = n.length, e = !0
                            }
                        } else 1 === J.length && 36064 === J[0] || (J[0] = 36064, J.length = 1, e = !0);
                    else 1 === J.length && 1029 === J[0] || (J[0] = 1029, J.length = 1, e = !0);
                    e && (lt.isWebGL2 ? It.drawBuffers(J) : st.get("WEBGL_draw_buffers").drawBuffersWEBGL(J))
                }
                if (ct.viewport(z), ct.scissor(B), ct.setScissorTest(U), o) {
                    const r = ht.get(t.texture);
                    It.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, n)
                } else if (l) {
                    const r = ht.get(t.texture),
                        o = e || 0;
                    It.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, o)
                }
            }, this.readRenderTargetPixels = function(t, e, n, r, o, l, c) {
                if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let h = ht.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== c && (h = h[c]), h) {
                    ct.bindFramebuffer(36160, h);
                    try {
                        const c = t.texture,
                            h = c.format,
                            d = c.type;
                        if (h !== O && Dt.convert(h) !== It.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        const f = d === R && (st.has("EXT_color_buffer_half_float") || lt.isWebGL2 && st.has("EXT_color_buffer_float"));
                        if (!(d === A || Dt.convert(d) === It.getParameter(35738) || d === k && (lt.isWebGL2 || st.has("OES_texture_float") || st.has("WEBGL_color_buffer_float")) || f)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === It.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - o && It.readPixels(e, n, r, o, Dt.convert(h), Dt.convert(d), l) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        const t = null !== I ? ht.get(I).__webglFramebuffer : null;
                        ct.bindFramebuffer(36160, t)
                    }
                }
            }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                const r = Math.pow(2, -n),
                    o = Math.floor(e.image.width * r),
                    l = Math.floor(e.image.height * r);
                let c = Dt.convert(e.format);
                lt.isWebGL2 && (6407 === c && (c = 32849), 6408 === c && (c = 32856)), pt.setTexture2D(e, 0), It.copyTexImage2D(3553, n, c, t.x, t.y, o, l, 0), ct.unbindTexture()
            }, this.copyTextureToTexture = function(t, e, n, r = 0) {
                const o = e.image.width,
                    l = e.image.height,
                    c = Dt.convert(n.format),
                    h = Dt.convert(n.type);
                pt.setTexture2D(n, 0), It.pixelStorei(37440, n.flipY), It.pixelStorei(37441, n.premultiplyAlpha), It.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? It.texSubImage2D(3553, r, t.x, t.y, o, l, c, h, e.image.data) : e.isCompressedTexture ? It.compressedTexSubImage2D(3553, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, c, e.mipmaps[0].data) : It.texSubImage2D(3553, r, t.x, t.y, c, h, e.image), 0 === r && n.generateMipmaps && It.generateMipmap(3553), ct.unbindTexture()
            }, this.copyTextureToTexture3D = function(t, e, n, r, o = 0) {
                if (C.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                const l = t.max.x - t.min.x + 1,
                    c = t.max.y - t.min.y + 1,
                    h = t.max.z - t.min.z + 1,
                    d = Dt.convert(r.format),
                    f = Dt.convert(r.type);
                let m;
                if (r.isDataTexture3D) pt.setTexture3D(r, 0), m = 32879;
                else {
                    if (!r.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    pt.setTexture2DArray(r, 0), m = 35866
                }
                It.pixelStorei(37440, r.flipY), It.pixelStorei(37441, r.premultiplyAlpha), It.pixelStorei(3317, r.unpackAlignment);
                const v = It.getParameter(3314),
                    y = It.getParameter(32878),
                    _ = It.getParameter(3316),
                    x = It.getParameter(3315),
                    w = It.getParameter(32877),
                    image = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                It.pixelStorei(3314, image.width), It.pixelStorei(32878, image.height), It.pixelStorei(3316, t.min.x), It.pixelStorei(3315, t.min.y), It.pixelStorei(32877, t.min.z), n.isDataTexture || n.isDataTexture3D ? It.texSubImage3D(m, o, e.x, e.y, e.z, l, c, h, d, f, image.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), It.compressedTexSubImage3D(m, o, e.x, e.y, e.z, l, c, h, d, image.data)) : It.texSubImage3D(m, o, e.x, e.y, e.z, l, c, h, d, f, image), It.pixelStorei(3314, v), It.pixelStorei(32878, y), It.pixelStorei(3316, _), It.pixelStorei(3315, x), It.pixelStorei(32877, w), 0 === o && r.generateMipmaps && It.generateMipmap(m), ct.unbindTexture()
            }, this.initTexture = function(t) {
                pt.setTexture2D(t, 0), ct.unbindTexture()
            }, this.resetState = function() {
                P = 0, D = 0, I = null, ct.reset(), Ot.reset()
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }(class extends Uo {}).prototype.isWebGL1Renderer = !0;
        class Ho {
            constructor(t, e = 25e-5) {
                this.name = "", this.color = new We(t), this.density = e
            }
            clone() {
                return new Ho(this.color, this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        Ho.prototype.isFogExp2 = !0;
        class jo {
            constructor(t, e = 1, n = 1e3) {
                this.name = "", this.color = new We(t), this.near = e, this.far = n
            }
            clone() {
                return new jo(this.color, this.near, this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        jo.prototype.isFog = !0;
        class Vo extends Te {
            constructor() {
                super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            copy(source, t) {
                return super.copy(source, t), null !== source.background && (this.background = source.background.clone()), null !== source.environment && (this.environment = source.environment.clone()), null !== source.fog && (this.fog = source.fog.clone()), null !== source.overrideMaterial && (this.overrideMaterial = source.overrideMaterial.clone()), this.autoUpdate = source.autoUpdate, this.matrixAutoUpdate = source.matrixAutoUpdate, this
            }
            toJSON(meta) {
                const data = super.toJSON(meta);
                return null !== this.fog && (data.object.fog = this.fog.toJSON()), data
            }
        }
        Vo.prototype.isScene = !0;
        class Go {
            constructor(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = J, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0, this.uuid = ot()
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t, this
            }
            copy(source) {
                return this.array = new source.array.constructor(source.array), this.count = source.count, this.stride = source.stride, this.usage = source.usage, this
            }
            copyAt(t, e, n) {
                t *= this.stride, n *= e.stride;
                for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                return this
            }
            set(t, e = 0) {
                return this.array.set(t, e), this
            }
            clone(data) {
                void 0 === data.arrayBuffers && (data.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ot()), void 0 === data.arrayBuffers[this.array.buffer._uuid] && (data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const t = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]),
                    e = new this.constructor(t, this.stride);
                return e.setUsage(this.usage), e
            }
            onUpload(t) {
                return this.onUploadCallback = t, this
            }
            toJSON(data) {
                return void 0 === data.arrayBuffers && (data.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ot()), void 0 === data.arrayBuffers[this.array.buffer._uuid] && (data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        Go.prototype.isInterleavedBuffer = !0;
        const Wo = new Mt;
        class qo {
            constructor(t, e, n, r = !1) {
                this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === r
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(t) {
                this.data.needsUpdate = t
            }
            applyMatrix4(t) {
                for (let i = 0, e = this.data.count; i < e; i++) Wo.x = this.getX(i), Wo.y = this.getY(i), Wo.z = this.getZ(i), Wo.applyMatrix4(t), this.setXYZ(i, Wo.x, Wo.y, Wo.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let i = 0, e = this.count; i < e; i++) Wo.x = this.getX(i), Wo.y = this.getY(i), Wo.z = this.getZ(i), Wo.applyNormalMatrix(t), this.setXYZ(i, Wo.x, Wo.y, Wo.z);
                return this
            }
            transformDirection(t) {
                for (let i = 0, e = this.count; i < e; i++) Wo.x = this.getX(i), Wo.y = this.getY(i), Wo.z = this.getZ(i), Wo.transformDirection(t), this.setXYZ(i, Wo.x, Wo.y, Wo.z);
                return this
            }
            setX(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            }
            setY(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            }
            setZ(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            }
            setW(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            }
            getX(t) {
                return this.data.array[t * this.data.stride + this.offset]
            }
            getY(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            }
            getZ(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            }
            getW(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            }
            setXY(t, e, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
            }
            setXYZ(t, e, n, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this
            }
            setXYZW(t, e, n, r, o) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = o, this
            }
            clone(data) {
                if (void 0 === data) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let i = 0; i < this.count; i++) {
                        const e = i * this.data.stride + this.offset;
                        for (let n = 0; n < this.itemSize; n++) t.push(this.data.array[e + n])
                    }
                    return new Ye(new this.array.constructor(t), this.itemSize, this.normalized)
                }
                return void 0 === data.interleavedBuffers && (data.interleavedBuffers = {}), void 0 === data.interleavedBuffers[this.data.uuid] && (data.interleavedBuffers[this.data.uuid] = this.data.clone(data)), new qo(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            }
            toJSON(data) {
                if (void 0 === data) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let i = 0; i < this.count; i++) {
                        const e = i * this.data.stride + this.offset;
                        for (let n = 0; n < this.itemSize; n++) t.push(this.data.array[e + n])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                }
                return void 0 === data.interleavedBuffers && (data.interleavedBuffers = {}), void 0 === data.interleavedBuffers[this.data.uuid] && (data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        qo.prototype.isInterleavedBufferAttribute = !0;
        class Xo extends ze {
            constructor(t) {
                super(), this.type = "SpriteMaterial", this.color = new We(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.color.copy(source.color), this.map = source.map, this.alphaMap = source.alphaMap, this.rotation = source.rotation, this.sizeAttenuation = source.sizeAttenuation, this
            }
        }
        let $o;
        Xo.prototype.isSpriteMaterial = !0;
        const Yo = new Mt,
            Zo = new Mt,
            Jo = new Mt,
            Ko = new ht,
            Qo = new ht,
            ta = new te,
            ea = new Mt,
            na = new Mt,
            ra = new Mt,
            ia = new ht,
            oa = new ht,
            aa = new ht;
        class sa extends Te {
            constructor(t) {
                if (super(), this.type = "Sprite", void 0 === $o) {
                    $o = new ln;
                    const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                        e = new Go(t, 5);
                    $o.setIndex([0, 1, 2, 0, 2, 3]), $o.setAttribute("position", new qo(e, 3, 0, !1)), $o.setAttribute("uv", new qo(e, 2, 3, !1))
                }
                this.geometry = $o, this.material = void 0 !== t ? t : new Xo, this.center = new ht(.5, .5)
            }
            raycast(t, e) {
                null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Zo.setFromMatrixScale(this.matrixWorld), ta.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Jo.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Zo.multiplyScalar(-Jo.z);
                const n = this.material.rotation;
                let r, o;
                0 !== n && (o = Math.cos(n), r = Math.sin(n));
                const l = this.center;
                la(ea.set(-.5, -.5, 0), Jo, l, Zo, r, o), la(na.set(.5, -.5, 0), Jo, l, Zo, r, o), la(ra.set(.5, .5, 0), Jo, l, Zo, r, o), ia.set(0, 0), oa.set(1, 0), aa.set(1, 1);
                let c = t.ray.intersectTriangle(ea, na, ra, !1, Yo);
                if (null === c && (la(na.set(-.5, .5, 0), Jo, l, Zo, r, o), oa.set(0, 1), c = t.ray.intersectTriangle(ea, ra, na, !1, Yo), null === c)) return;
                const h = t.ray.origin.distanceTo(Yo);
                h < t.near || h > t.far || e.push({
                    distance: h,
                    point: Yo.clone(),
                    uv: Ne.getUV(Yo, ea, na, ra, ia, oa, aa, new ht),
                    face: null,
                    object: this
                })
            }
            copy(source) {
                return super.copy(source), void 0 !== source.center && this.center.copy(source.center), this.material = source.material, this
            }
        }

        function la(t, e, n, r, o, l) {
            Ko.subVectors(t, n).addScalar(.5).multiply(r), void 0 !== o ? (Qo.x = l * Ko.x - o * Ko.y, Qo.y = o * Ko.x + l * Ko.y) : Qo.copy(Ko), t.copy(e), t.x += Qo.x, t.y += Qo.y, t.applyMatrix4(ta)
        }
        sa.prototype.isSprite = !0;
        const ca = new Mt,
            ua = new _t,
            ha = new _t,
            da = new Mt,
            pa = new te;
        class fa extends En {
            constructor(t, e) {
                super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new te, this.bindMatrixInverse = new te
            }
            copy(source) {
                return super.copy(source), this.bindMode = source.bindMode, this.bindMatrix.copy(source.bindMatrix), this.bindMatrixInverse.copy(source.bindMatrixInverse), this.skeleton = source.skeleton, this
            }
            bind(t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const t = new _t,
                    e = this.geometry.attributes.skinWeight;
                for (let i = 0, n = e.count; i < n; i++) {
                    t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
                    const n = 1 / t.manhattanLength();
                    n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
                }
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            boneTransform(t, e) {
                const n = this.skeleton,
                    r = this.geometry;
                ua.fromBufferAttribute(r.attributes.skinIndex, t), ha.fromBufferAttribute(r.attributes.skinWeight, t), ca.fromBufferAttribute(r.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                for (let i = 0; i < 4; i++) {
                    const t = ha.getComponent(i);
                    if (0 !== t) {
                        const r = ua.getComponent(i);
                        pa.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(da.copy(ca).applyMatrix4(pa), t)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
        }
        fa.prototype.isSkinnedMesh = !0;
        class ma extends Te {
            constructor() {
                super(), this.type = "Bone"
            }
        }
        ma.prototype.isBone = !0;
        class ga extends vt {
            constructor(data = null, t = 1, e = 1, n, r, o, l, c, h = 1003, d = 1003, f, m) {
                super(null, o, l, c, h, d, n, r, f, m), this.image = {
                    data: data,
                    width: t,
                    height: e
                }, this.magFilter = h, this.minFilter = d, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
        }
        ga.prototype.isDataTexture = !0;
        const va = new te,
            ya = new te,
            _a = [],
            xa = new En;
        class ba extends En {
            constructor(t, e, n) {
                super(t, e), this.instanceMatrix = new Ye(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
            }
            copy(source) {
                return super.copy(source), this.instanceMatrix.copy(source.instanceMatrix), null !== source.instanceColor && (this.instanceColor = source.instanceColor.clone()), this.count = source.count, this
            }
            getColorAt(t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            }
            getMatrixAt(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            }
            raycast(t, e) {
                const n = this.matrixWorld,
                    r = this.count;
                if (xa.geometry = this.geometry, xa.material = this.material, void 0 !== xa.material)
                    for (let o = 0; o < r; o++) {
                        this.getMatrixAt(o, va), ya.multiplyMatrices(n, va), xa.matrixWorld = ya, xa.raycast(t, _a);
                        for (let i = 0, t = _a.length; i < t; i++) {
                            const t = _a[i];
                            t.instanceId = o, t.object = this, e.push(t)
                        }
                        _a.length = 0
                    }
            }
            setColorAt(t, e) {
                null === this.instanceColor && (this.instanceColor = new Ye(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
            }
            setMatrixAt(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        ba.prototype.isInstancedMesh = !0;
        class wa extends ze {
            constructor(t) {
                super(), this.type = "LineBasicMaterial", this.color = new We(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.color.copy(source.color), this.linewidth = source.linewidth, this.linecap = source.linecap, this.linejoin = source.linejoin, this
            }
        }
        wa.prototype.isLineBasicMaterial = !0;
        const Ma = new Mt,
            Sa = new Mt,
            Ta = new te,
            Ea = new Qt,
            Aa = new Wt;
        class Ca extends Te {
            constructor(t = new ln, e = new wa) {
                super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(source) {
                return super.copy(source), this.material = source.material, this.geometry = source.geometry, this
            }
            computeLineDistances() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position,
                            n = [0];
                        for (let i = 1, t = e.count; i < t; i++) Ma.fromBufferAttribute(e, i - 1), Sa.fromBufferAttribute(e, i), n[i] = n[i - 1], n[i] += Ma.distanceTo(Sa);
                        t.setAttribute("lineDistance", new Ke(n, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
            raycast(t, e) {
                const n = this.geometry,
                    r = this.matrixWorld,
                    o = t.params.Line.threshold,
                    l = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Aa.copy(n.boundingSphere), Aa.applyMatrix4(r), Aa.radius += o, !1 === t.ray.intersectsSphere(Aa)) return;
                Ta.copy(r).invert(), Ea.copy(t.ray).applyMatrix4(Ta);
                const c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    h = c * c,
                    d = new Mt,
                    f = new Mt,
                    m = new Mt,
                    v = new Mt,
                    y = this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    const r = n.index,
                        o = n.attributes.position;
                    if (null !== r) {
                        for (let i = Math.max(0, l.start), n = Math.min(r.count, l.start + l.count) - 1; i < n; i += y) {
                            const a = r.getX(i),
                                b = r.getX(i + 1);
                            d.fromBufferAttribute(o, a), f.fromBufferAttribute(o, b);
                            if (Ea.distanceSqToSegment(d, f, v, m) > h) continue;
                            v.applyMatrix4(this.matrixWorld);
                            const n = t.ray.origin.distanceTo(v);
                            n < t.near || n > t.far || e.push({
                                distance: n,
                                point: m.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    } else {
                        for (let i = Math.max(0, l.start), n = Math.min(o.count, l.start + l.count) - 1; i < n; i += y) {
                            d.fromBufferAttribute(o, i), f.fromBufferAttribute(o, i + 1);
                            if (Ea.distanceSqToSegment(d, f, v, m) > h) continue;
                            v.applyMatrix4(this.matrixWorld);
                            const n = t.ray.origin.distanceTo(v);
                            n < t.near || n > t.far || e.push({
                                distance: n,
                                point: m.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes,
                        n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }
        Ca.prototype.isLine = !0;
        const La = new Mt,
            ka = new Mt;
        class Ra extends Ca {
            constructor(t, e) {
                super(t, e), this.type = "LineSegments"
            }
            computeLineDistances() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position,
                            n = [];
                        for (let i = 0, t = e.count; i < t; i += 2) La.fromBufferAttribute(e, i), ka.fromBufferAttribute(e, i + 1), n[i] = 0 === i ? 0 : n[i - 1], n[i + 1] = n[i] + La.distanceTo(ka);
                        t.setAttribute("lineDistance", new Ke(n, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
        }
        Ra.prototype.isLineSegments = !0;
        class Pa extends Ca {
            constructor(t, e) {
                super(t, e), this.type = "LineLoop"
            }
        }
        Pa.prototype.isLineLoop = !0;
        class Da extends ze {
            constructor(t) {
                super(), this.type = "PointsMaterial", this.color = new We(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.color.copy(source.color), this.map = source.map, this.alphaMap = source.alphaMap, this.size = source.size, this.sizeAttenuation = source.sizeAttenuation, this
            }
        }
        Da.prototype.isPointsMaterial = !0;
        const Oa = new te,
            Ia = new Qt,
            Na = new Wt,
            Fa = new Mt;
        class za extends Te {
            constructor(t = new ln, e = new Da) {
                super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            copy(source) {
                return super.copy(source), this.material = source.material, this.geometry = source.geometry, this
            }
            raycast(t, e) {
                const n = this.geometry,
                    r = this.matrixWorld,
                    o = t.params.Points.threshold,
                    l = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Na.copy(n.boundingSphere), Na.applyMatrix4(r), Na.radius += o, !1 === t.ray.intersectsSphere(Na)) return;
                Oa.copy(r).invert(), Ia.copy(t.ray).applyMatrix4(Oa);
                const c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    h = c * c;
                if (n.isBufferGeometry) {
                    const o = n.index,
                        c = n.attributes.position;
                    if (null !== o) {
                        for (let i = Math.max(0, l.start), n = Math.min(o.count, l.start + l.count); i < n; i++) {
                            const a = o.getX(i);
                            Fa.fromBufferAttribute(c, a), Ba(Fa, a, h, r, t, e, this)
                        }
                    } else {
                        for (let i = Math.max(0, l.start), n = Math.min(c.count, l.start + l.count); i < n; i++) Fa.fromBufferAttribute(c, i), Ba(Fa, i, h, r, t, e, this)
                    }
                } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes,
                        n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }

        function Ba(t, e, n, r, o, l, object) {
            const c = Ia.distanceSqToPoint(t);
            if (c < n) {
                const n = new Mt;
                Ia.closestPointToPoint(t, n), n.applyMatrix4(r);
                const h = o.ray.origin.distanceTo(n);
                if (h < o.near || h > o.far) return;
                l.push({
                    distance: h,
                    distanceToRay: Math.sqrt(c),
                    point: n,
                    index: e,
                    face: null,
                    object: object
                })
            }
        }
        za.prototype.isPoints = !0;
        (class extends vt {
            constructor(video, t, e, n, r, o, l, c, h) {
                super(video, t, e, n, r, o, l, c, h), this.format = void 0 !== l ? l : D, this.minFilter = void 0 !== o ? o : T, this.magFilter = void 0 !== r ? r : T, this.generateMipmaps = !1;
                const d = this;
                "requestVideoFrameCallback" in video && video.requestVideoFrameCallback((function t() {
                    d.needsUpdate = !0, video.requestVideoFrameCallback(t)
                }))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const video = this.image;
                !1 === "requestVideoFrameCallback" in video && video.readyState >= video.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }).prototype.isVideoTexture = !0;
        class Ua extends vt {
            constructor(t, e, n, r, o, l, c, h, d, f, m, v) {
                super(null, l, c, h, d, f, r, o, m, v), this.image = {
                    width: e,
                    height: n
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }
        }
        Ua.prototype.isCompressedTexture = !0;
        (class extends vt {
            constructor(canvas, t, e, n, r, o, l, c, h) {
                super(canvas, t, e, n, r, o, l, c, h), this.needsUpdate = !0
            }
        }).prototype.isCanvasTexture = !0;
        (class extends vt {
            constructor(t, e, n, r, o, l, c, h, d, f) {
                if ((f = void 0 !== f ? f : N) !== N && f !== F) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && f === N && (n = C), void 0 === n && f === F && (n = P), super(null, r, o, l, c, h, f, n, d), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== c ? c : w, this.minFilter = void 0 !== h ? h : w, this.flipY = !1, this.generateMipmaps = !1
            }
        }).prototype.isDepthTexture = !0;
        new Mt, new Mt, new Mt, new Ne;
        class Ha {
            constructor() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            }
            getPointAt(u, t) {
                const e = this.getUtoTmapping(u);
                return this.getPoint(e, t)
            }
            getPoints(t = 5) {
                const e = [];
                for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                return e
            }
            getSpacedPoints(t = 5) {
                const e = [];
                for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                return e
            }
            getLength() {
                const t = this.getLengths();
                return t[t.length - 1]
            }
            getLengths(t = this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                const e = [];
                let n, r = this.getPoint(0),
                    o = 0;
                e.push(0);
                for (let p = 1; p <= t; p++) n = this.getPoint(p / t), o += n.distanceTo(r), e.push(o), r = n;
                return this.cacheArcLengths = e, e
            }
            updateArcLengths() {
                this.needsUpdate = !0, this.getLengths()
            }
            getUtoTmapping(u, t) {
                const e = this.getLengths();
                let i = 0;
                const n = e.length;
                let r;
                r = t || u * e[n - 1];
                let o, l = 0,
                    c = n - 1;
                for (; l <= c;)
                    if (i = Math.floor(l + (c - l) / 2), o = e[i] - r, o < 0) l = i + 1;
                    else {
                        if (!(o > 0)) {
                            c = i;
                            break
                        }
                        c = i - 1
                    }
                if (i = c, e[i] === r) return i / (n - 1);
                const h = e[i];
                return (i + (r - h) / (e[i + 1] - h)) / (n - 1)
            }
            getTangent(t, e) {
                const n = 1e-4;
                let r = t - n,
                    o = t + n;
                r < 0 && (r = 0), o > 1 && (o = 1);
                const l = this.getPoint(r),
                    c = this.getPoint(o),
                    h = e || (l.isVector2 ? new ht : new Mt);
                return h.copy(c).sub(l).normalize(), h
            }
            getTangentAt(u, t) {
                const e = this.getUtoTmapping(u);
                return this.getTangent(e, t)
            }
            computeFrenetFrames(t, e) {
                const n = new Mt,
                    r = [],
                    o = [],
                    l = [],
                    c = new Mt,
                    h = new te;
                for (let i = 0; i <= t; i++) {
                    const u = i / t;
                    r[i] = this.getTangentAt(u, new Mt), r[i].normalize()
                }
                o[0] = new Mt, l[0] = new Mt;
                let d = Number.MAX_VALUE;
                const f = Math.abs(r[0].x),
                    m = Math.abs(r[0].y),
                    v = Math.abs(r[0].z);
                f <= d && (d = f, n.set(1, 0, 0)), m <= d && (d = m, n.set(0, 1, 0)), v <= d && n.set(0, 0, 1), c.crossVectors(r[0], n).normalize(), o[0].crossVectors(r[0], c), l[0].crossVectors(r[0], o[0]);
                for (let i = 1; i <= t; i++) {
                    if (o[i] = o[i - 1].clone(), l[i] = l[i - 1].clone(), c.crossVectors(r[i - 1], r[i]), c.length() > Number.EPSILON) {
                        c.normalize();
                        const t = Math.acos(at(r[i - 1].dot(r[i]), -1, 1));
                        o[i].applyMatrix4(h.makeRotationAxis(c, t))
                    }
                    l[i].crossVectors(r[i], o[i])
                }
                if (!0 === e) {
                    let e = Math.acos(at(o[0].dot(o[t]), -1, 1));
                    e /= t, r[0].dot(c.crossVectors(o[0], o[t])) > 0 && (e = -e);
                    for (let i = 1; i <= t; i++) o[i].applyMatrix4(h.makeRotationAxis(r[i], e * i)), l[i].crossVectors(r[i], o[i])
                }
                return {
                    tangents: r,
                    normals: o,
                    binormals: l
                }
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(source) {
                return this.arcLengthDivisions = source.arcLengthDivisions, this
            }
            toJSON() {
                const data = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return data.arcLengthDivisions = this.arcLengthDivisions, data.type = this.type, data
            }
            fromJSON(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }
        }
        class ja extends Ha {
            constructor(t = 0, e = 0, n = 1, r = 1, o = 0, l = 2 * Math.PI, c = !1, h = 0) {
                super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = r, this.aStartAngle = o, this.aEndAngle = l, this.aClockwise = c, this.aRotation = h
            }
            getPoint(t, e) {
                const n = e || new ht,
                    r = 2 * Math.PI;
                let o = this.aEndAngle - this.aStartAngle;
                const l = Math.abs(o) < Number.EPSILON;
                for (; o < 0;) o += r;
                for (; o > r;) o -= r;
                o < Number.EPSILON && (o = l ? 0 : r), !0 !== this.aClockwise || l || (o === r ? o = -r : o -= r);
                const c = this.aStartAngle + t * o;
                let h = this.aX + this.xRadius * Math.cos(c),
                    d = this.aY + this.yRadius * Math.sin(c);
                if (0 !== this.aRotation) {
                    const t = Math.cos(this.aRotation),
                        e = Math.sin(this.aRotation),
                        n = h - this.aX,
                        r = d - this.aY;
                    h = n * t - r * e + this.aX, d = n * e + r * t + this.aY
                }
                return n.set(h, d)
            }
            copy(source) {
                return super.copy(source), this.aX = source.aX, this.aY = source.aY, this.xRadius = source.xRadius, this.yRadius = source.yRadius, this.aStartAngle = source.aStartAngle, this.aEndAngle = source.aEndAngle, this.aClockwise = source.aClockwise, this.aRotation = source.aRotation, this
            }
            toJSON() {
                const data = super.toJSON();
                return data.aX = this.aX, data.aY = this.aY, data.xRadius = this.xRadius, data.yRadius = this.yRadius, data.aStartAngle = this.aStartAngle, data.aEndAngle = this.aEndAngle, data.aClockwise = this.aClockwise, data.aRotation = this.aRotation, data
            }
            fromJSON(t) {
                return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }
        }
        ja.prototype.isEllipseCurve = !0;
        class Va extends ja {
            constructor(t, e, n, r, o, l) {
                super(t, e, n, n, r, o, l), this.type = "ArcCurve"
            }
        }

        function Ga() {
            let t = 0,
                e = 0,
                n = 0,
                r = 0;

            function o(o, l, c, h) {
                t = o, e = c, n = -3 * o + 3 * l - 2 * c - h, r = 2 * o - 2 * l + c + h
            }
            return {
                initCatmullRom: function(t, e, n, r, l) {
                    o(e, n, l * (n - t), l * (r - e))
                },
                initNonuniformCatmullRom: function(t, e, n, r, l, c, h) {
                    let d = (e - t) / l - (n - t) / (l + c) + (n - e) / c,
                        f = (n - e) / c - (r - e) / (c + h) + (r - n) / h;
                    d *= c, f *= c, o(e, n, d, f)
                },
                calc: function(o) {
                    const l = o * o;
                    return t + e * o + n * l + r * (l * o)
                }
            }
        }
        Va.prototype.isArcCurve = !0;
        const Wa = new Mt,
            qa = new Ga,
            Xa = new Ga,
            $a = new Ga;
        class Ya extends Ha {
            constructor(t = [], e = !1, n = "centripetal", r = .5) {
                super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r
            }
            getPoint(t, e = new Mt) {
                const n = e,
                    r = this.points,
                    o = r.length,
                    p = (o - (this.closed ? 0 : 1)) * t;
                let l, c, h = Math.floor(p),
                    d = p - h;
                this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / o) + 1) * o : 0 === d && h === o - 1 && (h = o - 2, d = 1), this.closed || h > 0 ? l = r[(h - 1) % o] : (Wa.subVectors(r[0], r[1]).add(r[0]), l = Wa);
                const f = r[h % o],
                    m = r[(h + 1) % o];
                if (this.closed || h + 2 < o ? c = r[(h + 2) % o] : (Wa.subVectors(r[o - 1], r[o - 2]).add(r[o - 1]), c = Wa), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const t = "chordal" === this.curveType ? .5 : .25;
                    let e = Math.pow(l.distanceToSquared(f), t),
                        n = Math.pow(f.distanceToSquared(m), t),
                        r = Math.pow(m.distanceToSquared(c), t);
                    n < 1e-4 && (n = 1), e < 1e-4 && (e = n), r < 1e-4 && (r = n), qa.initNonuniformCatmullRom(l.x, f.x, m.x, c.x, e, n, r), Xa.initNonuniformCatmullRom(l.y, f.y, m.y, c.y, e, n, r), $a.initNonuniformCatmullRom(l.z, f.z, m.z, c.z, e, n, r)
                } else "catmullrom" === this.curveType && (qa.initCatmullRom(l.x, f.x, m.x, c.x, this.tension), Xa.initCatmullRom(l.y, f.y, m.y, c.y, this.tension), $a.initCatmullRom(l.z, f.z, m.z, c.z, this.tension));
                return n.set(qa.calc(d), Xa.calc(d), $a.calc(d)), n
            }
            copy(source) {
                super.copy(source), this.points = [];
                for (let i = 0, t = source.points.length; i < t; i++) {
                    const t = source.points[i];
                    this.points.push(t.clone())
                }
                return this.closed = source.closed, this.curveType = source.curveType, this.tension = source.tension, this
            }
            toJSON() {
                const data = super.toJSON();
                data.points = [];
                for (let i = 0, t = this.points.length; i < t; i++) {
                    const t = this.points[i];
                    data.points.push(t.toArray())
                }
                return data.closed = this.closed, data.curveType = this.curveType, data.tension = this.tension, data
            }
            fromJSON(t) {
                super.fromJSON(t), this.points = [];
                for (let i = 0, e = t.points.length; i < e; i++) {
                    const e = t.points[i];
                    this.points.push((new Mt).fromArray(e))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }
        }

        function Za(t, e, n, r, o) {
            const l = .5 * (r - e),
                c = .5 * (o - n),
                h = t * t;
            return (2 * n - 2 * r + l + c) * (t * h) + (-3 * n + 3 * r - 2 * l - c) * h + l * t + n
        }

        function Ja(t, e, n, r) {
            return function(t, p) {
                const e = 1 - t;
                return e * e * p
            }(t, e) + function(t, p) {
                return 2 * (1 - t) * t * p
            }(t, n) + function(t, p) {
                return t * t * p
            }(t, r)
        }

        function Ka(t, e, n, r, o) {
            return function(t, p) {
                const e = 1 - t;
                return e * e * e * p
            }(t, e) + function(t, p) {
                const e = 1 - t;
                return 3 * e * e * t * p
            }(t, n) + function(t, p) {
                return 3 * (1 - t) * t * t * p
            }(t, r) + function(t, p) {
                return t * t * t * p
            }(t, o)
        }
        Ya.prototype.isCatmullRomCurve3 = !0;
        class Qa extends Ha {
            constructor(t = new ht, e = new ht, n = new ht, r = new ht) {
                super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
            }
            getPoint(t, e = new ht) {
                const n = e,
                    r = this.v0,
                    o = this.v1,
                    l = this.v2,
                    c = this.v3;
                return n.set(Ka(t, r.x, o.x, l.x, c.x), Ka(t, r.y, o.y, l.y, c.y)), n
            }
            copy(source) {
                return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this.v3.copy(source.v3), this
            }
            toJSON() {
                const data = super.toJSON();
                return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data.v3 = this.v3.toArray(), data
            }
            fromJSON(t) {
                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }
        }
        Qa.prototype.isCubicBezierCurve = !0;
        class ts extends Ha {
            constructor(t = new Mt, e = new Mt, n = new Mt, r = new Mt) {
                super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
            }
            getPoint(t, e = new Mt) {
                const n = e,
                    r = this.v0,
                    o = this.v1,
                    l = this.v2,
                    c = this.v3;
                return n.set(Ka(t, r.x, o.x, l.x, c.x), Ka(t, r.y, o.y, l.y, c.y), Ka(t, r.z, o.z, l.z, c.z)), n
            }
            copy(source) {
                return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this.v3.copy(source.v3), this
            }
            toJSON() {
                const data = super.toJSON();
                return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data.v3 = this.v3.toArray(), data
            }
            fromJSON(t) {
                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }
        }
        ts.prototype.isCubicBezierCurve3 = !0;
        class es extends Ha {
            constructor(t = new ht, e = new ht) {
                super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
            }
            getPoint(t, e = new ht) {
                const n = e;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }
            getPointAt(u, t) {
                return this.getPoint(u, t)
            }
            getTangent(t, e) {
                const n = e || new ht;
                return n.copy(this.v2).sub(this.v1).normalize(), n
            }
            copy(source) {
                return super.copy(source), this.v1.copy(source.v1), this.v2.copy(source.v2), this
            }
            toJSON() {
                const data = super.toJSON();
                return data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data
            }
            fromJSON(t) {
                return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }
        }
        es.prototype.isLineCurve = !0;
        class ns extends Ha {
            constructor(t = new ht, e = new ht, n = new ht) {
                super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
            }
            getPoint(t, e = new ht) {
                const n = e,
                    r = this.v0,
                    o = this.v1,
                    l = this.v2;
                return n.set(Ja(t, r.x, o.x, l.x), Ja(t, r.y, o.y, l.y)), n
            }
            copy(source) {
                return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this
            }
            toJSON() {
                const data = super.toJSON();
                return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data
            }
            fromJSON(t) {
                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }
        }
        ns.prototype.isQuadraticBezierCurve = !0;
        class rs extends Ha {
            constructor(t = new Mt, e = new Mt, n = new Mt) {
                super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
            }
            getPoint(t, e = new Mt) {
                const n = e,
                    r = this.v0,
                    o = this.v1,
                    l = this.v2;
                return n.set(Ja(t, r.x, o.x, l.x), Ja(t, r.y, o.y, l.y), Ja(t, r.z, o.z, l.z)), n
            }
            copy(source) {
                return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this
            }
            toJSON() {
                const data = super.toJSON();
                return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data
            }
            fromJSON(t) {
                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }
        }
        rs.prototype.isQuadraticBezierCurve3 = !0;
        class is extends Ha {
            constructor(t = []) {
                super(), this.type = "SplineCurve", this.points = t
            }
            getPoint(t, e = new ht) {
                const n = e,
                    r = this.points,
                    p = (r.length - 1) * t,
                    o = Math.floor(p),
                    l = p - o,
                    c = r[0 === o ? o : o - 1],
                    h = r[o],
                    d = r[o > r.length - 2 ? r.length - 1 : o + 1],
                    f = r[o > r.length - 3 ? r.length - 1 : o + 2];
                return n.set(Za(l, c.x, h.x, d.x, f.x), Za(l, c.y, h.y, d.y, f.y)), n
            }
            copy(source) {
                super.copy(source), this.points = [];
                for (let i = 0, t = source.points.length; i < t; i++) {
                    const t = source.points[i];
                    this.points.push(t.clone())
                }
                return this
            }
            toJSON() {
                const data = super.toJSON();
                data.points = [];
                for (let i = 0, t = this.points.length; i < t; i++) {
                    const t = this.points[i];
                    data.points.push(t.toArray())
                }
                return data
            }
            fromJSON(t) {
                super.fromJSON(t), this.points = [];
                for (let i = 0, e = t.points.length; i < e; i++) {
                    const e = t.points[i];
                    this.points.push((new ht).fromArray(e))
                }
                return this
            }
        }
        is.prototype.isSplineCurve = !0;
        var os = Object.freeze({
            __proto__: null,
            ArcCurve: Va,
            CatmullRomCurve3: Ya,
            CubicBezierCurve: Qa,
            CubicBezierCurve3: ts,
            EllipseCurve: ja,
            LineCurve: es,
            LineCurve3: class extends Ha {
                constructor(t = new Mt, e = new Mt) {
                    super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
                }
                getPoint(t, e = new Mt) {
                    const n = e;
                    return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                }
                getPointAt(u, t) {
                    return this.getPoint(u, t)
                }
                copy(source) {
                    return super.copy(source), this.v1.copy(source.v1), this.v2.copy(source.v2), this
                }
                toJSON() {
                    const data = super.toJSON();
                    return data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            },
            QuadraticBezierCurve: ns,
            QuadraticBezierCurve3: rs,
            SplineCurve: is
        });
        const as = function(data, t, e = 2) {
            const n = t && t.length,
                r = n ? t[0] * e : data.length;
            let o = ss(data, 0, r, e, !0);
            const l = [];
            if (!o || o.next === o.prev) return l;
            let c, h, d, f, m, v, y;
            if (n && (o = function(data, t, e, n) {
                    const r = [];
                    let i, o, l, c, h;
                    for (i = 0, o = t.length; i < o; i++) l = t[i] * n, c = i < o - 1 ? t[i + 1] * n : data.length, h = ss(data, l, c, n, !1), h === h.next && (h.steiner = !0), r.push(ys(h));
                    for (r.sort(fs), i = 0; i < r.length; i++) ms(r[i], e), e = ls(e, e.next);
                    return e
                }(data, t, o, e)), data.length > 80 * e) {
                c = d = data[0], h = f = data[1];
                for (let i = e; i < r; i += e) m = data[i], v = data[i + 1], m < c && (c = m), v < h && (h = v), m > d && (d = m), v > f && (f = v);
                y = Math.max(d - c, f - h), y = 0 !== y ? 1 / y : 0
            }
            return cs(o, l, e, c, h, y), l
        };

        function ss(data, t, e, n, r) {
            let i, o;
            if (r === function(data, t, e, n) {
                    let r = 0;
                    for (let i = t, o = e - n; i < e; i += n) r += (data[o] - data[i]) * (data[i + 1] + data[o + 1]), o = i;
                    return r
                }(data, t, e, n) > 0)
                for (i = t; i < e; i += n) o = As(i, data[i], data[i + 1], o);
            else
                for (i = e - n; i >= t; i -= n) o = As(i, data[i], data[i + 1], o);
            return o && bs(o, o.next) && (Cs(o), o = o.next), o
        }

        function ls(t, e) {
            if (!t) return t;
            e || (e = t);
            let n, p = t;
            do {
                if (n = !1, p.steiner || !bs(p, p.next) && 0 !== area(p.prev, p, p.next)) p = p.next;
                else {
                    if (Cs(p), p = e = p.prev, p === p.next) break;
                    n = !0
                }
            } while (n || p !== e);
            return e
        }

        function cs(t, e, n, r, o, l, c) {
            if (!t) return;
            !c && l && function(t, e, n, r) {
                let p = t;
                do {
                    null === p.z && (p.z = vs(p.x, p.y, e, n, r)), p.prevZ = p.prev, p.nextZ = p.next, p = p.next
                } while (p !== t);
                p.prevZ.nextZ = null, p.prevZ = null,
                    function(t) {
                        let i, p, q, e, n, r, o, l, c = 1;
                        do {
                            for (p = t, t = null, n = null, r = 0; p;) {
                                for (r++, q = p, o = 0, i = 0; i < c && (o++, q = q.nextZ, q); i++);
                                for (l = c; o > 0 || l > 0 && q;) 0 !== o && (0 === l || !q || p.z <= q.z) ? (e = p, p = p.nextZ, o--) : (e = q, q = q.nextZ, l--), n ? n.nextZ = e : t = e, e.prevZ = n, n = e;
                                p = q
                            }
                            n.nextZ = null, c *= 2
                        } while (r > 1)
                    }(p)
            }(t, r, o, l);
            let h, d, f = t;
            for (; t.prev !== t.next;)
                if (h = t.prev, d = t.next, l ? hs(t, r, o, l) : us(t)) e.push(h.i / n), e.push(t.i / n), e.push(d.i / n), Cs(t), t = d.next, f = d.next;
                else if ((t = d) === f) {
                c ? 1 === c ? cs(t = ds(ls(t), e, n), e, n, r, o, l, 2) : 2 === c && ps(t, e, n, r, o, l) : cs(ls(t), e, n, r, o, l, 1);
                break
            }
        }

        function us(t) {
            const a = t.prev,
                b = t,
                e = t.next;
            if (area(a, b, e) >= 0) return !1;
            let p = t.next.next;
            for (; p !== t.prev;) {
                if (_s(a.x, a.y, b.x, b.y, e.x, e.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
                p = p.next
            }
            return !0
        }

        function hs(t, e, n, r) {
            const a = t.prev,
                b = t,
                o = t.next;
            if (area(a, b, o) >= 0) return !1;
            const l = a.x < b.x ? a.x < o.x ? a.x : o.x : b.x < o.x ? b.x : o.x,
                c = a.y < b.y ? a.y < o.y ? a.y : o.y : b.y < o.y ? b.y : o.y,
                h = a.x > b.x ? a.x > o.x ? a.x : o.x : b.x > o.x ? b.x : o.x,
                d = a.y > b.y ? a.y > o.y ? a.y : o.y : b.y > o.y ? b.y : o.y,
                f = vs(l, c, e, n, r),
                m = vs(h, d, e, n, r);
            let p = t.prevZ,
                v = t.nextZ;
            for (; p && p.z >= f && v && v.z <= m;) {
                if (p !== t.prev && p !== t.next && _s(a.x, a.y, b.x, b.y, o.x, o.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
                if (p = p.prevZ, v !== t.prev && v !== t.next && _s(a.x, a.y, b.x, b.y, o.x, o.y, v.x, v.y) && area(v.prev, v, v.next) >= 0) return !1;
                v = v.nextZ
            }
            for (; p && p.z >= f;) {
                if (p !== t.prev && p !== t.next && _s(a.x, a.y, b.x, b.y, o.x, o.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
                p = p.prevZ
            }
            for (; v && v.z <= m;) {
                if (v !== t.prev && v !== t.next && _s(a.x, a.y, b.x, b.y, o.x, o.y, v.x, v.y) && area(v.prev, v, v.next) >= 0) return !1;
                v = v.nextZ
            }
            return !0
        }

        function ds(t, e, n) {
            let p = t;
            do {
                const a = p.prev,
                    b = p.next.next;
                !bs(a, b) && ws(a, p, p.next, b) && Ts(a, b) && Ts(b, a) && (e.push(a.i / n), e.push(p.i / n), e.push(b.i / n), Cs(p), Cs(p.next), p = t = b), p = p.next
            } while (p !== t);
            return ls(p)
        }

        function ps(t, e, n, r, o, l) {
            let a = t;
            do {
                let b = a.next.next;
                for (; b !== a.prev;) {
                    if (a.i !== b.i && xs(a, b)) {
                        let t = Es(a, b);
                        return a = ls(a, a.next), t = ls(t, t.next), cs(a, e, n, r, o, l), void cs(t, e, n, r, o, l)
                    }
                    b = b.next
                }
                a = a.next
            } while (a !== t)
        }

        function fs(a, b) {
            return a.x - b.x
        }

        function ms(t, e) {
            if (e = function(t, e) {
                    let p = e;
                    const n = t.x,
                        r = t.y;
                    let o, l = -1 / 0;
                    do {
                        if (r <= p.y && r >= p.next.y && p.next.y !== p.y) {
                            const t = p.x + (r - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                            if (t <= n && t > l) {
                                if (l = t, t === n) {
                                    if (r === p.y) return p;
                                    if (r === p.next.y) return p.next
                                }
                                o = p.x < p.next.x ? p : p.next
                            }
                        }
                        p = p.next
                    } while (p !== e);
                    if (!o) return null;
                    if (n === l) return o;
                    const c = o,
                        h = o.x,
                        d = o.y;
                    let f, m = 1 / 0;
                    p = o;
                    do {
                        n >= p.x && p.x >= h && n !== p.x && _s(r < d ? n : l, r, h, d, r < d ? l : n, r, p.x, p.y) && (f = Math.abs(r - p.y) / (n - p.x), Ts(p, t) && (f < m || f === m && (p.x > o.x || p.x === o.x && gs(o, p))) && (o = p, m = f)), p = p.next
                    } while (p !== c);
                    return o
                }(t, e), e) {
                const b = Es(e, t);
                ls(e, e.next), ls(b, b.next)
            }
        }

        function gs(t, p) {
            return area(t.prev, t, p.prev) < 0 && area(p.next, t, t.next) < 0
        }

        function vs(t, e, n, r, o) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * o) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * o) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }

        function ys(t) {
            let p = t,
                e = t;
            do {
                (p.x < e.x || p.x === e.x && p.y < e.y) && (e = p), p = p.next
            } while (p !== t);
            return e
        }

        function _s(t, e, n, r, o, l, c, h) {
            return (o - c) * (e - h) - (t - c) * (l - h) >= 0 && (t - c) * (r - h) - (n - c) * (e - h) >= 0 && (n - c) * (l - h) - (o - c) * (r - h) >= 0
        }

        function xs(a, b) {
            return a.next.i !== b.i && a.prev.i !== b.i && ! function(a, b) {
                let p = a;
                do {
                    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && ws(p, p.next, a, b)) return !0;
                    p = p.next
                } while (p !== a);
                return !1
            }(a, b) && (Ts(a, b) && Ts(b, a) && function(a, b) {
                let p = a,
                    t = !1;
                const e = (a.x + b.x) / 2,
                    n = (a.y + b.y) / 2;
                do {
                    p.y > n != p.next.y > n && p.next.y !== p.y && e < (p.next.x - p.x) * (n - p.y) / (p.next.y - p.y) + p.x && (t = !t), p = p.next
                } while (p !== a);
                return t
            }(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || bs(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0)
        }

        function area(p, q, t) {
            return (q.y - p.y) * (t.x - q.x) - (q.x - p.x) * (t.y - q.y)
        }

        function bs(t, e) {
            return t.x === e.x && t.y === e.y
        }

        function ws(t, e, n, r) {
            const o = Ss(area(t, e, n)),
                l = Ss(area(t, e, r)),
                c = Ss(area(n, r, t)),
                h = Ss(area(n, r, e));
            return o !== l && c !== h || (!(0 !== o || !Ms(t, n, e)) || (!(0 !== l || !Ms(t, r, e)) || (!(0 !== c || !Ms(n, t, r)) || !(0 !== h || !Ms(n, e, r)))))
        }

        function Ms(p, q, t) {
            return q.x <= Math.max(p.x, t.x) && q.x >= Math.min(p.x, t.x) && q.y <= Math.max(p.y, t.y) && q.y >= Math.min(p.y, t.y)
        }

        function Ss(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }

        function Ts(a, b) {
            return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0
        }

        function Es(a, b) {
            const t = new Ls(a.i, a.x, a.y),
                e = new Ls(b.i, b.x, b.y),
                n = a.next,
                r = b.prev;
            return a.next = b, b.prev = a, t.next = n, n.prev = t, e.next = t, t.prev = e, r.next = e, e.prev = r, e
        }

        function As(i, t, e, n) {
            const p = new Ls(i, t, e);
            return n ? (p.next = n.next, p.prev = n, n.next.prev = p, n.next = p) : (p.prev = p, p.next = p), p
        }

        function Cs(p) {
            p.next.prev = p.prev, p.prev.next = p.next, p.prevZ && (p.prevZ.nextZ = p.nextZ), p.nextZ && (p.nextZ.prevZ = p.prevZ)
        }

        function Ls(i, t, e) {
            this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }
        class ks {
            static area(t) {
                const e = t.length;
                let a = 0;
                for (let p = e - 1, q = 0; q < e; p = q++) a += t[p].x * t[q].y - t[q].x * t[p].y;
                return .5 * a
            }
            static isClockWise(t) {
                return ks.area(t) < 0
            }
            static triangulateShape(t, e) {
                const n = [],
                    r = [],
                    o = [];
                Rs(t), Ps(n, t);
                let l = t.length;
                e.forEach(Rs);
                for (let i = 0; i < e.length; i++) r.push(l), l += e[i].length, Ps(n, e[i]);
                const c = as(n, r);
                for (let i = 0; i < c.length; i += 3) o.push(c.slice(i, i + 3));
                return o
            }
        }

        function Rs(t) {
            const e = t.length;
            e > 2 && t[e - 1].equals(t[0]) && t.pop()
        }

        function Ps(t, e) {
            for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
        }
        class Ds extends ln {
            constructor(t, e) {
                super(), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, t = Array.isArray(t) ? t : [t];
                const n = this,
                    r = [],
                    o = [];
                for (let i = 0, e = t.length; i < e; i++) {
                    l(t[i])
                }

                function l(t) {
                    const l = [],
                        c = void 0 !== e.curveSegments ? e.curveSegments : 12,
                        h = void 0 !== e.steps ? e.steps : 1;
                    let d = void 0 !== e.depth ? e.depth : 100,
                        f = void 0 === e.bevelEnabled || e.bevelEnabled,
                        m = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                        v = void 0 !== e.bevelSize ? e.bevelSize : m - 2,
                        y = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                        _ = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                    const x = e.extrudePath,
                        w = void 0 !== e.UVGenerator ? e.UVGenerator : Os;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), d = e.amount);
                    let M, S, T, E, A, C = !1;
                    x && (M = x.getSpacedPoints(h), C = !0, f = !1, S = x.computeFrenetFrames(h, !1), T = new Mt, E = new Mt, A = new Mt), f || (_ = 0, m = 0, v = 0, y = 0);
                    const L = t.extractPoints(c);
                    let k = L.shape;
                    const R = L.holes;
                    if (!ks.isClockWise(k)) {
                        k = k.reverse();
                        for (let t = 0, e = R.length; t < e; t++) {
                            const e = R[t];
                            ks.isClockWise(e) && (R[t] = e.reverse())
                        }
                    }
                    const P = ks.triangulateShape(k, R),
                        D = k;
                    for (let t = 0, e = R.length; t < e; t++) {
                        const e = R[t];
                        k = k.concat(e)
                    }

                    function O(t, e, n) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                    }
                    const I = k.length,
                        N = P.length;

                    function F(t, e, n) {
                        let r, o, l;
                        const c = t.x - e.x,
                            h = t.y - e.y,
                            d = n.x - t.x,
                            f = n.y - t.y,
                            m = c * c + h * h,
                            v = c * f - h * d;
                        if (Math.abs(v) > Number.EPSILON) {
                            const v = Math.sqrt(m),
                                y = Math.sqrt(d * d + f * f),
                                _ = e.x - h / v,
                                x = e.y + c / v,
                                w = ((n.x - f / y - _) * f - (n.y + d / y - x) * d) / (c * f - h * d);
                            r = _ + c * w - t.x, o = x + h * w - t.y;
                            const M = r * r + o * o;
                            if (M <= 2) return new ht(r, o);
                            l = Math.sqrt(M / 2)
                        } else {
                            let t = !1;
                            c > Number.EPSILON ? d > Number.EPSILON && (t = !0) : c < -Number.EPSILON ? d < -Number.EPSILON && (t = !0) : Math.sign(h) === Math.sign(f) && (t = !0), t ? (r = -h, o = c, l = Math.sqrt(m)) : (r = c, o = h, l = Math.sqrt(m / 2))
                        }
                        return new ht(r / l, o / l)
                    }
                    const z = [];
                    for (let i = 0, t = D.length, e = t - 1, n = i + 1; i < t; i++, e++, n++) e === t && (e = 0), n === t && (n = 0), z[i] = F(D[i], D[e], D[n]);
                    const B = [];
                    let U, H = z.concat();
                    for (let t = 0, e = R.length; t < e; t++) {
                        const e = R[t];
                        U = [];
                        for (let i = 0, t = e.length, n = t - 1, r = i + 1; i < t; i++, n++, r++) n === t && (n = 0), r === t && (r = 0), U[i] = F(e[i], e[n], e[r]);
                        B.push(U), H = H.concat(U)
                    }
                    for (let b = 0; b < _; b++) {
                        const t = b / _,
                            e = m * Math.cos(t * Math.PI / 2),
                            n = v * Math.sin(t * Math.PI / 2) + y;
                        for (let i = 0, t = D.length; i < t; i++) {
                            const t = O(D[i], z[i], n);
                            G(t.x, t.y, -e)
                        }
                        for (let t = 0, r = R.length; t < r; t++) {
                            const r = R[t];
                            U = B[t];
                            for (let i = 0, t = r.length; i < t; i++) {
                                const t = O(r[i], U[i], n);
                                G(t.x, t.y, -e)
                            }
                        }
                    }
                    const j = v + y;
                    for (let i = 0; i < I; i++) {
                        const t = f ? O(k[i], H[i], j) : k[i];
                        C ? (E.copy(S.normals[0]).multiplyScalar(t.x), T.copy(S.binormals[0]).multiplyScalar(t.y), A.copy(M[0]).add(E).add(T), G(A.x, A.y, A.z)) : G(t.x, t.y, 0)
                    }
                    for (let s = 1; s <= h; s++)
                        for (let i = 0; i < I; i++) {
                            const t = f ? O(k[i], H[i], j) : k[i];
                            C ? (E.copy(S.normals[s]).multiplyScalar(t.x), T.copy(S.binormals[s]).multiplyScalar(t.y), A.copy(M[s]).add(E).add(T), G(A.x, A.y, A.z)) : G(t.x, t.y, d / h * s)
                        }
                    for (let b = _ - 1; b >= 0; b--) {
                        const t = b / _,
                            e = m * Math.cos(t * Math.PI / 2),
                            n = v * Math.sin(t * Math.PI / 2) + y;
                        for (let i = 0, t = D.length; i < t; i++) {
                            const t = O(D[i], z[i], n);
                            G(t.x, t.y, d + e)
                        }
                        for (let t = 0, r = R.length; t < r; t++) {
                            const r = R[t];
                            U = B[t];
                            for (let i = 0, t = r.length; i < t; i++) {
                                const t = O(r[i], U[i], n);
                                C ? G(t.x, t.y + M[h - 1].y, M[h - 1].x + e) : G(t.x, t.y, d + e)
                            }
                        }
                    }

                    function V(t, e) {
                        let i = t.length;
                        for (; --i >= 0;) {
                            const n = i;
                            let r = i - 1;
                            r < 0 && (r = t.length - 1);
                            for (let s = 0, t = h + 2 * _; s < t; s++) {
                                const t = I * s,
                                    o = I * (s + 1);
                                X(e + n + t, e + r + t, e + r + o, e + n + o)
                            }
                        }
                    }

                    function G(t, e, n) {
                        l.push(t), l.push(e), l.push(n)
                    }

                    function W(a, b, t) {
                        $(a), $(b), $(t);
                        const e = r.length / 3,
                            o = w.generateTopUV(n, r, e - 3, e - 2, e - 1);
                        Y(o[0]), Y(o[1]), Y(o[2])
                    }

                    function X(a, b, t, e) {
                        $(a), $(b), $(e), $(b), $(t), $(e);
                        const o = r.length / 3,
                            l = w.generateSideWallUV(n, r, o - 6, o - 3, o - 2, o - 1);
                        Y(l[0]), Y(l[1]), Y(l[3]), Y(l[1]), Y(l[2]), Y(l[3])
                    }

                    function $(t) {
                        r.push(l[3 * t + 0]), r.push(l[3 * t + 1]), r.push(l[3 * t + 2])
                    }

                    function Y(t) {
                        o.push(t.x), o.push(t.y)
                    }! function() {
                        const t = r.length / 3;
                        if (f) {
                            let t = 0,
                                e = I * t;
                            for (let i = 0; i < N; i++) {
                                const t = P[i];
                                W(t[2] + e, t[1] + e, t[0] + e)
                            }
                            t = h + 2 * _, e = I * t;
                            for (let i = 0; i < N; i++) {
                                const t = P[i];
                                W(t[0] + e, t[1] + e, t[2] + e)
                            }
                        } else {
                            for (let i = 0; i < N; i++) {
                                const t = P[i];
                                W(t[2], t[1], t[0])
                            }
                            for (let i = 0; i < N; i++) {
                                const t = P[i];
                                W(t[0] + I * h, t[1] + I * h, t[2] + I * h)
                            }
                        }
                        n.addGroup(t, r.length / 3 - t, 0)
                    }(),
                    function() {
                        const t = r.length / 3;
                        let e = 0;
                        V(D, e), e += D.length;
                        for (let t = 0, n = R.length; t < n; t++) {
                            const n = R[t];
                            V(n, e), e += n.length
                        }
                        n.addGroup(t, r.length / 3 - t, 1)
                    }()
                }
                this.setAttribute("position", new Ke(r, 3)), this.setAttribute("uv", new Ke(o, 2)), this.computeVertexNormals()
            }
            toJSON() {
                const data = super.toJSON();
                return function(t, e, data) {
                    if (data.shapes = [], Array.isArray(t))
                        for (let i = 0, e = t.length; i < e; i++) {
                            const e = t[i];
                            data.shapes.push(e.uuid)
                        } else data.shapes.push(t.uuid);
                    void 0 !== e.extrudePath && (data.options.extrudePath = e.extrudePath.toJSON());
                    return data
                }(this.parameters.shapes, this.parameters.options, data)
            }
            static fromJSON(data, t) {
                const e = [];
                for (let n = 0, r = data.shapes.length; n < r; n++) {
                    const r = t[data.shapes[n]];
                    e.push(r)
                }
                const n = data.options.extrudePath;
                return void 0 !== n && (data.options.extrudePath = (new os[n.type]).fromJSON(n)), new Ds(e, data.options)
            }
        }
        const Os = {
            generateTopUV: function(t, e, n, r, o) {
                const l = e[3 * n],
                    c = e[3 * n + 1],
                    h = e[3 * r],
                    d = e[3 * r + 1],
                    f = e[3 * o],
                    m = e[3 * o + 1];
                return [new ht(l, c), new ht(h, d), new ht(f, m)]
            },
            generateSideWallUV: function(t, e, n, r, o, l) {
                const c = e[3 * n],
                    h = e[3 * n + 1],
                    d = e[3 * n + 2],
                    f = e[3 * r],
                    m = e[3 * r + 1],
                    v = e[3 * r + 2],
                    y = e[3 * o],
                    _ = e[3 * o + 1],
                    x = e[3 * o + 2],
                    w = e[3 * l],
                    M = e[3 * l + 1],
                    S = e[3 * l + 2];
                return Math.abs(h - m) < Math.abs(c - f) ? [new ht(c, 1 - d), new ht(f, 1 - v), new ht(y, 1 - x), new ht(w, 1 - S)] : [new ht(h, 1 - d), new ht(m, 1 - v), new ht(_, 1 - x), new ht(M, 1 - S)]
            }
        };
        class Is extends ln {
            constructor(t, e = 12) {
                super(), this.type = "ShapeGeometry", this.parameters = {
                    shapes: t,
                    curveSegments: e
                };
                const n = [],
                    r = [],
                    o = [],
                    l = [];
                let c = 0,
                    h = 0;
                if (!1 === Array.isArray(t)) d(t);
                else
                    for (let i = 0; i < t.length; i++) d(t[i]), this.addGroup(c, h, i), c += h, h = 0;

                function d(t) {
                    const c = r.length / 3,
                        d = t.extractPoints(e);
                    let f = d.shape;
                    const m = d.holes;
                    !1 === ks.isClockWise(f) && (f = f.reverse());
                    for (let i = 0, t = m.length; i < t; i++) {
                        const t = m[i];
                        !0 === ks.isClockWise(t) && (m[i] = t.reverse())
                    }
                    const v = ks.triangulateShape(f, m);
                    for (let i = 0, t = m.length; i < t; i++) {
                        const t = m[i];
                        f = f.concat(t)
                    }
                    for (let i = 0, t = f.length; i < t; i++) {
                        const t = f[i];
                        r.push(t.x, t.y, 0), o.push(0, 0, 1), l.push(t.x, t.y)
                    }
                    for (let i = 0, t = v.length; i < t; i++) {
                        const t = v[i],
                            a = t[0] + c,
                            b = t[1] + c,
                            e = t[2] + c;
                        n.push(a, b, e), h += 3
                    }
                }
                this.setIndex(n), this.setAttribute("position", new Ke(r, 3)), this.setAttribute("normal", new Ke(o, 3)), this.setAttribute("uv", new Ke(l, 2))
            }
            toJSON() {
                const data = super.toJSON();
                return function(t, data) {
                    if (data.shapes = [], Array.isArray(t))
                        for (let i = 0, e = t.length; i < e; i++) {
                            const e = t[i];
                            data.shapes.push(e.uuid)
                        } else data.shapes.push(t.uuid);
                    return data
                }(this.parameters.shapes, data)
            }
            static fromJSON(data, t) {
                const e = [];
                for (let n = 0, r = data.shapes.length; n < r; n++) {
                    const r = t[data.shapes[n]];
                    e.push(r)
                }
                return new Is(e, data.curveSegments)
            }
        }
        class Ns extends ln {
            constructor(t = 1, e = 32, n = 16, r = 0, o = 2 * Math.PI, l = 0, c = Math.PI) {
                super(), this.type = "SphereGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: o,
                    thetaStart: l,
                    thetaLength: c
                }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
                const h = Math.min(l + c, Math.PI);
                let d = 0;
                const f = [],
                    m = new Mt,
                    v = new Mt,
                    y = [],
                    _ = [],
                    x = [],
                    w = [];
                for (let y = 0; y <= n; y++) {
                    const M = [],
                        S = y / n;
                    let T = 0;
                    0 == y && 0 == l ? T = .5 / e : y == n && h == Math.PI && (T = -.5 / e);
                    for (let n = 0; n <= e; n++) {
                        const u = n / e;
                        m.x = -t * Math.cos(r + u * o) * Math.sin(l + S * c), m.y = t * Math.cos(l + S * c), m.z = t * Math.sin(r + u * o) * Math.sin(l + S * c), _.push(m.x, m.y, m.z), v.copy(m).normalize(), x.push(v.x, v.y, v.z), w.push(u + T, 1 - S), M.push(d++)
                    }
                    f.push(M)
                }
                for (let t = 0; t < n; t++)
                    for (let r = 0; r < e; r++) {
                        const a = f[t][r + 1],
                            b = f[t][r],
                            e = f[t + 1][r],
                            o = f[t + 1][r + 1];
                        (0 !== t || l > 0) && y.push(a, b, o), (t !== n - 1 || h < Math.PI) && y.push(b, e, o)
                    }
                this.setIndex(y), this.setAttribute("position", new Ke(_, 3)), this.setAttribute("normal", new Ke(x, 3)), this.setAttribute("uv", new Ke(w, 2))
            }
            static fromJSON(data) {
                return new Ns(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength)
            }
        }
        class Fs extends ze {
            constructor(t) {
                super(), this.type = "ShadowMaterial", this.color = new We(0), this.transparent = !0, this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.color.copy(source.color), this
            }
        }
        Fs.prototype.isShadowMaterial = !0;
        class zs extends ze {
            constructor(t) {
                super(), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new We(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new We(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.defines = {
                    STANDARD: ""
                }, this.color.copy(source.color), this.roughness = source.roughness, this.metalness = source.metalness, this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.roughnessMap = source.roughnessMap, this.metalnessMap = source.metalnessMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.envMapIntensity = source.envMapIntensity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.flatShading = source.flatShading, this
            }
        }
        zs.prototype.isMeshStandardMaterial = !0;
        class Bs extends zs {
            constructor(t) {
                super(), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ht(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
                    get: function() {
                        return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                    },
                    set: function(t) {
                        this.reflectivity = at(2.5 * (t - 1) / (t + 1), 0, 1)
                    }
                }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationTint = new We(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularTint = new We(1, 1, 1), this.specularTintMap = null, this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.clearcoat = source.clearcoat, this.clearcoatMap = source.clearcoatMap, this.clearcoatRoughness = source.clearcoatRoughness, this.clearcoatRoughnessMap = source.clearcoatRoughnessMap, this.clearcoatNormalMap = source.clearcoatNormalMap, this.clearcoatNormalScale.copy(source.clearcoatNormalScale), this.reflectivity = source.reflectivity, source.sheen ? this.sheen = (this.sheen || new We).copy(source.sheen) : this.sheen = null, this.transmission = source.transmission, this.transmissionMap = source.transmissionMap, this.thickness = source.thickness, this.thicknessMap = source.thicknessMap, this.attenuationDistance = source.attenuationDistance, this.attenuationTint.copy(source.attenuationTint), this.specularIntensity = source.specularIntensity, this.specularIntensityMap = source.specularIntensityMap, this.specularTint.copy(source.specularTint), this.specularTintMap = source.specularTintMap, this
            }
        }
        Bs.prototype.isMeshPhysicalMaterial = !0;
        class Us extends ze {
            constructor(t) {
                super(), this.type = "MeshPhongMaterial", this.color = new We(16777215), this.specular = new We(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new We(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.color.copy(source.color), this.specular.copy(source.specular), this.shininess = source.shininess, this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.flatShading = source.flatShading, this
            }
        }
        Us.prototype.isMeshPhongMaterial = !0;
        class Hs extends ze {
            constructor(t) {
                super(), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.color = new We(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new We(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.color.copy(source.color), this.map = source.map, this.gradientMap = source.gradientMap, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.alphaMap = source.alphaMap, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this
            }
        }
        Hs.prototype.isMeshToonMaterial = !0;
        class js extends ze {
            constructor(t) {
                super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.flatShading = source.flatShading, this
            }
        }
        js.prototype.isMeshNormalMaterial = !0;
        class Vs extends ze {
            constructor(t) {
                super(), this.type = "MeshLambertMaterial", this.color = new We(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new We(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.color.copy(source.color), this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this
            }
        }
        Vs.prototype.isMeshLambertMaterial = !0;
        class Gs extends ze {
            constructor(t) {
                super(), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new We(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.defines = {
                    MATCAP: ""
                }, this.color.copy(source.color), this.matcap = source.matcap, this.map = source.map, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.alphaMap = source.alphaMap, this.flatShading = source.flatShading, this
            }
        }
        Gs.prototype.isMeshMatcapMaterial = !0;
        class Ws extends wa {
            constructor(t) {
                super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }
            copy(source) {
                return super.copy(source), this.scale = source.scale, this.dashSize = source.dashSize, this.gapSize = source.gapSize, this
            }
        }
        Ws.prototype.isLineDashedMaterial = !0;
        const qs = {
            arraySlice: function(t, e, n) {
                return qs.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
            },
            convertArray: function(t, e, n) {
                return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function(object) {
                return ArrayBuffer.isView(object) && !(object instanceof DataView)
            },
            getKeyframeOrder: function(t) {
                const e = t.length,
                    n = new Array(e);
                for (let i = 0; i !== e; ++i) n[i] = i;
                return n.sort((function(i, e) {
                    return t[i] - t[e]
                })), n
            },
            sortedArray: function(t, e, n) {
                const r = t.length,
                    o = new t.constructor(r);
                for (let i = 0, l = 0; l !== r; ++i) {
                    const r = n[i] * e;
                    for (let n = 0; n !== e; ++n) o[l++] = t[r + n]
                }
                return o
            },
            flattenJSON: function(t, e, n, r) {
                let i = 1,
                    o = t[0];
                for (; void 0 !== o && void 0 === o[r];) o = t[i++];
                if (void 0 === o) return;
                let l = o[r];
                if (void 0 !== l)
                    if (Array.isArray(l))
                        do {
                            l = o[r], void 0 !== l && (e.push(o.time), n.push.apply(n, l)), o = t[i++]
                        } while (void 0 !== o);
                    else if (void 0 !== l.toArray)
                    do {
                        l = o[r], void 0 !== l && (e.push(o.time), l.toArray(n, n.length)), o = t[i++]
                    } while (void 0 !== o);
                else
                    do {
                        l = o[r], void 0 !== l && (e.push(o.time), n.push(l)), o = t[i++]
                    } while (void 0 !== o)
            },
            subclip: function(t, e, n, r, o = 30) {
                const l = t.clone();
                l.name = e;
                const c = [];
                for (let i = 0; i < l.tracks.length; ++i) {
                    const track = l.tracks[i],
                        t = track.getValueSize(),
                        e = [],
                        h = [];
                    for (let l = 0; l < track.times.length; ++l) {
                        const c = track.times[l] * o;
                        if (!(c < n || c >= r)) {
                            e.push(track.times[l]);
                            for (let e = 0; e < t; ++e) h.push(track.values[l * t + e])
                        }
                    }
                    0 !== e.length && (track.times = qs.convertArray(e, track.times.constructor), track.values = qs.convertArray(h, track.values.constructor), c.push(track))
                }
                l.tracks = c;
                let h = 1 / 0;
                for (let i = 0; i < l.tracks.length; ++i) h > l.tracks[i].times[0] && (h = l.tracks[i].times[0]);
                for (let i = 0; i < l.tracks.length; ++i) l.tracks[i].shift(-1 * h);
                return l.resetDuration(), l
            },
            makeClipAdditive: function(t, e = 0, n = t, r = 30) {
                r <= 0 && (r = 30);
                const o = n.tracks.length,
                    l = e / r;
                for (let i = 0; i < o; ++i) {
                    const e = n.tracks[i],
                        r = e.ValueTypeName;
                    if ("bool" === r || "string" === r) continue;
                    const o = t.tracks.find((function(track) {
                        return track.name === e.name && track.ValueTypeName === r
                    }));
                    if (void 0 === o) continue;
                    let c = 0;
                    const h = e.getValueSize();
                    e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                    let d = 0;
                    const f = o.getValueSize();
                    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = f / 3);
                    const m = e.times.length - 1;
                    let v;
                    if (l <= e.times[0]) {
                        const t = c,
                            n = h - c;
                        v = qs.arraySlice(e.values, t, n)
                    } else if (l >= e.times[m]) {
                        const t = m * h + c,
                            n = t + h - c;
                        v = qs.arraySlice(e.values, t, n)
                    } else {
                        const t = e.createInterpolant(),
                            n = c,
                            r = h - c;
                        t.evaluate(l), v = qs.arraySlice(t.resultBuffer, n, r)
                    }
                    if ("quaternion" === r) {
                        (new wt).fromArray(v).normalize().conjugate().toArray(v)
                    }
                    const y = o.times.length;
                    for (let t = 0; t < y; ++t) {
                        const e = t * f + d;
                        if ("quaternion" === r) wt.multiplyQuaternionsFlat(o.values, e, v, 0, o.values, e);
                        else {
                            const t = f - 2 * d;
                            for (let n = 0; n < t; ++n) o.values[e + n] -= v[n]
                        }
                    }
                }
                return t.blendMode = 2501, t
            }
        };
        class Xs {
            constructor(t, e, n, r) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
            }
            evaluate(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex,
                    r = e[n],
                    o = e[n - 1];
                t: {
                    e: {
                        let l;n: {
                            r: if (!(t < r)) {
                                for (let l = n + 2;;) {
                                    if (void 0 === r) {
                                        if (t < o) break r;
                                        return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, o)
                                    }
                                    if (n === l) break;
                                    if (o = r, r = e[++n], t < r) break e
                                }
                                l = e.length;
                                break n
                            }if (t >= o) break t; {
                                const c = e[1];
                                t < c && (n = 2, o = c);
                                for (let l = n - 2;;) {
                                    if (void 0 === o) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                                    if (n === l) break;
                                    if (r = o, o = e[--n - 1], t >= o) break e
                                }
                                l = n, n = 0
                            }
                        }
                        for (; n < l;) {
                            const r = n + l >>> 1;
                            t < e[r] ? l = r : n = r + 1
                        }
                        if (r = e[n], o = e[n - 1], void 0 === o) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                        if (void 0 === r) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, o, t)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, o, r)
                }
                return this.interpolate_(n, o, t, r)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(t) {
                const e = this.resultBuffer,
                    n = this.sampleValues,
                    r = this.valueSize,
                    o = t * r;
                for (let i = 0; i !== r; ++i) e[i] = n[o + i];
                return e
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        Xs.prototype.beforeStart_ = Xs.prototype.copySampleValue_, Xs.prototype.afterEnd_ = Xs.prototype.copySampleValue_;
        class $s extends Xs {
            constructor(t, e, n, r) {
                super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: H,
                    endingEnd: H
                }
            }
            intervalChanged_(t, e, n) {
                const r = this.parameterPositions;
                let o = t - 2,
                    l = t + 1,
                    c = r[o],
                    h = r[l];
                if (void 0 === c) switch (this.getSettings_().endingStart) {
                    case j:
                        o = t, c = 2 * e - n;
                        break;
                    case V:
                        o = r.length - 2, c = e + r[o] - r[o + 1];
                        break;
                    default:
                        o = t, c = n
                }
                if (void 0 === h) switch (this.getSettings_().endingEnd) {
                    case j:
                        l = t, h = 2 * n - e;
                        break;
                    case V:
                        l = 1, h = n + r[1] - r[0];
                        break;
                    default:
                        l = t - 1, h = e
                }
                const d = .5 * (n - e),
                    f = this.valueSize;
                this._weightPrev = d / (e - c), this._weightNext = d / (h - n), this._offsetPrev = o * f, this._offsetNext = l * f
            }
            interpolate_(t, e, n, r) {
                const o = this.resultBuffer,
                    l = this.sampleValues,
                    c = this.valueSize,
                    h = t * c,
                    d = h - c,
                    f = this._offsetPrev,
                    m = this._offsetNext,
                    v = this._weightPrev,
                    y = this._weightNext,
                    p = (n - e) / (r - e),
                    _ = p * p,
                    x = _ * p,
                    w = -v * x + 2 * v * _ - v * p,
                    M = (1 + v) * x + (-1.5 - 2 * v) * _ + (-.5 + v) * p + 1,
                    S = (-1 - y) * x + (1.5 + y) * _ + .5 * p,
                    T = y * x - y * _;
                for (let i = 0; i !== c; ++i) o[i] = w * l[f + i] + M * l[d + i] + S * l[h + i] + T * l[m + i];
                return o
            }
        }
        class Ys extends Xs {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            interpolate_(t, e, n, r) {
                const o = this.resultBuffer,
                    l = this.sampleValues,
                    c = this.valueSize,
                    h = t * c,
                    d = h - c,
                    f = (n - e) / (r - e),
                    m = 1 - f;
                for (let i = 0; i !== c; ++i) o[i] = l[d + i] * m + l[h + i] * f;
                return o
            }
        }
        class Zs extends Xs {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            interpolate_(t) {
                return this.copySampleValue_(t - 1)
            }
        }
        class Js {
            constructor(t, e, n, r) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = qs.convertArray(e, this.TimeBufferType), this.values = qs.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
            }
            static toJSON(track) {
                const t = track.constructor;
                let e;
                if (t.toJSON !== this.toJSON) e = t.toJSON(track);
                else {
                    e = {
                        name: track.name,
                        times: qs.convertArray(track.times, Array),
                        values: qs.convertArray(track.values, Array)
                    };
                    const t = track.getInterpolation();
                    t !== track.DefaultInterpolation && (e.interpolation = t)
                }
                return e.type = track.ValueTypeName, e
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new Zs(this.times, this.values, this.getValueSize(), t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new Ys(this.times, this.values, this.getValueSize(), t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new $s(this.times, this.values, this.getValueSize(), t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                    case z:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case B:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case U:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e), this
                }
                return this.createInterpolant = e, this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return z;
                    case this.InterpolantFactoryMethodLinear:
                        return B;
                    case this.InterpolantFactoryMethodSmooth:
                        return U
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let i = 0, n = e.length; i !== n; ++i) e[i] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t
                }
                return this
            }
            trim(t, e) {
                const n = this.times,
                    r = n.length;
                let o = 0,
                    l = r - 1;
                for (; o !== r && n[o] < t;) ++o;
                for (; - 1 !== l && n[l] > e;) --l;
                if (++l, 0 !== o || l !== r) {
                    o >= l && (l = Math.max(l, 1), o = l - 1);
                    const t = this.getValueSize();
                    this.times = qs.arraySlice(n, o, l), this.values = qs.arraySlice(this.values, o * t, l * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                const n = this.times,
                    r = this.values,
                    o = n.length;
                0 === o && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                let l = null;
                for (let i = 0; i !== o; i++) {
                    const e = n[i];
                    if ("number" == typeof e && isNaN(e)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, e), t = !1;
                        break
                    }
                    if (null !== l && l > e) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, i, e, l), t = !1;
                        break
                    }
                    l = e
                }
                if (void 0 !== r && qs.isTypedArray(r))
                    for (let i = 0, e = r.length; i !== e; ++i) {
                        const e = r[i];
                        if (isNaN(e)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, e), t = !1;
                            break
                        }
                    }
                return t
            }
            optimize() {
                const t = qs.arraySlice(this.times),
                    e = qs.arraySlice(this.values),
                    n = this.getValueSize(),
                    r = this.getInterpolation() === U,
                    o = t.length - 1;
                let l = 1;
                for (let i = 1; i < o; ++i) {
                    let o = !1;
                    const time = t[i];
                    if (time !== t[i + 1] && (1 !== i || time !== t[0]))
                        if (r) o = !0;
                        else {
                            const t = i * n,
                                r = t - n,
                                l = t + n;
                            for (let c = 0; c !== n; ++c) {
                                const n = e[t + c];
                                if (n !== e[r + c] || n !== e[l + c]) {
                                    o = !0;
                                    break
                                }
                            }
                        }
                    if (o) {
                        if (i !== l) {
                            t[l] = t[i];
                            const r = i * n,
                                o = l * n;
                            for (let t = 0; t !== n; ++t) e[o + t] = e[r + t]
                        }++l
                    }
                }
                if (o > 0) {
                    t[l] = t[o];
                    for (let t = o * n, r = l * n, c = 0; c !== n; ++c) e[r + c] = e[t + c];
                    ++l
                }
                return l !== t.length ? (this.times = qs.arraySlice(t, 0, l), this.values = qs.arraySlice(e, 0, l * n)) : (this.times = t, this.values = e), this
            }
            clone() {
                const t = qs.arraySlice(this.times, 0),
                    e = qs.arraySlice(this.values, 0),
                    track = new(0, this.constructor)(this.name, t, e);
                return track.createInterpolant = this.createInterpolant, track
            }
        }
        Js.prototype.TimeBufferType = Float32Array, Js.prototype.ValueBufferType = Float32Array, Js.prototype.DefaultInterpolation = B;
        class Ks extends Js {}
        Ks.prototype.ValueTypeName = "bool", Ks.prototype.ValueBufferType = Array, Ks.prototype.DefaultInterpolation = z, Ks.prototype.InterpolantFactoryMethodLinear = void 0, Ks.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Qs extends Js {}
        Qs.prototype.ValueTypeName = "color";
        class tl extends Js {}
        tl.prototype.ValueTypeName = "number";
        class el extends Xs {
            constructor(t, e, n, r) {
                super(t, e, n, r)
            }
            interpolate_(t, e, n, r) {
                const o = this.resultBuffer,
                    l = this.sampleValues,
                    c = this.valueSize,
                    h = (n - e) / (r - e);
                let d = t * c;
                for (let t = d + c; d !== t; d += 4) wt.slerpFlat(o, 0, l, d - c, l, d, h);
                return o
            }
        }
        class nl extends Js {
            InterpolantFactoryMethodLinear(t) {
                return new el(this.times, this.values, this.getValueSize(), t)
            }
        }
        nl.prototype.ValueTypeName = "quaternion", nl.prototype.DefaultInterpolation = B, nl.prototype.InterpolantFactoryMethodSmooth = void 0;
        class rl extends Js {}
        rl.prototype.ValueTypeName = "string", rl.prototype.ValueBufferType = Array, rl.prototype.DefaultInterpolation = z, rl.prototype.InterpolantFactoryMethodLinear = void 0, rl.prototype.InterpolantFactoryMethodSmooth = void 0;
        class il extends Js {}
        il.prototype.ValueTypeName = "vector";
        class al {
            constructor(t, e = -1, n, r = 2500) {
                this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = ot(), this.duration < 0 && this.resetDuration()
            }
            static parse(t) {
                const e = [],
                    n = t.tracks,
                    r = 1 / (t.fps || 1);
                for (let i = 0, t = n.length; i !== t; ++i) e.push(sl(n[i]).scale(r));
                const o = new this(t.name, t.duration, e, t.blendMode);
                return o.uuid = t.uuid, o
            }
            static toJSON(t) {
                const e = [],
                    n = t.tracks,
                    r = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e,
                        uuid: t.uuid,
                        blendMode: t.blendMode
                    };
                for (let i = 0, t = n.length; i !== t; ++i) e.push(Js.toJSON(n[i]));
                return r
            }
            static CreateFromMorphTargetSequence(t, e, n, r) {
                const o = e.length,
                    l = [];
                for (let i = 0; i < o; i++) {
                    let t = [],
                        c = [];
                    t.push((i + o - 1) % o, i, (i + 1) % o), c.push(0, 1, 0);
                    const h = qs.getKeyframeOrder(t);
                    t = qs.sortedArray(t, 1, h), c = qs.sortedArray(c, 1, h), r || 0 !== t[0] || (t.push(o), c.push(c[0])), l.push(new tl(".morphTargetInfluences[" + e[i].name + "]", t, c).scale(1 / n))
                }
                return new this(t, -1, l)
            }
            static findByName(t, e) {
                let n = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    n = e.geometry && e.geometry.animations || e.animations
                }
                for (let i = 0; i < n.length; i++)
                    if (n[i].name === e) return n[i];
                return null
            }
            static CreateClipsFromMorphTargetSequences(t, e, n) {
                const r = {},
                    pattern = /^([\w-]*?)([\d]+)$/;
                for (let i = 0, e = t.length; i < e; i++) {
                    const e = t[i],
                        n = e.name.match(pattern);
                    if (n && n.length > 1) {
                        const t = n[1];
                        let o = r[t];
                        o || (r[t] = o = []), o.push(e)
                    }
                }
                const o = [];
                for (const t in r) o.push(this.CreateFromMorphTargetSequence(t, r[t], e, n));
                return o
            }
            static parseAnimation(t, e) {
                if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                const n = function(t, e, n, r, o) {
                        if (0 !== n.length) {
                            const l = [],
                                c = [];
                            qs.flattenJSON(n, l, c, r), 0 !== l.length && o.push(new t(e, l, c))
                        }
                    },
                    r = [],
                    o = t.name || "default",
                    l = t.fps || 30,
                    c = t.blendMode;
                let h = t.length || -1;
                const d = t.hierarchy || [];
                for (let t = 0; t < d.length; t++) {
                    const o = d[t].keys;
                    if (o && 0 !== o.length)
                        if (o[0].morphTargets) {
                            const t = {};
                            let e;
                            for (e = 0; e < o.length; e++)
                                if (o[e].morphTargets)
                                    for (let n = 0; n < o[e].morphTargets.length; n++) t[o[e].morphTargets[n]] = -1;
                            for (const n in t) {
                                const t = [],
                                    l = [];
                                for (let r = 0; r !== o[e].morphTargets.length; ++r) {
                                    const r = o[e];
                                    t.push(r.time), l.push(r.morphTarget === n ? 1 : 0)
                                }
                                r.push(new tl(".morphTargetInfluence[" + n + "]", t, l))
                            }
                            h = t.length * (l || 1)
                        } else {
                            const l = ".bones[" + e[t].name + "]";
                            n(il, l + ".position", o, "pos", r), n(nl, l + ".quaternion", o, "rot", r), n(il, l + ".scale", o, "scl", r)
                        }
                }
                if (0 === r.length) return null;
                return new this(o, h, r, c)
            }
            resetDuration() {
                let t = 0;
                for (let i = 0, e = this.tracks.length; i !== e; ++i) {
                    const track = this.tracks[i];
                    t = Math.max(t, track.times[track.times.length - 1])
                }
                return this.duration = t, this
            }
            trim() {
                for (let i = 0; i < this.tracks.length; i++) this.tracks[i].trim(0, this.duration);
                return this
            }
            validate() {
                let t = !0;
                for (let i = 0; i < this.tracks.length; i++) t = t && this.tracks[i].validate();
                return t
            }
            optimize() {
                for (let i = 0; i < this.tracks.length; i++) this.tracks[i].optimize();
                return this
            }
            clone() {
                const t = [];
                for (let i = 0; i < this.tracks.length; i++) t.push(this.tracks[i].clone());
                return new this.constructor(this.name, this.duration, t, this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }

        function sl(t) {
            if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function(t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return tl;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return il;
                    case "color":
                        return Qs;
                    case "quaternion":
                        return nl;
                    case "bool":
                    case "boolean":
                        return Ks;
                    case "string":
                        return rl
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                const e = [],
                    n = [];
                qs.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        }
        const ll = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled) return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        };
        class cl {
            constructor(t, e, n) {
                const r = this;
                let o, l = !1,
                    c = 0,
                    h = 0;
                const d = [];
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                    h++, !1 === l && void 0 !== r.onStart && r.onStart(t, c, h), l = !0
                }, this.itemEnd = function(t) {
                    c++, void 0 !== r.onProgress && r.onProgress(t, c, h), c === h && (l = !1, void 0 !== r.onLoad && r.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== r.onError && r.onError(t)
                }, this.resolveURL = function(t) {
                    return o ? o(t) : t
                }, this.setURLModifier = function(t) {
                    return o = t, this
                }, this.addHandler = function(t, e) {
                    return d.push(t, e), this
                }, this.removeHandler = function(t) {
                    const e = d.indexOf(t);
                    return -1 !== e && d.splice(e, 2), this
                }, this.getHandler = function(t) {
                    for (let i = 0, e = d.length; i < e; i += 2) {
                        const e = d[i],
                            n = d[i + 1];
                        if (e.global && (e.lastIndex = 0), e.test(t)) return n
                    }
                    return null
                }
            }
        }
        const hl = new cl;
        class pl {
            constructor(t) {
                this.manager = void 0 !== t ? t : hl, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            load() {}
            loadAsync(t, e) {
                const n = this;
                return new Promise((function(r, o) {
                    n.load(t, r, e, o)
                }))
            }
            parse() {}
            setCrossOrigin(t) {
                return this.crossOrigin = t, this
            }
            setWithCredentials(t) {
                return this.withCredentials = t, this
            }
            setPath(path) {
                return this.path = path, this
            }
            setResourcePath(t) {
                return this.resourcePath = t, this
            }
            setRequestHeader(t) {
                return this.requestHeader = t, this
            }
        }
        const fl = {};
        class ml extends pl {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const o = this,
                    l = ll.get(t);
                if (void 0 !== l) return o.manager.itemStart(t), setTimeout((function() {
                    e && e(l), o.manager.itemEnd(t)
                }), 0), l;
                if (void 0 !== fl[t]) return void fl[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: r
                });
                const c = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                let h;
                if (c) {
                    const n = c[1],
                        l = !!c[2];
                    let data = c[3];
                    data = decodeURIComponent(data), l && (data = atob(data));
                    try {
                        let r;
                        const l = (this.responseType || "").toLowerCase();
                        switch (l) {
                            case "arraybuffer":
                            case "blob":
                                const view = new Uint8Array(data.length);
                                for (let i = 0; i < data.length; i++) view[i] = data.charCodeAt(i);
                                r = "blob" === l ? new Blob([view.buffer], {
                                    type: n
                                }) : view.buffer;
                                break;
                            case "document":
                                const t = new DOMParser;
                                r = t.parseFromString(data, n);
                                break;
                            case "json":
                                r = JSON.parse(data);
                                break;
                            default:
                                r = data
                        }
                        setTimeout((function() {
                            e && e(r), o.manager.itemEnd(t)
                        }), 0)
                    } catch (e) {
                        setTimeout((function() {
                            r && r(e), o.manager.itemError(t), o.manager.itemEnd(t)
                        }), 0)
                    }
                } else {
                    fl[t] = [], fl[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: r
                    }), h = new XMLHttpRequest, h.open("GET", t, !0), h.addEventListener("load", (function(e) {
                        const n = this.response,
                            r = fl[t];
                        if (delete fl[t], 200 === this.status || 0 === this.status) {
                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), ll.add(t, n);
                            for (let i = 0, t = r.length; i < t; i++) {
                                const t = r[i];
                                t.onLoad && t.onLoad(n)
                            }
                            o.manager.itemEnd(t)
                        } else {
                            for (let i = 0, t = r.length; i < t; i++) {
                                const t = r[i];
                                t.onError && t.onError(e)
                            }
                            o.manager.itemError(t), o.manager.itemEnd(t)
                        }
                    }), !1), h.addEventListener("progress", (function(e) {
                        const n = fl[t];
                        for (let i = 0, t = n.length; i < t; i++) {
                            const t = n[i];
                            t.onProgress && t.onProgress(e)
                        }
                    }), !1), h.addEventListener("error", (function(e) {
                        const n = fl[t];
                        delete fl[t];
                        for (let i = 0, t = n.length; i < t; i++) {
                            const t = n[i];
                            t.onError && t.onError(e)
                        }
                        o.manager.itemError(t), o.manager.itemEnd(t)
                    }), !1), h.addEventListener("abort", (function(e) {
                        const n = fl[t];
                        delete fl[t];
                        for (let i = 0, t = n.length; i < t; i++) {
                            const t = n[i];
                            t.onError && t.onError(e)
                        }
                        o.manager.itemError(t), o.manager.itemEnd(t)
                    }), !1), void 0 !== this.responseType && (h.responseType = this.responseType), void 0 !== this.withCredentials && (h.withCredentials = this.withCredentials), h.overrideMimeType && h.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                    for (const header in this.requestHeader) h.setRequestHeader(header, this.requestHeader[header]);
                    h.send(null)
                }
                return o.manager.itemStart(t), h
            }
            setResponseType(t) {
                return this.responseType = t, this
            }
            setMimeType(t) {
                return this.mimeType = t, this
            }
        }
        class gl extends pl {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const o = this,
                    l = ll.get(t);
                if (void 0 !== l) return o.manager.itemStart(t), setTimeout((function() {
                    e && e(l), o.manager.itemEnd(t)
                }), 0), l;
                const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                function c() {
                    image.removeEventListener("load", c, !1), image.removeEventListener("error", h, !1), ll.add(t, this), e && e(this), o.manager.itemEnd(t)
                }

                function h(e) {
                    image.removeEventListener("load", c, !1), image.removeEventListener("error", h, !1), r && r(e), o.manager.itemError(t), o.manager.itemEnd(t)
                }
                return image.addEventListener("load", c, !1), image.addEventListener("error", h, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (image.crossOrigin = this.crossOrigin), o.manager.itemStart(t), image.src = t, image
            }
        }
        class vl extends pl {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                const o = new Fn,
                    l = new gl(this.manager);
                l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
                let c = 0;

                function h(i) {
                    l.load(t[i], (function(image) {
                        o.images[i] = image, c++, 6 === c && (o.needsUpdate = !0, e && e(o))
                    }), void 0, r)
                }
                for (let i = 0; i < t.length; ++i) h(i);
                return o
            }
        }
        class yl extends pl {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                const o = new vt,
                    l = new gl(this.manager);
                return l.setCrossOrigin(this.crossOrigin), l.setPath(this.path), l.load(t, (function(image) {
                    o.image = image;
                    const n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                    o.format = n ? D : O, o.needsUpdate = !0, void 0 !== e && e(o)
                }), n, r), o
            }
        }
        class _l extends Ha {
            constructor() {
                super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }
            add(t) {
                this.curves.push(t)
            }
            closePath() {
                const t = this.curves[0].getPoint(0),
                    e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new es(e, t))
            }
            getPoint(t) {
                const e = t * this.getLength(),
                    n = this.getCurveLengths();
                let i = 0;
                for (; i < n.length;) {
                    if (n[i] >= e) {
                        const t = n[i] - e,
                            r = this.curves[i],
                            o = r.getLength(),
                            u = 0 === o ? 0 : 1 - t / o;
                        return r.getPointAt(u)
                    }
                    i++
                }
                return null
            }
            getLength() {
                const t = this.getCurveLengths();
                return t[t.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                const t = [];
                let e = 0;
                for (let i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                return this.cacheLengths = t, t
            }
            getSpacedPoints(t = 40) {
                const e = [];
                for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return this.autoClose && e.push(e[0]), e
            }
            getPoints(t = 12) {
                const e = [];
                let n;
                for (let i = 0, r = this.curves; i < r.length; i++) {
                    const o = r[i],
                        l = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t,
                        c = o.getPoints(l);
                    for (let t = 0; t < c.length; t++) {
                        const r = c[t];
                        n && n.equals(r) || (e.push(r), n = r)
                    }
                }
                return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
            }
            copy(source) {
                super.copy(source), this.curves = [];
                for (let i = 0, t = source.curves.length; i < t; i++) {
                    const t = source.curves[i];
                    this.curves.push(t.clone())
                }
                return this.autoClose = source.autoClose, this
            }
            toJSON() {
                const data = super.toJSON();
                data.autoClose = this.autoClose, data.curves = [];
                for (let i = 0, t = this.curves.length; i < t; i++) {
                    const t = this.curves[i];
                    data.curves.push(t.toJSON())
                }
                return data
            }
            fromJSON(t) {
                super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                for (let i = 0, e = t.curves.length; i < e; i++) {
                    const e = t.curves[i];
                    this.curves.push((new os[e.type]).fromJSON(e))
                }
                return this
            }
        }
        class xl extends _l {
            constructor(t) {
                super(), this.type = "Path", this.currentPoint = new ht, t && this.setFromPoints(t)
            }
            setFromPoints(t) {
                this.moveTo(t[0].x, t[0].y);
                for (let i = 1, e = t.length; i < e; i++) this.lineTo(t[i].x, t[i].y);
                return this
            }
            moveTo(t, e) {
                return this.currentPoint.set(t, e), this
            }
            lineTo(t, e) {
                const n = new es(this.currentPoint.clone(), new ht(t, e));
                return this.curves.push(n), this.currentPoint.set(t, e), this
            }
            quadraticCurveTo(t, e, n, r) {
                const o = new ns(this.currentPoint.clone(), new ht(t, e), new ht(n, r));
                return this.curves.push(o), this.currentPoint.set(n, r), this
            }
            bezierCurveTo(t, e, n, r, o, l) {
                const c = new Qa(this.currentPoint.clone(), new ht(t, e), new ht(n, r), new ht(o, l));
                return this.curves.push(c), this.currentPoint.set(o, l), this
            }
            splineThru(t) {
                const e = [this.currentPoint.clone()].concat(t),
                    n = new is(e);
                return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
            }
            arc(t, e, n, r, o, l) {
                const c = this.currentPoint.x,
                    h = this.currentPoint.y;
                return this.absarc(t + c, e + h, n, r, o, l), this
            }
            absarc(t, e, n, r, o, l) {
                return this.absellipse(t, e, n, n, r, o, l), this
            }
            ellipse(t, e, n, r, o, l, c, h) {
                const d = this.currentPoint.x,
                    f = this.currentPoint.y;
                return this.absellipse(t + d, e + f, n, r, o, l, c, h), this
            }
            absellipse(t, e, n, r, o, l, c, h) {
                const d = new ja(t, e, n, r, o, l, c, h);
                if (this.curves.length > 0) {
                    const t = d.getPoint(0);
                    t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                }
                this.curves.push(d);
                const f = d.getPoint(1);
                return this.currentPoint.copy(f), this
            }
            copy(source) {
                return super.copy(source), this.currentPoint.copy(source.currentPoint), this
            }
            toJSON() {
                const data = super.toJSON();
                return data.currentPoint = this.currentPoint.toArray(), data
            }
            fromJSON(t) {
                return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
            }
        }
        class bl extends xl {
            constructor(t) {
                super(t), this.uuid = ot(), this.type = "Shape", this.holes = []
            }
            getPointsHoles(t) {
                const e = [];
                for (let i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                return e
            }
            extractPoints(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            }
            copy(source) {
                super.copy(source), this.holes = [];
                for (let i = 0, t = source.holes.length; i < t; i++) {
                    const t = source.holes[i];
                    this.holes.push(t.clone())
                }
                return this
            }
            toJSON() {
                const data = super.toJSON();
                data.uuid = this.uuid, data.holes = [];
                for (let i = 0, t = this.holes.length; i < t; i++) {
                    const t = this.holes[i];
                    data.holes.push(t.toJSON())
                }
                return data
            }
            fromJSON(t) {
                super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                for (let i = 0, e = t.holes.length; i < e; i++) {
                    const e = t.holes[i];
                    this.holes.push((new xl).fromJSON(e))
                }
                return this
            }
        }
        class wl extends Te {
            constructor(t, e = 1) {
                super(), this.type = "Light", this.color = new We(t), this.intensity = e
            }
            dispose() {}
            copy(source) {
                return super.copy(source), this.color.copy(source.color), this.intensity = source.intensity, this
            }
            toJSON(meta) {
                const data = super.toJSON(meta);
                return data.object.color = this.color.getHex(), data.object.intensity = this.intensity, void 0 !== this.groundColor && (data.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (data.object.distance = this.distance), void 0 !== this.angle && (data.object.angle = this.angle), void 0 !== this.decay && (data.object.decay = this.decay), void 0 !== this.penumbra && (data.object.penumbra = this.penumbra), void 0 !== this.shadow && (data.object.shadow = this.shadow.toJSON()), data
            }
        }
        wl.prototype.isLight = !0;
        class Ml extends wl {
            constructor(t, e, n) {
                super(t, n), this.type = "HemisphereLight", this.position.copy(Te.DefaultUp), this.updateMatrix(), this.groundColor = new We(e)
            }
            copy(source) {
                return wl.prototype.copy.call(this, source), this.groundColor.copy(source.groundColor), this
            }
        }
        Ml.prototype.isHemisphereLight = !0;
        const Sl = new te,
            Tl = new Mt,
            El = new Mt;
        class Al {
            constructor(t) {
                this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new ht(512, 512), this.map = null, this.mapPass = null, this.matrix = new te, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Wn, this._frameExtents = new ht(1, 1), this._viewportCount = 1, this._viewports = [new _t(0, 0, 1, 1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(t) {
                const e = this.camera,
                    n = this.matrix;
                Tl.setFromMatrixPosition(t.matrixWorld), e.position.copy(Tl), El.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(El), e.updateMatrixWorld(), Sl.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Sl), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
            }
            getViewport(t) {
                return this._viewports[t]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
            }
            copy(source) {
                return this.camera = source.camera.clone(), this.bias = source.bias, this.radius = source.radius, this.mapSize.copy(source.mapSize), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const object = {};
                return 0 !== this.bias && (object.bias = this.bias), 0 !== this.normalBias && (object.normalBias = this.normalBias), 1 !== this.radius && (object.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (object.mapSize = this.mapSize.toArray()), object.camera = this.camera.toJSON(!1).object, delete object.camera.matrix, object
            }
        }
        class Cl extends Al {
            constructor() {
                super(new On(50, 1, .5, 500)), this.focus = 1
            }
            updateMatrices(t) {
                const e = this.camera,
                    n = 2 * it * t.angle * this.focus,
                    r = this.mapSize.width / this.mapSize.height,
                    o = t.distance || e.far;
                n === e.fov && r === e.aspect && o === e.far || (e.fov = n, e.aspect = r, e.far = o, e.updateProjectionMatrix()), super.updateMatrices(t)
            }
            copy(source) {
                return super.copy(source), this.focus = source.focus, this
            }
        }
        Cl.prototype.isSpotLightShadow = !0;
        class Ll extends wl {
            constructor(t, e, n = 0, r = Math.PI / 3, o = 0, l = 1) {
                super(t, e), this.type = "SpotLight", this.position.copy(Te.DefaultUp), this.updateMatrix(), this.target = new Te, this.distance = n, this.angle = r, this.penumbra = o, this.decay = l, this.shadow = new Cl
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(source) {
                return super.copy(source), this.distance = source.distance, this.angle = source.angle, this.penumbra = source.penumbra, this.decay = source.decay, this.target = source.target.clone(), this.shadow = source.shadow.clone(), this
            }
        }
        Ll.prototype.isSpotLight = !0;
        const kl = new te,
            Rl = new Mt,
            Pl = new Mt;
        class Dl extends Al {
            constructor() {
                super(new On(90, 1, .5, 500)), this._frameExtents = new ht(4, 2), this._viewportCount = 6, this._viewports = [new _t(2, 1, 1, 1), new _t(0, 1, 1, 1), new _t(3, 1, 1, 1), new _t(1, 1, 1, 1), new _t(3, 0, 1, 1), new _t(1, 0, 1, 1)], this._cubeDirections = [new Mt(1, 0, 0), new Mt(-1, 0, 0), new Mt(0, 0, 1), new Mt(0, 0, -1), new Mt(0, 1, 0), new Mt(0, -1, 0)], this._cubeUps = [new Mt(0, 1, 0), new Mt(0, 1, 0), new Mt(0, 1, 0), new Mt(0, 1, 0), new Mt(0, 0, 1), new Mt(0, 0, -1)]
            }
            updateMatrices(t, e = 0) {
                const n = this.camera,
                    r = this.matrix,
                    o = t.distance || n.far;
                o !== n.far && (n.far = o, n.updateProjectionMatrix()), Rl.setFromMatrixPosition(t.matrixWorld), n.position.copy(Rl), Pl.copy(n.position), Pl.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Pl), n.updateMatrixWorld(), r.makeTranslation(-Rl.x, -Rl.y, -Rl.z), kl.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(kl)
            }
        }
        Dl.prototype.isPointLightShadow = !0;
        class Ol extends wl {
            constructor(t, e, n = 0, r = 1) {
                super(t, e), this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new Dl
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(source) {
                return super.copy(source), this.distance = source.distance, this.decay = source.decay, this.shadow = source.shadow.clone(), this
            }
        }
        Ol.prototype.isPointLight = !0;
        class Il extends Al {
            constructor() {
                super(new or(-5, 5, 5, -5, .5, 500))
            }
        }
        Il.prototype.isDirectionalLightShadow = !0;
        class Nl extends wl {
            constructor(t, e) {
                super(t, e), this.type = "DirectionalLight", this.position.copy(Te.DefaultUp), this.updateMatrix(), this.target = new Te, this.shadow = new Il
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(source) {
                return super.copy(source), this.target = source.target.clone(), this.shadow = source.shadow.clone(), this
            }
        }
        Nl.prototype.isDirectionalLight = !0;
        class Fl extends wl {
            constructor(t, e) {
                super(t, e), this.type = "AmbientLight"
            }
        }
        Fl.prototype.isAmbientLight = !0;
        class zl extends wl {
            constructor(t, e, n = 10, r = 10) {
                super(t, e), this.type = "RectAreaLight", this.width = n, this.height = r
            }
            copy(source) {
                return super.copy(source), this.width = source.width, this.height = source.height, this
            }
            toJSON(meta) {
                const data = super.toJSON(meta);
                return data.object.width = this.width, data.object.height = this.height, data
            }
        }
        zl.prototype.isRectAreaLight = !0;
        class Bl {
            constructor() {
                this.coefficients = [];
                for (let i = 0; i < 9; i++) this.coefficients.push(new Mt)
            }
            set(t) {
                for (let i = 0; i < 9; i++) this.coefficients[i].copy(t[i]);
                return this
            }
            zero() {
                for (let i = 0; i < 9; i++) this.coefficients[i].set(0, 0, 0);
                return this
            }
            getAt(t, e) {
                const n = t.x,
                    r = t.y,
                    o = t.z,
                    l = this.coefficients;
                return e.copy(l[0]).multiplyScalar(.282095), e.addScaledVector(l[1], .488603 * r), e.addScaledVector(l[2], .488603 * o), e.addScaledVector(l[3], .488603 * n), e.addScaledVector(l[4], n * r * 1.092548), e.addScaledVector(l[5], r * o * 1.092548), e.addScaledVector(l[6], .315392 * (3 * o * o - 1)), e.addScaledVector(l[7], n * o * 1.092548), e.addScaledVector(l[8], .546274 * (n * n - r * r)), e
            }
            getIrradianceAt(t, e) {
                const n = t.x,
                    r = t.y,
                    o = t.z,
                    l = this.coefficients;
                return e.copy(l[0]).multiplyScalar(.886227), e.addScaledVector(l[1], 1.023328 * r), e.addScaledVector(l[2], 1.023328 * o), e.addScaledVector(l[3], 1.023328 * n), e.addScaledVector(l[4], .858086 * n * r), e.addScaledVector(l[5], .858086 * r * o), e.addScaledVector(l[6], .743125 * o * o - .247708), e.addScaledVector(l[7], .858086 * n * o), e.addScaledVector(l[8], .429043 * (n * n - r * r)), e
            }
            add(t) {
                for (let i = 0; i < 9; i++) this.coefficients[i].add(t.coefficients[i]);
                return this
            }
            addScaledSH(t, s) {
                for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(t.coefficients[i], s);
                return this
            }
            scale(s) {
                for (let i = 0; i < 9; i++) this.coefficients[i].multiplyScalar(s);
                return this
            }
            lerp(t, e) {
                for (let i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
                return this
            }
            equals(t) {
                for (let i = 0; i < 9; i++)
                    if (!this.coefficients[i].equals(t.coefficients[i])) return !1;
                return !0
            }
            copy(t) {
                return this.set(t.coefficients)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            fromArray(t, e = 0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
                return this
            }
            toArray(t = [], e = 0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
                return t
            }
            static getBasisAt(t, e) {
                const n = t.x,
                    r = t.y,
                    o = t.z;
                e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * o, e[3] = .488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * o, e[6] = .315392 * (3 * o * o - 1), e[7] = 1.092548 * n * o, e[8] = .546274 * (n * n - r * r)
            }
        }
        Bl.prototype.isSphericalHarmonics3 = !0;
        class Ul extends wl {
            constructor(t = new Bl, e = 1) {
                super(void 0, e), this.sh = t
            }
            copy(source) {
                return super.copy(source), this.sh.copy(source.sh), this
            }
            fromJSON(t) {
                return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
            }
            toJSON(meta) {
                const data = super.toJSON(meta);
                return data.object.sh = this.sh.toArray(), data
            }
        }
        Ul.prototype.isLightProbe = !0;
        class Hl {
            static decodeText(t) {
                if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                let s = "";
                for (let i = 0, e = t.length; i < e; i++) s += String.fromCharCode(t[i]);
                try {
                    return decodeURIComponent(escape(s))
                } catch (t) {
                    return s
                }
            }
            static extractUrlBase(t) {
                const e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1)
            }
        }
        class jl extends ln {
            constructor() {
                super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
            }
            copy(source) {
                return super.copy(source), this.instanceCount = source.instanceCount, this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const data = super.toJSON(this);
                return data.instanceCount = this.instanceCount, data.isInstancedBufferGeometry = !0, data
            }
        }
        jl.prototype.isInstancedBufferGeometry = !0;
        class Vl extends Ye {
            constructor(t, e, n, r = 1) {
                "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = r
            }
            copy(source) {
                return super.copy(source), this.meshPerAttribute = source.meshPerAttribute, this
            }
            toJSON() {
                const data = super.toJSON();
                return data.meshPerAttribute = this.meshPerAttribute, data.isInstancedBufferAttribute = !0, data
            }
        }
        Vl.prototype.isInstancedBufferAttribute = !0;
        (class extends pl {
            constructor(t) {
                super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(t) {
                return this.options = t, this
            }
            load(t, e, n, r) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const o = this,
                    l = ll.get(t);
                if (void 0 !== l) return o.manager.itemStart(t), setTimeout((function() {
                    e && e(l), o.manager.itemEnd(t)
                }), 0), l;
                const c = {};
                c.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", c.headers = this.requestHeader, fetch(t, c).then((function(t) {
                    return t.blob()
                })).then((function(t) {
                    return createImageBitmap(t, Object.assign(o.options, {
                        colorSpaceConversion: "none"
                    }))
                })).then((function(n) {
                    ll.add(t, n), e && e(n), o.manager.itemEnd(t)
                })).catch((function(e) {
                    r && r(e), o.manager.itemError(t), o.manager.itemEnd(t)
                })), o.manager.itemStart(t)
            }
        }).prototype.isImageBitmapLoader = !0;
        class Gl {
            constructor() {
                this.type = "ShapePath", this.color = new We, this.subPaths = [], this.currentPath = null
            }
            moveTo(t, e) {
                return this.currentPath = new xl, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
            }
            lineTo(t, e) {
                return this.currentPath.lineTo(t, e), this
            }
            quadraticCurveTo(t, e, n, r) {
                return this.currentPath.quadraticCurveTo(t, e, n, r), this
            }
            bezierCurveTo(t, e, n, r, o, l) {
                return this.currentPath.bezierCurveTo(t, e, n, r, o, l), this
            }
            splineThru(t) {
                return this.currentPath.splineThru(t), this
            }
            toShapes(t, e) {
                function n(t) {
                    const e = [];
                    for (let i = 0, n = t.length; i < n; i++) {
                        const n = t[i],
                            r = new bl;
                        r.curves = n.curves, e.push(r)
                    }
                    return e
                }

                function r(t, e) {
                    const n = e.length;
                    let r = !1;
                    for (let p = n - 1, q = 0; q < n; p = q++) {
                        let n = e[p],
                            o = e[q],
                            l = o.x - n.x,
                            c = o.y - n.y;
                        if (Math.abs(c) > Number.EPSILON) {
                            if (c < 0 && (n = e[q], l = -l, o = e[p], c = -c), t.y < n.y || t.y > o.y) continue;
                            if (t.y === n.y) {
                                if (t.x === n.x) return !0
                            } else {
                                const e = c * (t.x - n.x) - l * (t.y - n.y);
                                if (0 === e) return !0;
                                if (e < 0) continue;
                                r = !r
                            }
                        } else {
                            if (t.y !== n.y) continue;
                            if (o.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= o.x) return !0
                        }
                    }
                    return r
                }
                const o = ks.isClockWise,
                    l = this.subPaths;
                if (0 === l.length) return [];
                if (!0 === e) return n(l);
                let c, h, d;
                const f = [];
                if (1 === l.length) return h = l[0], d = new bl, d.curves = h.curves, f.push(d), f;
                let m = !o(l[0].getPoints());
                m = t ? !m : m;
                const v = [],
                    y = [];
                let _, x, w = [],
                    M = 0;
                y[M] = void 0, w[M] = [];
                for (let i = 0, e = l.length; i < e; i++) h = l[i], _ = h.getPoints(), c = o(_), c = t ? !c : c, c ? (!m && y[M] && M++, y[M] = {
                    s: new bl,
                    p: _
                }, y[M].s.curves = h.curves, m && M++, w[M] = []) : w[M].push({
                    h: h,
                    p: _[0]
                });
                if (!y[0]) return n(l);
                if (y.length > 1) {
                    let t = !1;
                    const e = [];
                    for (let t = 0, e = y.length; t < e; t++) v[t] = [];
                    for (let n = 0, o = y.length; n < o; n++) {
                        const o = w[n];
                        for (let l = 0; l < o.length; l++) {
                            const c = o[l];
                            let h = !0;
                            for (let o = 0; o < y.length; o++) r(c.p, y[o].p) && (n !== o && e.push({
                                froms: n,
                                tos: o,
                                hole: l
                            }), h ? (h = !1, v[o].push(c)) : t = !0);
                            h && v[n].push(c)
                        }
                    }
                    e.length > 0 && (t || (w = v))
                }
                for (let i = 0, t = y.length; i < t; i++) {
                    d = y[i].s, f.push(d), x = w[i];
                    for (let t = 0, e = x.length; t < e; t++) d.holes.push(x[t].h)
                }
                return f
            }
        }
        class Wl {
            constructor(data) {
                this.type = "Font", this.data = data
            }
            generateShapes(text, t = 100) {
                const e = [],
                    n = function(text, t, data) {
                        const e = Array.from(text),
                            n = t / data.resolution,
                            r = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * n,
                            o = [];
                        let l = 0,
                            c = 0;
                        for (let i = 0; i < e.length; i++) {
                            const t = e[i];
                            if ("\n" === t) l = 0, c -= r;
                            else {
                                const e = ql(t, n, l, c, data);
                                l += e.offsetX, o.push(e.path)
                            }
                        }
                        return o
                    }(text, t, this.data);
                for (let p = 0, t = n.length; p < t; p++) Array.prototype.push.apply(e, n[p].toShapes());
                return e
            }
        }

        function ql(t, e, n, r, data) {
            const glyph = data.glyphs[t] || data.glyphs["?"];
            if (!glyph) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + data.familyName + ".");
            const path = new Gl;
            let o, l, c, h, d, f, m, v;
            if (glyph.o) {
                const t = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
                for (let i = 0, y = t.length; i < y;) {
                    switch (t[i++]) {
                        case "m":
                            o = t[i++] * e + n, l = t[i++] * e + r, path.moveTo(o, l);
                            break;
                        case "l":
                            o = t[i++] * e + n, l = t[i++] * e + r, path.lineTo(o, l);
                            break;
                        case "q":
                            c = t[i++] * e + n, h = t[i++] * e + r, d = t[i++] * e + n, f = t[i++] * e + r, path.quadraticCurveTo(d, f, c, h);
                            break;
                        case "b":
                            c = t[i++] * e + n, h = t[i++] * e + r, d = t[i++] * e + n, f = t[i++] * e + r, m = t[i++] * e + n, v = t[i++] * e + r, path.bezierCurveTo(d, f, m, v, c, h)
                    }
                }
            }
            return {
                offsetX: glyph.ha * e,
                path: path
            }
        }
        Wl.prototype.isFont = !0;
        let Xl;
        const $l = function() {
            return void 0 === Xl && (Xl = new(window.AudioContext || window.webkitAudioContext)), Xl
        };
        class Yl extends pl {
            constructor(t) {
                super(t)
            }
            load(t, e, n, r) {
                const o = this,
                    l = new ml(this.manager);
                l.setResponseType("arraybuffer"), l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(t, (function(n) {
                    try {
                        const t = n.slice(0);
                        $l().decodeAudioData(t, (function(t) {
                            e(t)
                        }))
                    } catch (e) {
                        r ? r(e) : console.error(e), o.manager.itemError(t)
                    }
                }), n, r)
            }
        }(class extends Ul {
            constructor(t, e, n = 1) {
                super(void 0, n);
                const r = (new We).set(t),
                    o = (new We).set(e),
                    l = new Mt(r.r, r.g, r.b),
                    c = new Mt(o.r, o.g, o.b),
                    h = Math.sqrt(Math.PI),
                    d = h * Math.sqrt(.75);
                this.sh.coefficients[0].copy(l).add(c).multiplyScalar(h), this.sh.coefficients[1].copy(l).sub(c).multiplyScalar(d)
            }
        }).prototype.isHemisphereLightProbe = !0;
        (class extends Ul {
            constructor(t, e = 1) {
                super(void 0, e);
                const n = (new We).set(t);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
        }).prototype.isAmbientLightProbe = !0;
        class Zl {
            constructor(t = !0) {
                this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            start() {
                this.startTime = Jl(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }
            stop() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(), this.elapsedTime
            }
            getDelta() {
                let t = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    const e = Jl();
                    t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        }

        function Jl() {
            return ("undefined" == typeof performance ? Date : performance).now()
        }
        class Kl extends Te {
            constructor(t) {
                super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            }
            setMediaElementSource(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
            }
            setMediaStreamSource(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
            }
            setBuffer(t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            }
            play(t = 0) {
                if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + t;
                const source = this.context.createBufferSource();
                return source.buffer = this.buffer, source.loop = this.loop, source.loopStart = this.loopStart, source.loopEnd = this.loopEnd, source.onended = this.onEnded.bind(this), source.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = source, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
            }
            pause() {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            stop() {
                if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let i = 1, t = this.filters.length; i < t; i++) this.filters[i - 1].connect(this.filters[i]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this._connected = !0, this
            }
            disconnect() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (let i = 1, t = this.filters.length; i < t; i++) this.filters[i - 1].disconnect(this.filters[i]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this._connected = !1, this
            }
            getFilters() {
                return this.filters
            }
            setFilters(t) {
                return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
            }
            setDetune(t) {
                if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(filter) {
                return this.setFilters(filter ? [filter] : [])
            }
            setPlaybackRate(t) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            }
            setLoop(t) {
                if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            setLoopStart(t) {
                return this.loopStart = t, this
            }
            setLoopEnd(t) {
                return this.loopEnd = t, this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
            }
        }
        class Ql {
            constructor(t, e, n) {
                let r, o, l;
                switch (this.binding = t, this.valueSize = n, e) {
                    case "quaternion":
                        r = this._slerp, o = this._slerpAdditive, l = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        r = this._select, o = this._select, l = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                        break;
                    default:
                        r = this._lerp, o = this._lerpAdditive, l = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = r, this._mixBufferRegionAdditive = o, this._setIdentity = l, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
            }
            accumulate(t, e) {
                const n = this.buffer,
                    r = this.valueSize,
                    o = t * r + r;
                let l = this.cumulativeWeight;
                if (0 === l) {
                    for (let i = 0; i !== r; ++i) n[o + i] = n[i];
                    l = e
                } else {
                    l += e;
                    const t = e / l;
                    this._mixBufferRegion(n, o, 0, t, r)
                }
                this.cumulativeWeight = l
            }
            accumulateAdditive(t) {
                const e = this.buffer,
                    n = this.valueSize,
                    r = n * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t
            }
            apply(t) {
                const e = this.valueSize,
                    n = this.buffer,
                    r = t * e + e,
                    o = this.cumulativeWeight,
                    l = this.cumulativeWeightAdditive,
                    c = this.binding;
                if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o < 1) {
                    const t = e * this._origIndex;
                    this._mixBufferRegion(n, r, t, 1 - o, e)
                }
                l > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
                for (let i = e, t = e + e; i !== t; ++i)
                    if (n[i] !== n[i + e]) {
                        c.setValue(n, r);
                        break
                    }
            }
            saveOriginalState() {
                const t = this.binding,
                    e = this.buffer,
                    n = this.valueSize,
                    r = n * this._origIndex;
                t.getValue(e, r);
                for (let i = n, t = r; i !== t; ++i) e[i] = e[r + i % n];
                this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            }
            _setAdditiveIdentityNumeric() {
                const t = this._addIndex * this.valueSize,
                    e = t + this.valueSize;
                for (let i = t; i < e; i++) this.buffer[i] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const t = this._origIndex * this.valueSize,
                    e = this._addIndex * this.valueSize;
                for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i]
            }
            _select(t, e, n, r, o) {
                if (r >= .5)
                    for (let i = 0; i !== o; ++i) t[e + i] = t[n + i]
            }
            _slerp(t, e, n, r) {
                wt.slerpFlat(t, e, t, e, t, n, r)
            }
            _slerpAdditive(t, e, n, r, o) {
                const l = this._workIndex * o;
                wt.multiplyQuaternionsFlat(t, l, t, e, t, n), wt.slerpFlat(t, e, t, e, t, l, r)
            }
            _lerp(t, e, n, r, o) {
                const s = 1 - r;
                for (let i = 0; i !== o; ++i) {
                    const o = e + i;
                    t[o] = t[o] * s + t[n + i] * r
                }
            }
            _lerpAdditive(t, e, n, r, o) {
                for (let i = 0; i !== o; ++i) {
                    const o = e + i;
                    t[o] = t[o] + t[n + i] * r
                }
            }
        }
        const tc = "\\[\\]\\.:\\/",
            ec = new RegExp("[\\[\\]\\.:\\/]", "g"),
            nc = "[^\\[\\]\\.:\\/]",
            rc = "[^" + tc.replace("\\.", "") + "]",
            ic = /((?:WC+[\/:])*)/.source.replace("WC", nc),
            oc = /(WCOD+)?/.source.replace("WCOD", rc),
            ac = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", nc),
            sc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", nc),
            lc = new RegExp("^" + ic + oc + ac + sc + "$"),
            cc = ["material", "materials", "bones"];
        class uc {
            constructor(t, path, e) {
                this.path = path, this.parsedPath = e || uc.parseTrackName(path), this.node = uc.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
            static create(t, path, e) {
                return t && t.isAnimationObjectGroup ? new uc.Composite(t, path, e) : new uc(t, path, e)
            }
            static sanitizeNodeName(t) {
                return t.replace(/\s/g, "_").replace(ec, "")
            }
            static parseTrackName(t) {
                const e = lc.exec(t);
                if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6]
                    },
                    r = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== r && -1 !== r) {
                    const t = n.nodeName.substring(r + 1); - 1 !== cc.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }
            static findNode(t, e) {
                if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n) return n
                }
                if (t.children) {
                    const n = function(t) {
                            for (let i = 0; i < t.length; i++) {
                                const r = t[i];
                                if (r.name === e || r.uuid === e) return r;
                                const o = n(r.children);
                                if (o) return o
                            }
                            return null
                        },
                        r = n(t.children);
                    if (r) return r
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(t, e) {
                t[e] = this.node[this.propertyName]
            }
            _getValue_array(t, e) {
                const source = this.resolvedProperty;
                for (let i = 0, n = source.length; i !== n; ++i) t[e++] = source[i]
            }
            _getValue_arrayElement(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            _setValue_direct(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }
            _setValue_direct_setNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
            }
            _setValue_array_setNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            _setValue_arrayElement_setNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            _setValue_fromArray_setNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(t, e) {
                this.bind(), this.getValue(t, e)
            }
            _setValue_unbound(t, e) {
                this.bind(), this.setValue(t, e)
            }
            bind() {
                let t = this.node;
                const e = this.parsedPath,
                    n = e.objectName,
                    r = e.propertyName;
                let o = e.propertyIndex;
                if (t || (t = uc.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (n) {
                    let r = e.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            t = t.skeleton.bones;
                            for (let i = 0; i < t.length; i++)
                                if (t[i].name === r) {
                                    r = i;
                                    break
                                }
                            break;
                        default:
                            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            t = t[n]
                    }
                    if (void 0 !== r) {
                        if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[r]
                    }
                }
                const l = t[r];
                if (void 0 === l) {
                    const n = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", t)
                }
                let c = this.Versioning.None;
                this.targetObject = t, void 0 !== t.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                let h = this.BindingType.Direct;
                if (void 0 !== o) {
                    if ("morphTargetInfluences" === r) {
                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                        if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== t.morphTargetDictionary[o] && (o = t.morphTargetDictionary[o])
                    }
                    h = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = o
                } else void 0 !== l.fromArray && void 0 !== l.toArray ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (h = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = r;
                this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][c]
            }
            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }
        uc.Composite = class {
            constructor(t, path, e) {
                const n = e || uc.parseTrackName(path);
                this._targetGroup = t, this._bindings = t.subscribe_(path, n)
            }
            getValue(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_,
                    r = this._bindings[n];
                void 0 !== r && r.getValue(t, e)
            }
            setValue(t, e) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
            }
            bind() {
                const t = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, e = t.length; i !== e; ++i) t[i].bind()
            }
            unbind() {
                const t = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, e = t.length; i !== e; ++i) t[i].unbind()
            }
        }, uc.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, uc.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, uc.prototype.GetterByBindingType = [uc.prototype._getValue_direct, uc.prototype._getValue_array, uc.prototype._getValue_arrayElement, uc.prototype._getValue_toArray], uc.prototype.SetterByBindingTypeAndVersioning = [
            [uc.prototype._setValue_direct, uc.prototype._setValue_direct_setNeedsUpdate, uc.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
            [uc.prototype._setValue_array, uc.prototype._setValue_array_setNeedsUpdate, uc.prototype._setValue_array_setMatrixWorldNeedsUpdate],
            [uc.prototype._setValue_arrayElement, uc.prototype._setValue_arrayElement_setNeedsUpdate, uc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
            [uc.prototype._setValue_fromArray, uc.prototype._setValue_fromArray_setNeedsUpdate, uc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
        ];
        class hc {
            constructor(t, e, n = null, r = e.blendMode) {
                this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = r;
                const o = e.tracks,
                    l = o.length,
                    c = new Array(l),
                    h = {
                        endingStart: H,
                        endingEnd: H
                    };
                for (let i = 0; i !== l; ++i) {
                    const t = o[i].createInterpolant(null);
                    c[i] = t, t.settings = h
                }
                this._interpolantSettings = h, this._interpolants = c, this._propertyBindings = new Array(l), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this), this
            }
            stop() {
                return this._mixer._deactivateAction(this), this.reset()
            }
            reset() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(time) {
                return this._startTime = time, this
            }
            setLoop(t, e) {
                return this.loop = t, this.repetitions = e, this
            }
            setEffectiveWeight(t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(t) {
                return this._scheduleFading(t, 0, 1)
            }
            fadeOut(t) {
                return this._scheduleFading(t, 1, 0)
            }
            crossFadeFrom(t, e, n) {
                if (t.fadeOut(e), this.fadeIn(e), n) {
                    const n = this._clip.duration,
                        r = t._clip.duration,
                        o = r / n,
                        l = n / r;
                    t.warp(1, o, e), this.warp(l, 1, e)
                }
                return this
            }
            crossFadeTo(t, e, n) {
                return t.crossFadeFrom(this, e, n)
            }
            stopFading() {
                const t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }
            setEffectiveTimeScale(t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            }
            syncWith(t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            }
            halt(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            }
            warp(t, e, n) {
                const r = this._mixer,
                    o = r.time,
                    l = this.timeScale;
                let c = this._timeScaleInterpolant;
                null === c && (c = r._lendControlInterpolant(), this._timeScaleInterpolant = c);
                const h = c.parameterPositions,
                    d = c.sampleValues;
                return h[0] = o, h[1] = o + n, d[0] = t / l, d[1] = e / l, this
            }
            stopWarping() {
                const t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(time, t, e, n) {
                if (!this.enabled) return void this._updateWeight(time);
                const r = this._startTime;
                if (null !== r) {
                    const n = (time - r) * e;
                    if (n < 0 || 0 === e) return;
                    this._startTime = null, t = e * n
                }
                t *= this._updateTimeScale(time);
                const o = this._updateTime(t),
                    l = this._updateWeight(time);
                if (l > 0) {
                    const t = this._interpolants,
                        e = this._propertyBindings;
                    if (2501 === this.blendMode)
                        for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(o), e[n].accumulateAdditive(l);
                    else
                        for (let r = 0, c = t.length; r !== c; ++r) t[r].evaluate(o), e[r].accumulate(n, l)
                }
            }
            _updateWeight(time) {
                let t = 0;
                if (this.enabled) {
                    t = this.weight;
                    const e = this._weightInterpolant;
                    if (null !== e) {
                        const n = e.evaluate(time)[0];
                        t *= n, time > e.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = t, t
            }
            _updateTimeScale(time) {
                let t = 0;
                if (!this.paused) {
                    t = this.timeScale;
                    const e = this._timeScaleInterpolant;
                    if (null !== e) {
                        t *= e.evaluate(time)[0], time > e.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                    }
                }
                return this._effectiveTimeScale = t, t
            }
            _updateTime(t) {
                const e = this._clip.duration,
                    n = this.loop;
                let time = this.time + t,
                    r = this._loopCount;
                const o = 2202 === n;
                if (0 === t) return -1 === r ? time : o && 1 == (1 & r) ? e - time : time;
                if (2200 === n) {
                    -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    t: {
                        if (time >= e) time = e;
                        else {
                            if (!(time < 0)) {
                                this.time = time;
                                break t
                            }
                            time = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = time,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), time >= e || time < 0) {
                        const n = Math.floor(time / e);
                        time -= e * n, r += Math.abs(n);
                        const l = this.repetitions - r;
                        if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, time = t > 0 ? e : 0, this.time = time, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        });
                        else {
                            if (1 === l) {
                                const e = t < 0;
                                this._setEndings(e, !e, o)
                            } else this._setEndings(!1, !1, o);
                            this._loopCount = r, this.time = time, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: n
                            })
                        }
                    } else this.time = time;
                    if (o && 1 == (1 & r)) return e - time
                }
                return time
            }
            _setEndings(t, e, n) {
                const r = this._interpolantSettings;
                n ? (r.endingStart = j, r.endingEnd = j) : (r.endingStart = t ? this.zeroSlopeAtStart ? j : H : V, r.endingEnd = e ? this.zeroSlopeAtEnd ? j : H : V)
            }
            _scheduleFading(t, e, n) {
                const r = this._mixer,
                    o = r.time;
                let l = this._weightInterpolant;
                null === l && (l = r._lendControlInterpolant(), this._weightInterpolant = l);
                const c = l.parameterPositions,
                    h = l.sampleValues;
                return c[0] = o, h[0] = e, c[1] = o + t, h[1] = n, this
            }
        }(class extends tt {
            constructor(t) {
                super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }
            _bindAction(t, e) {
                const n = t._localRoot || this._root,
                    r = t._clip.tracks,
                    o = r.length,
                    l = t._propertyBindings,
                    c = t._interpolants,
                    h = n.uuid,
                    d = this._bindingsByRootAndName;
                let f = d[h];
                void 0 === f && (f = {}, d[h] = f);
                for (let i = 0; i !== o; ++i) {
                    const track = r[i],
                        t = track.name;
                    let o = f[t];
                    if (void 0 !== o) l[i] = o;
                    else {
                        if (o = l[i], void 0 !== o) {
                            null === o._cacheIndex && (++o.referenceCount, this._addInactiveBinding(o, h, t));
                            continue
                        }
                        const path = e && e._propertyBindings[i].binding.parsedPath;
                        o = new Ql(uc.create(n, t, path), track.ValueTypeName, track.getValueSize()), ++o.referenceCount, this._addInactiveBinding(o, h, t), l[i] = o
                    }
                    c[i].resultBuffer = o.buffer
                }
            }
            _activateAction(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        const e = (t._localRoot || this._root).uuid,
                            n = t._clip.uuid,
                            r = this._actionsByClip[n];
                        this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e)
                    }
                    const e = t._propertyBindings;
                    for (let i = 0, t = e.length; i !== t; ++i) {
                        const t = e[i];
                        0 == t.useCount++ && (this._lendBinding(t), t.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            }
            _deactivateAction(t) {
                if (this._isActiveAction(t)) {
                    const e = t._propertyBindings;
                    for (let i = 0, t = e.length; i !== t; ++i) {
                        const t = e[i];
                        0 == --t.useCount && (t.restoreOriginalState(), this._takeBackBinding(t))
                    }
                    this._takeBackAction(t)
                }
            }
            _initMemoryManager() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                const t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(t) {
                const e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            }
            _addInactiveAction(t, e, n) {
                const r = this._actions,
                    o = this._actionsByClip;
                let l = o[e];
                if (void 0 === l) l = {
                    knownActions: [t],
                    actionByRoot: {}
                }, t._byClipCacheIndex = 0, o[e] = l;
                else {
                    const e = l.knownActions;
                    t._byClipCacheIndex = e.length, e.push(t)
                }
                t._cacheIndex = r.length, r.push(t), l.actionByRoot[n] = t
            }
            _removeInactiveAction(t) {
                const e = this._actions,
                    n = e[e.length - 1],
                    r = t._cacheIndex;
                n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
                const o = t._clip.uuid,
                    l = this._actionsByClip,
                    c = l[o],
                    h = c.knownActions,
                    d = h[h.length - 1],
                    f = t._byClipCacheIndex;
                d._byClipCacheIndex = f, h[f] = d, h.pop(), t._byClipCacheIndex = null;
                delete c.actionByRoot[(t._localRoot || this._root).uuid], 0 === h.length && delete l[o], this._removeInactiveBindingsForAction(t)
            }
            _removeInactiveBindingsForAction(t) {
                const e = t._propertyBindings;
                for (let i = 0, t = e.length; i !== t; ++i) {
                    const t = e[i];
                    0 == --t.referenceCount && this._removeInactiveBinding(t)
                }
            }
            _lendAction(t) {
                const e = this._actions,
                    n = t._cacheIndex,
                    r = this._nActiveActions++,
                    o = e[r];
                t._cacheIndex = r, e[r] = t, o._cacheIndex = n, e[n] = o
            }
            _takeBackAction(t) {
                const e = this._actions,
                    n = t._cacheIndex,
                    r = --this._nActiveActions,
                    o = e[r];
                t._cacheIndex = r, e[r] = t, o._cacheIndex = n, e[n] = o
            }
            _addInactiveBinding(t, e, n) {
                const r = this._bindingsByRootAndName,
                    o = this._bindings;
                let l = r[e];
                void 0 === l && (l = {}, r[e] = l), l[n] = t, t._cacheIndex = o.length, o.push(t)
            }
            _removeInactiveBinding(t) {
                const e = this._bindings,
                    n = t.binding,
                    r = n.rootNode.uuid,
                    o = n.path,
                    l = this._bindingsByRootAndName,
                    c = l[r],
                    h = e[e.length - 1],
                    d = t._cacheIndex;
                h._cacheIndex = d, e[d] = h, e.pop(), delete c[o], 0 === Object.keys(c).length && delete l[r]
            }
            _lendBinding(t) {
                const e = this._bindings,
                    n = t._cacheIndex,
                    r = this._nActiveBindings++,
                    o = e[r];
                t._cacheIndex = r, e[r] = t, o._cacheIndex = n, e[n] = o
            }
            _takeBackBinding(t) {
                const e = this._bindings,
                    n = t._cacheIndex,
                    r = --this._nActiveBindings,
                    o = e[r];
                t._cacheIndex = r, e[r] = t, o._cacheIndex = n, e[n] = o
            }
            _lendControlInterpolant() {
                const t = this._controlInterpolants,
                    e = this._nActiveControlInterpolants++;
                let n = t[e];
                return void 0 === n && (n = new Ys(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
            }
            _takeBackControlInterpolant(t) {
                const e = this._controlInterpolants,
                    n = t.__cacheIndex,
                    r = --this._nActiveControlInterpolants,
                    o = e[r];
                t.__cacheIndex = r, e[r] = t, o.__cacheIndex = n, e[n] = o
            }
            clipAction(t, e, n) {
                const r = e || this._root,
                    o = r.uuid;
                let l = "string" == typeof t ? al.findByName(r, t) : t;
                const c = null !== l ? l.uuid : t,
                    h = this._actionsByClip[c];
                let d = null;
                if (void 0 === n && (n = null !== l ? l.blendMode : G), void 0 !== h) {
                    const t = h.actionByRoot[o];
                    if (void 0 !== t && t.blendMode === n) return t;
                    d = h.knownActions[0], null === l && (l = d._clip)
                }
                if (null === l) return null;
                const f = new hc(this, l, e, n);
                return this._bindAction(f, d), this._addInactiveAction(f, c, o), f
            }
            existingAction(t, e) {
                const n = e || this._root,
                    r = n.uuid,
                    o = "string" == typeof t ? al.findByName(n, t) : t,
                    l = o ? o.uuid : t,
                    c = this._actionsByClip[l];
                return void 0 !== c && c.actionByRoot[r] || null
            }
            stopAllAction() {
                const t = this._actions;
                for (let i = this._nActiveActions - 1; i >= 0; --i) t[i].stop();
                return this
            }
            update(t) {
                t *= this.timeScale;
                const e = this._actions,
                    n = this._nActiveActions,
                    time = this.time += t,
                    r = Math.sign(t),
                    o = this._accuIndex ^= 1;
                for (let i = 0; i !== n; ++i) {
                    e[i]._update(time, t, r, o)
                }
                const l = this._bindings,
                    c = this._nActiveBindings;
                for (let i = 0; i !== c; ++i) l[i].apply(o);
                return this
            }
            setTime(t) {
                this.time = 0;
                for (let i = 0; i < this._actions.length; i++) this._actions[i].time = 0;
                return this.update(t)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(t) {
                const e = this._actions,
                    n = t.uuid,
                    r = this._actionsByClip,
                    o = r[n];
                if (void 0 !== o) {
                    const t = o.knownActions;
                    for (let i = 0, n = t.length; i !== n; ++i) {
                        const n = t[i];
                        this._deactivateAction(n);
                        const r = n._cacheIndex,
                            o = e[e.length - 1];
                        n._cacheIndex = null, n._byClipCacheIndex = null, o._cacheIndex = r, e[r] = o, e.pop(), this._removeInactiveBindingsForAction(n)
                    }
                    delete r[n]
                }
            }
            uncacheRoot(t) {
                const e = t.uuid,
                    n = this._actionsByClip;
                for (const t in n) {
                    const r = n[t].actionByRoot[e];
                    void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                }
                const r = this._bindingsByRootAndName[e];
                if (void 0 !== r)
                    for (const t in r) {
                        const e = r[t];
                        e.restoreOriginalState(), this._removeInactiveBinding(e)
                    }
            }
            uncacheAction(t, e) {
                const n = this.existingAction(t, e);
                null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        }).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
        class dc {
            constructor(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
            }
            clone() {
                return new dc(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }(class extends Go {
            constructor(t, e, n = 1) {
                super(t, e), this.meshPerAttribute = n
            }
            copy(source) {
                return super.copy(source), this.meshPerAttribute = source.meshPerAttribute, this
            }
            clone(data) {
                const t = super.clone(data);
                return t.meshPerAttribute = this.meshPerAttribute, t
            }
            toJSON(data) {
                const t = super.toJSON(data);
                return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
            }
        }).prototype.isInstancedInterleavedBuffer = !0;
        const pc = new ht;
        class fc {
            constructor(t = new ht(1 / 0, 1 / 0), e = new ht(-1 / 0, -1 / 0)) {
                this.min = t, this.max = e
            }
            set(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let i = 0, e = t.length; i < e; i++) this.expandByPoint(t[i]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = pc.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t), this.max.max(t), this
            }
            expandByVector(t) {
                return this.min.sub(t), this.max.add(t), this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return pc.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            intersect(t) {
                return this.min.max(t.min), this.max.min(t.max), this
            }
            union(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }
            translate(t) {
                return this.min.add(t), this.max.add(t), this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        fc.prototype.isBox2 = !0;
        (class extends Te {
            constructor(t) {
                super(), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
            }
        }).prototype.isImmediateRenderObject = !0;
        const mc = new Mt,
            gc = new te,
            vc = new te;

        function yc(object) {
            const t = [];
            object && object.isBone && t.push(object);
            for (let i = 0; i < object.children.length; i++) t.push.apply(t, yc(object.children[i]));
            return t
        }
        class _c extends En {
            constructor(t, e, n) {
                super(new Ns(e, 4, 2), new qe({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                })), this.light = t, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }
            dispose() {
                this.geometry.dispose(), this.material.dispose()
            }
            update() {
                void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }
        }
        const xc = new Float32Array(1);
        new Int32Array(xc.buffer);
        Ha.create = function(t, e) {
            return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ha.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
        }, xl.prototype.fromPoints = function(t) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
        }, class extends Ra {
            constructor(t = 10, e = 10, n = 4473924, r = 8947848) {
                n = new We(n), r = new We(r);
                const o = e / 2,
                    l = t / e,
                    c = t / 2,
                    h = [],
                    d = [];
                for (let i = 0, t = 0, f = -c; i <= e; i++, f += l) {
                    h.push(-c, 0, f, c, 0, f), h.push(f, 0, -c, f, 0, c);
                    const e = i === o ? n : r;
                    e.toArray(d, t), t += 3, e.toArray(d, t), t += 3, e.toArray(d, t), t += 3, e.toArray(d, t), t += 3
                }
                const f = new ln;
                f.setAttribute("position", new Ke(h, 3)), f.setAttribute("color", new Ke(d, 3));
                super(f, new wa({
                    vertexColors: !0,
                    toneMapped: !1
                })), this.type = "GridHelper"
            }
        }.prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, class extends Ra {
            constructor(object) {
                const t = yc(object),
                    e = new ln,
                    n = [],
                    r = [],
                    o = new We(0, 0, 1),
                    l = new We(0, 1, 0);
                for (let i = 0; i < t.length; i++) {
                    const e = t[i];
                    e.parent && e.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(l.r, l.g, l.b))
                }
                e.setAttribute("position", new Ke(n, 3)), e.setAttribute("color", new Ke(r, 3));
                super(e, new wa({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = object, this.bones = t, this.matrix = object.matrixWorld, this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(t) {
                const e = this.bones,
                    n = this.geometry,
                    r = n.getAttribute("position");
                vc.copy(this.root.matrixWorld).invert();
                for (let i = 0, t = 0; i < e.length; i++) {
                    const n = e[i];
                    n.parent && n.parent.isBone && (gc.multiplyMatrices(vc, n.matrixWorld), mc.setFromMatrixPosition(gc), r.setXYZ(t, mc.x, mc.y, mc.z), gc.multiplyMatrices(vc, n.parent.matrixWorld), mc.setFromMatrixPosition(gc), r.setXYZ(t + 1, mc.x, mc.y, mc.z), t += 2)
                }
                n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
            }
        }.prototype.update = function() {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }, pl.prototype.extractUrlBase = function(t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Hl.extractUrlBase(t)
        }, pl.Handlers = {
            add: function() {
                console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
            },
            get: function() {
                console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
            }
        }, fc.prototype.center = function(t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, fc.prototype.empty = function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, fc.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        }, fc.prototype.size = function(t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
        }, Et.prototype.center = function(t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, Et.prototype.empty = function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, Et.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        }, Et.prototype.isIntersectionSphere = function(t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }, Et.prototype.size = function(t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
        }, Wt.prototype.empty = function() {
            return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, Wn.prototype.setFromMatrix = function(t) {
            return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
        }, pt.prototype.flattenToArrayOffset = function(t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        }, pt.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        }, pt.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        }, pt.prototype.applyToBufferAttribute = function(t) {
            return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        }, pt.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }, pt.prototype.getInverse = function(t) {
            return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
        }, te.prototype.extractPosition = function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
        }, te.prototype.flattenToArrayOffset = function(t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        }, te.prototype.getPosition = function() {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Mt).setFromMatrixColumn(this, 3)
        }, te.prototype.setRotationFromQuaternion = function(q) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(q)
        }, te.prototype.multiplyToArray = function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        }, te.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, te.prototype.multiplyVector4 = function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, te.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        }, te.prototype.rotateAxis = function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
        }, te.prototype.crossVector = function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, te.prototype.translate = function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        }, te.prototype.rotateX = function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        }, te.prototype.rotateY = function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        }, te.prototype.rotateZ = function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        }, te.prototype.rotateByAxis = function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        }, te.prototype.applyToBufferAttribute = function(t) {
            return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, te.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        }, te.prototype.makeFrustum = function(t, e, n, r, o, l) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, o, l)
        }, te.prototype.getInverse = function(t) {
            return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
        }, jn.prototype.isIntersectionLine = function(line) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(line)
        }, wt.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
        }, wt.prototype.inverse = function() {
            return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
        }, Qt.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        }, Qt.prototype.isIntersectionPlane = function(t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
        }, Qt.prototype.isIntersectionSphere = function(t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }, Ne.prototype.area = function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        }, Ne.prototype.barycoordFromPoint = function(t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
        }, Ne.prototype.midpoint = function(t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
        }, Ne.prototypenormal = function(t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
        }, Ne.prototype.plane = function(t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
        }, Ne.barycoordFromPoint = function(t, a, b, e, n) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Ne.getBarycoord(t, a, b, e, n)
        }, Ne.normal = function(a, b, t, e) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Ne.getNormal(a, b, t, e)
        }, bl.prototype.extractAllPoints = function(t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
        }, bl.prototype.extrude = function(t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Ds(this, t)
        }, bl.prototype.makeGeometry = function(t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Is(this, t)
        }, ht.prototype.fromAttribute = function(t, e, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        }, ht.prototype.distanceToManhattan = function(t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        }, ht.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, Mt.prototype.setEulerFromRotationMatrix = function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        }, Mt.prototype.setEulerFromQuaternion = function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        }, Mt.prototype.getPositionFromMatrix = function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
        }, Mt.prototype.getScaleFromMatrix = function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
        }, Mt.prototype.getColumnFromMatrix = function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
        }, Mt.prototype.applyProjection = function(t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
        }, Mt.prototype.fromAttribute = function(t, e, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        }, Mt.prototype.distanceToManhattan = function(t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        }, Mt.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, _t.prototype.fromAttribute = function(t, e, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        }, _t.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, Te.prototype.getChildByName = function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
        }, Te.prototype.renderDepth = function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        }, Te.prototype.translate = function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
        }, Te.prototype.getWorldRotation = function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }, Te.prototype.applyMatrix = function(t) {
            return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
        }, Object.defineProperties(Te.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                },
                set: function(t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), En.prototype.setDrawMode = function() {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }, Object.defineProperties(En.prototype, {
            drawMode: {
                get: function() {
                    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                },
                set: function() {
                    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }
        }), fa.prototype.initBones = function() {
            console.error("THREE.SkinnedMesh: initBones() has been removed.")
        }, On.prototype.setLens = function(t, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }, Object.defineProperties(wl.prototype, {
            onlyShadow: {
                set: function() {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function() {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function() {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                }
            }
        }), Object.defineProperties(Ye.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            },
            dynamic: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === K
                },
                set: function() {
                    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(K)
                }
            }
        }), Ye.prototype.setDynamic = function(t) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? K : J), this
        }, Ye.prototype.copyIndicesArray = function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }, Ye.prototype.setArray = function() {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }, ln.prototype.addIndex = function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
        }, ln.prototype.addAttribute = function(t, e) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Ye(arguments[1], arguments[2])))
        }, ln.prototype.addDrawCall = function(t, e, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
        }, ln.prototype.clearDrawCalls = function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        }, ln.prototype.computeOffsets = function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }, ln.prototype.removeAttribute = function(t) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
        }, ln.prototype.applyMatrix = function(t) {
            return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
        }, Object.defineProperties(ln.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), Go.prototype.setDynamic = function(t) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? K : J), this
        }, Go.prototype.setArray = function() {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }, Ds.prototype.getArrays = function() {
            console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
        }, Ds.prototype.addShapeList = function() {
            console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
        }, Ds.prototype.addShape = function() {
            console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
        }, Vo.prototype.dispose = function() {
            console.error("THREE.Scene: .dispose() has been removed.")
        }, dc.prototype.onUpdate = function() {
            return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
        }, Object.defineProperties(ze.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            overdraw: {
                get: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE.Material: .wrapRGB has been removed."), new We
                }
            },
            shading: {
                get: function() {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                }
            },
            stencilMask: {
                get: function() {
                    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
                }
            },
            vertexTangents: {
                get: function() {
                    console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                },
                set: function() {
                    console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                }
            }
        }), Object.defineProperties(Pn.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                },
                set: function(t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                }
            }
        }), Uo.prototype.clearTarget = function(t, e, n, r) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r)
        }, Uo.prototype.animate = function(t) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
        }, Uo.prototype.getCurrentRenderTarget = function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        }, Uo.prototype.getMaxAnisotropy = function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        }, Uo.prototype.getPrecision = function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        }, Uo.prototype.resetGLState = function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        }, Uo.prototype.supportsFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        }, Uo.prototype.supportsHalfFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        }, Uo.prototype.supportsStandardDerivatives = function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        }, Uo.prototype.supportsCompressedTextureS3TC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        }, Uo.prototype.supportsCompressedTexturePVRTC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        }, Uo.prototype.supportsBlendMinMax = function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        }, Uo.prototype.supportsVertexTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        }, Uo.prototype.supportsInstancedArrays = function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        }, Uo.prototype.enableScissorTest = function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
        }, Uo.prototype.initMaterial = function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }, Uo.prototype.addPrePlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }, Uo.prototype.addPostPlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }, Uo.prototype.updateShadowMap = function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }, Uo.prototype.setFaceCulling = function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }, Uo.prototype.allocTextureUnit = function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        }, Uo.prototype.setTexture = function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        }, Uo.prototype.setTexture2D = function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        }, Uo.prototype.setTextureCube = function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        }, Uo.prototype.getActiveMipMapLevel = function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
        }, Object.defineProperties(Uo.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            context: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                }
            },
            vr: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                }
            },
            gammaInput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                }
            },
            gammaOutput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? X : W
                }
            },
            toneMappingWhitePoint: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                }
            }
        }), Object.defineProperties(ko.prototype, {
            cullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            renderReverseSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            },
            renderSingleSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }), Object.defineProperties(xt.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                }
            }
        }), Kl.prototype.load = function(t) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            const e = this;
            return (new Yl).load(t, (function(t) {
                e.setBuffer(t)
            })), this
        }, Nn.prototype.updateCubeMap = function(t, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
        }, Nn.prototype.clear = function(t, e, n, r) {
            return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, r)
        }, mt.crossOrigin = void 0, mt.loadTexture = function(t, e, n, r) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            const o = new yl;
            o.setCrossOrigin(this.crossOrigin);
            const l = o.load(t, n, void 0, r);
            return e && (l.mapping = e), l
        }, mt.loadTextureCube = function(t, e, n, r) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            const o = new vl;
            o.setCrossOrigin(this.crossOrigin);
            const l = o.load(t, n, void 0, r);
            return e && (l.mapping = e), l
        }, mt.loadCompressedTexture = function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }, mt.loadCompressedTextureCube = function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        };
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: "131"
            }
        })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "131")
    }, function(t, e, n) {
        "use strict";
        n.d(e, "k", (function() {
            return _
        })), n.d(e, "m", (function() {
            return x
        })), n.d(e, "l", (function() {
            return w
        })), n.d(e, "e", (function() {
            return M
        })), n.d(e, "b", (function() {
            return S
        })), n.d(e, "s", (function() {
            return T
        })), n.d(e, "g", (function() {
            return E
        })), n.d(e, "h", (function() {
            return A
        })), n.d(e, "d", (function() {
            return C
        })), n.d(e, "r", (function() {
            return L
        })), n.d(e, "j", (function() {
            return k
        })), n.d(e, "t", (function() {
            return P
        })), n.d(e, "o", (function() {
            return O
        })), n.d(e, "q", (function() {
            return I
        })), n.d(e, "f", (function() {
            return N
        })), n.d(e, "c", (function() {
            return F
        })), n.d(e, "i", (function() {
            return z
        })), n.d(e, "p", (function() {
            return B
        })), n.d(e, "a", (function() {
            return X
        })), n.d(e, "v", (function() {
            return $
        })), n.d(e, "n", (function() {
            return Y
        })), n.d(e, "u", (function() {
            return Z
        }));
        n(55), n(19), n(56), n(57), n(46), n(22), n(47);
        var r = n(25),
            o = n(7),
            l = n(18),
            c = n(12),
            h = (n(48), n(36), n(147), n(15), n(20), n(45), n(43), n(23), n(27), n(32), n(42), n(33), n(65), n(115), n(198), n(168), n(101), n(102), n(293), n(50), n(58), n(1)),
            d = n(26);

        function f(object, t) {
            var e = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(object);
                t && (n = n.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(object, t).enumerable
                }))), e.push.apply(e, n)
            }
            return e
        }

        function m(t) {
            for (var i = 1; i < arguments.length; i++) {
                var source = null != arguments[i] ? arguments[i] : {};
                i % 2 ? f(Object(source), !0).forEach((function(e) {
                    Object(l.a)(t, e, source[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(source)) : f(Object(source)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(source, e))
                }))
            }
            return t
        }

        function v(t, e) {
            var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!n) {
                if (Array.isArray(t) || (n = function(t, e) {
                        if (!t) return;
                        if ("string" == typeof t) return y(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        "Object" === n && t.constructor && (n = t.constructor.name);
                        if ("Map" === n || "Set" === n) return Array.from(t);
                        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return y(t, e)
                    }(t)) || e && t && "number" == typeof t.length) {
                    n && (t = n);
                    var i = 0,
                        r = function() {};
                    return {
                        s: r,
                        n: function() {
                            return i >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[i++]
                            }
                        },
                        e: function(t) {
                            throw t
                        },
                        f: r
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var o, l = !0,
                c = !1;
            return {
                s: function() {
                    n = n.call(t)
                },
                n: function() {
                    var t = n.next();
                    return l = t.done, t
                },
                e: function(t) {
                    c = !0, o = t
                },
                f: function() {
                    try {
                        l || null == n.return || n.return()
                    } finally {
                        if (c) throw o
                    }
                }
            }
        }

        function y(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }

        function _(t) {
            h.a.config.errorHandler && h.a.config.errorHandler(t)
        }

        function x(t) {
            return t.then((function(t) {
                return t.default || t
            }))
        }

        function w(t) {
            return t.$options && "function" == typeof t.$options.fetch && !t.$options.fetch.length
        }

        function M(t) {
            var e, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                r = t.$children || [],
                o = v(r);
            try {
                for (o.s(); !(e = o.n()).done;) {
                    var l = e.value;
                    l.$fetch ? n.push(l) : l.$children && M(l, n)
                }
            } catch (t) {
                o.e(t)
            } finally {
                o.f()
            }
            return n
        }

        function S(t, e) {
            if (e || !t.options.__hasNuxtData) {
                var n = t.options._originDataFn || t.options.data || function() {
                    return {}
                };
                t.options._originDataFn = n, t.options.data = function() {
                    var data = n.call(this, this);
                    return this.$ssrContext && (e = this.$ssrContext.asyncData[t.cid]), m(m({}, data), e)
                }, t.options.__hasNuxtData = !0, t._Ctor && t._Ctor.options && (t._Ctor.options.data = t.options.data)
            }
        }

        function T(t) {
            return t.options && t._Ctor === t || (t.options ? (t._Ctor = t, t.extendOptions = t.options) : (t = h.a.extend(t))._Ctor = t, !t.options.name && t.options.__file && (t.options.name = t.options.__file)), t
        }

        function E(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "components";
            return Array.prototype.concat.apply([], t.matched.map((function(t, r) {
                return Object.keys(t[n]).map((function(o) {
                    return e && e.push(r), t[n][o]
                }))
            })))
        }

        function A(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return E(t, e, "instances")
        }

        function C(t, e) {
            return Array.prototype.concat.apply([], t.matched.map((function(t, n) {
                return Object.keys(t.components).reduce((function(r, o) {
                    return t.components[o] ? r.push(e(t.components[o], t.instances[o], t, o, n)) : delete t.components[o], r
                }), [])
            })))
        }

        function L(t, e) {
            return Promise.all(C(t, function() {
                var t = Object(o.a)(regeneratorRuntime.mark((function t(n, r, o, l) {
                    var c, h;
                    return regeneratorRuntime.wrap((function(t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                if ("function" != typeof n || n.options) {
                                    t.next = 11;
                                    break
                                }
                                return t.prev = 1, t.next = 4, n();
                            case 4:
                                n = t.sent, t.next = 11;
                                break;
                            case 7:
                                throw t.prev = 7, t.t0 = t.catch(1), t.t0 && "ChunkLoadError" === t.t0.name && "undefined" != typeof window && window.sessionStorage && (c = Date.now(), (!(h = parseInt(window.sessionStorage.getItem("nuxt-reload"))) || h + 6e4 < c) && (window.sessionStorage.setItem("nuxt-reload", c), window.location.reload(!0))), t.t0;
                            case 11:
                                return o.components[l] = n = T(n), t.abrupt("return", "function" == typeof e ? e(n, r, o, l) : n);
                            case 13:
                            case "end":
                                return t.stop()
                        }
                    }), t, null, [
                        [1, 7]
                    ])
                })));
                return function(e, n, r, o) {
                    return t.apply(this, arguments)
                }
            }()))
        }

        function k(t) {
            return R.apply(this, arguments)
        }

        function R() {
            return (R = Object(o.a)(regeneratorRuntime.mark((function t(e) {
                return regeneratorRuntime.wrap((function(t) {
                    for (;;) switch (t.prev = t.next) {
                        case 0:
                            if (e) {
                                t.next = 2;
                                break
                            }
                            return t.abrupt("return");
                        case 2:
                            return t.next = 4, L(e);
                        case 4:
                            return t.abrupt("return", m(m({}, e), {}, {
                                meta: E(e).map((function(t, n) {
                                    return m(m({}, t.options.meta), (e.matched[n] || {}).meta)
                                }))
                            }));
                        case 5:
                        case "end":
                            return t.stop()
                    }
                }), t)
            })))).apply(this, arguments)
        }

        function P(t, e) {
            return D.apply(this, arguments)
        }

        function D() {
            return (D = Object(o.a)(regeneratorRuntime.mark((function t(e, n) {
                var o, l, h, f;
                return regeneratorRuntime.wrap((function(t) {
                    for (;;) switch (t.prev = t.next) {
                        case 0:
                            return e.context || (e.context = {
                                isStatic: !0,
                                isDev: !1,
                                isHMR: !1,
                                app: e,
                                store: e.store,
                                payload: n.payload,
                                error: n.error,
                                base: e.router.options.base,
                                env: {
                                    baseUrl: "https://monopo.vn"
                                }
                            }, n.req && (e.context.req = n.req), n.res && (e.context.res = n.res), n.ssrContext && (e.context.ssrContext = n.ssrContext), e.context.redirect = function(t, path, n) {
                                if (t) {
                                    e.context._redirected = !0;
                                    var o = Object(r.a)(path);
                                    if ("number" == typeof t || "undefined" !== o && "object" !== o || (n = path || {}, path = t, o = Object(r.a)(path), t = 302), "object" === o && (path = e.router.resolve(path).route.fullPath), !/(^[.]{1,2}\/)|(^\/(?!\/))/.test(path)) throw path = Object(d.e)(path, n), window.location.replace(path), new Error("ERR_REDIRECT");
                                    e.context.next({
                                        path: path,
                                        query: n,
                                        status: t
                                    })
                                }
                            }, e.context.nuxtState = window.__NUXT__), t.next = 3, Promise.all([k(n.route), k(n.from)]);
                        case 3:
                            o = t.sent, l = Object(c.a)(o, 2), h = l[0], f = l[1], n.route && (e.context.route = h), n.from && (e.context.from = f), e.context.next = n.next, e.context._redirected = !1, e.context._errored = !1, e.context.isHMR = !1, e.context.params = e.context.route.params || {}, e.context.query = e.context.route.query || {};
                        case 15:
                        case "end":
                            return t.stop()
                    }
                }), t)
            })))).apply(this, arguments)
        }

        function O(t, e) {
            return !t.length || e._redirected || e._errored ? Promise.resolve() : I(t[0], e).then((function() {
                return O(t.slice(1), e)
            }))
        }

        function I(t, e) {
            var n;
            return (n = 2 === t.length ? new Promise((function(n) {
                t(e, (function(t, data) {
                    t && e.error(t), n(data = data || {})
                }))
            })) : t(e)) && n instanceof Promise && "function" == typeof n.then ? n : Promise.resolve(n)
        }

        function N(base, t) {
            if ("hash" === t) return window.location.hash.replace(/^#\//, "");
            base = decodeURI(base).slice(0, -1);
            var path = decodeURI(window.location.pathname);
            base && path.startsWith(base) && (path = path.slice(base.length));
            var e = (path || "/") + window.location.search + window.location.hash;
            return Object(d.d)(e)
        }

        function F(t, e) {
            return function(t, e) {
                for (var n = new Array(t.length), i = 0; i < t.length; i++) "object" === Object(r.a)(t[i]) && (n[i] = new RegExp("^(?:" + t[i].pattern + ")$", W(e)));
                return function(e, r) {
                    for (var path = "", data = e || {}, o = (r || {}).pretty ? H : encodeURIComponent, l = 0; l < t.length; l++) {
                        var c = t[l];
                        if ("string" != typeof c) {
                            var h = data[c.name || "pathMatch"],
                                d = void 0;
                            if (null == h) {
                                if (c.optional) {
                                    c.partial && (path += c.prefix);
                                    continue
                                }
                                throw new TypeError('Expected "' + c.name + '" to be defined')
                            }
                            if (Array.isArray(h)) {
                                if (!c.repeat) throw new TypeError('Expected "' + c.name + '" to not repeat, but received `' + JSON.stringify(h) + "`");
                                if (0 === h.length) {
                                    if (c.optional) continue;
                                    throw new TypeError('Expected "' + c.name + '" to not be empty')
                                }
                                for (var f = 0; f < h.length; f++) {
                                    if (d = o(h[f]), !n[l].test(d)) throw new TypeError('Expected all "' + c.name + '" to match "' + c.pattern + '", but received `' + JSON.stringify(d) + "`");
                                    path += (0 === f ? c.prefix : c.delimiter) + d
                                }
                            } else {
                                if (d = c.asterisk ? j(h) : o(h), !n[l].test(d)) throw new TypeError('Expected "' + c.name + '" to match "' + c.pattern + '", but received "' + d + '"');
                                path += c.prefix + d
                            }
                        } else path += c
                    }
                    return path
                }
            }(function(t, e) {
                var n, r = [],
                    o = 0,
                    l = 0,
                    path = "",
                    c = e && e.delimiter || "/";
                for (; null != (n = U.exec(t));) {
                    var h = n[0],
                        d = n[1],
                        f = n.index;
                    if (path += t.slice(l, f), l = f + h.length, d) path += d[1];
                    else {
                        var m = t[l],
                            v = n[2],
                            y = n[3],
                            _ = n[4],
                            x = n[5],
                            w = n[6],
                            M = n[7];
                        path && (r.push(path), path = "");
                        var S = null != v && null != m && m !== v,
                            T = "+" === w || "*" === w,
                            E = "?" === w || "*" === w,
                            A = n[2] || c,
                            pattern = _ || x;
                        r.push({
                            name: y || o++,
                            prefix: v || "",
                            delimiter: A,
                            optional: E,
                            repeat: T,
                            partial: S,
                            asterisk: Boolean(M),
                            pattern: pattern ? G(pattern) : M ? ".*" : "[^" + V(A) + "]+?"
                        })
                    }
                }
                l < t.length && (path += t.substr(l));
                path && r.push(path);
                return r
            }(t, e), e)
        }

        function z(t, e) {
            var n = {},
                r = m(m({}, t), e);
            for (var o in r) String(t[o]) !== String(e[o]) && (n[o] = !0);
            return n
        }

        function B(t) {
            var e;
            if (t.message || "string" == typeof t) e = t.message || t;
            else try {
                e = JSON.stringify(t, null, 2)
            } catch (n) {
                e = "[".concat(t.constructor.name, "]")
            }
            return m(m({}, t), {}, {
                message: e,
                statusCode: t.statusCode || t.status || t.response && t.response.status || 500
            })
        }
        window.onNuxtReadyCbs = [], window.onNuxtReady = function(t) {
            window.onNuxtReadyCbs.push(t)
        };
        var U = new RegExp(["(\\\\.)", "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"), "g");

        function H(t, e) {
            var n = e ? /[?#]/g : /[/?#]/g;
            return encodeURI(t).replace(n, (function(t) {
                return "%" + t.charCodeAt(0).toString(16).toUpperCase()
            }))
        }

        function j(t) {
            return H(t, !0)
        }

        function V(t) {
            return t.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
        }

        function G(t) {
            return t.replace(/([=!:$/()])/g, "\\$1")
        }

        function W(t) {
            return t && t.sensitive ? "" : "i"
        }

        function X(t, e, n) {
            t.$options[e] || (t.$options[e] = []), t.$options[e].includes(n) || t.$options[e].push(n)
        }
        var $ = d.c,
            Y = (d.g, d.b);

        function Z(t) {
            try {
                window.history.scrollRestoration = t
            } catch (t) {}
        }
    }, , , function(t, e, n) {
        "use strict";
        n.d(e, "b", (function() {
            return Lt
        })), n.d(e, "a", (function() {
            return Lt
        }));
        var r, o, l, c, h, d, f, m = n(0),
            v = {},
            y = 180 / Math.PI,
            _ = Math.PI / 180,
            x = Math.atan2,
            w = /([A-Z])/g,
            M = /(?:left|right|width|margin|padding|x)/i,
            S = /[\s,\(]\S/,
            T = {
                autoAlpha: "opacity,visibility",
                scale: "scaleX,scaleY",
                alpha: "opacity"
            },
            E = function(t, data) {
                return data.set(data.t, data.p, Math.round(1e4 * (data.s + data.c * t)) / 1e4 + data.u, data)
            },
            A = function(t, data) {
                return data.set(data.t, data.p, 1 === t ? data.e : Math.round(1e4 * (data.s + data.c * t)) / 1e4 + data.u, data)
            },
            C = function(t, data) {
                return data.set(data.t, data.p, t ? Math.round(1e4 * (data.s + data.c * t)) / 1e4 + data.u : data.b, data)
            },
            L = function(t, data) {
                var e = data.s + data.c * t;
                data.set(data.t, data.p, ~~(e + (e < 0 ? -.5 : .5)) + data.u, data)
            },
            k = function(t, data) {
                return data.set(data.t, data.p, t ? data.e : data.b, data)
            },
            R = function(t, data) {
                return data.set(data.t, data.p, 1 !== t ? data.b : data.e, data)
            },
            P = function(t, e, n) {
                return t.style[e] = n
            },
            D = function(t, e, n) {
                return t.style.setProperty(e, n)
            },
            O = function(t, e, n) {
                return t._gsap[e] = n
            },
            I = function(t, e, n) {
                return t._gsap.scaleX = t._gsap.scaleY = n
            },
            N = function(t, e, n, data, r) {
                var o = t._gsap;
                o.scaleX = o.scaleY = n, o.renderTransform(r, o)
            },
            F = function(t, e, n, data, r) {
                var o = t._gsap;
                o[e] = n, o.renderTransform(r, o)
            },
            z = "transform",
            B = z + "Origin",
            U = function(t, e) {
                var n = o.createElementNS ? o.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : o.createElement(t);
                return n.style ? n : o.createElement(t)
            },
            H = function t(e, n, r) {
                var o = getComputedStyle(e);
                return o[n] || o.getPropertyValue(n.replace(w, "-$1").toLowerCase()) || o.getPropertyValue(n) || !r && t(e, V(n) || n, 1) || ""
            },
            j = "O,Moz,ms,Ms,Webkit".split(","),
            V = function(t, element, e) {
                var s = (element || h).style,
                    i = 5;
                if (t in s && !e) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1); i-- && !(j[i] + t in s););
                return i < 0 ? null : (3 === i ? "ms" : i >= 0 ? j[i] : "") + t
            },
            G = function() {
                "undefined" != typeof window && window.document && (r = window, o = r.document, l = o.documentElement, h = U("div") || {
                    style: {}
                }, U("div"), z = V(z), B = z + "Origin", h.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", f = !!V("perspective"), c = 1)
            },
            W = function t(e) {
                var n, svg = U("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    r = this.parentNode,
                    o = this.nextSibling,
                    c = this.style.cssText;
                if (l.appendChild(svg), svg.appendChild(this), this.style.display = "block", e) try {
                    n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                } catch (t) {} else this._gsapBBox && (n = this._gsapBBox());
                return r && (o ? r.insertBefore(this, o) : r.appendChild(this)), l.removeChild(svg), this.style.cssText = c, n
            },
            X = function(t, e) {
                for (var i = e.length; i--;)
                    if (t.hasAttribute(e[i])) return t.getAttribute(e[i])
            },
            $ = function(t) {
                var e;
                try {
                    e = t.getBBox()
                } catch (n) {
                    e = W.call(t, !0)
                }
                return e && (e.width || e.height) || t.getBBox === W || (e = W.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                    x: +X(t, ["x", "cx", "x1"]) || 0,
                    y: +X(t, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            },
            Y = function(t) {
                return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !$(t))
            },
            Z = function(t, e) {
                if (e) {
                    var style = t.style;
                    e in v && e !== B && (e = z), style.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), style.removeProperty(e.replace(w, "-$1").toLowerCase())) : style.removeAttribute(e)
                }
            },
            J = function(t, e, n, r, o, l) {
                var c = new m.d(t._pt, e, n, 0, 1, l ? R : k);
                return t._pt = c, c.b = r, c.e = o, t._props.push(n), c
            },
            K = {
                deg: 1,
                rad: 1,
                turn: 1
            },
            Q = function t(e, n, r, l) {
                var c, d, f, y, _ = parseFloat(r) || 0,
                    x = (r + "").trim().substr((_ + "").length) || "px",
                    style = h.style,
                    w = M.test(n),
                    S = "svg" === e.tagName.toLowerCase(),
                    T = (S ? "client" : "offset") + (w ? "Width" : "Height"),
                    E = 100,
                    A = "px" === l,
                    C = "%" === l;
                return l === x || !_ || K[l] || K[x] ? _ : ("px" !== x && !A && (_ = t(e, n, r, "px")), y = e.getCTM && Y(e), !C && "%" !== x || !v[n] && !~n.indexOf("adius") ? (style[w ? "width" : "height"] = E + (A ? x : l), d = ~n.indexOf("adius") || "em" === l && e.appendChild && !S ? e : e.parentNode, y && (d = (e.ownerSVGElement || {}).parentNode), d && d !== o && d.appendChild || (d = o.body), (f = d._gsap) && C && f.width && w && f.time === m.x.time ? Object(m.v)(_ / f.width * E) : ((C || "%" === x) && (style.position = H(e, "position")), d === e && (style.position = "static"), d.appendChild(h), c = h[T], d.removeChild(h), style.position = "absolute", w && C && ((f = Object(m.j)(d)).time = m.x.time, f.width = d[T]), Object(m.v)(A ? c * _ / E : c && _ ? E / c * _ : 0))) : (c = y ? e.getBBox()[w ? "width" : "height"] : e[T], Object(m.v)(C ? _ / c * E : _ / 100 * c)))
            },
            tt = function(t, e, n, r) {
                var o;
                return c || G(), e in T && "transform" !== e && ~(e = T[e]).indexOf(",") && (e = e.split(",")[0]), v[e] && "transform" !== e ? (o = pt(t, r), o = "transformOrigin" !== e ? o[e] : o.svg ? o.origin : ft(H(t, B)) + " " + o.zOrigin + "px") : (!(o = t.style[e]) || "auto" === o || r || ~(o + "").indexOf("calc(")) && (o = ot[e] && ot[e](t, e, n) || H(t, e) || Object(m.k)(t, e) || ("opacity" === e ? 1 : 0)), n && !~(o + "").trim().indexOf(" ") ? Q(t, e, o, n) + n : o
            },
            et = function(t, e, n, r) {
                if (!n || "none" === n) {
                    var p = V(e, t, 1),
                        s = p && H(t, p, 1);
                    s && s !== n ? (e = p, n = s) : "borderColor" === e && (n = H(t, "borderTopColor"))
                }
                var a, o, l, c, h, d, f, v, y, _, x, w, M = new m.d(this._pt, t.style, e, 0, 1, m.t),
                    S = 0,
                    T = 0;
                if (M.b = n, M.e = r, n += "", "auto" === (r += "") && (t.style[e] = r, r = H(t, e) || r, t.style[e] = n), a = [n, r], Object(m.g)(a), r = a[1], l = (n = a[0]).match(m.q) || [], (r.match(m.q) || []).length) {
                    for (; o = m.q.exec(r);) f = o[0], y = r.substring(S, o.index), h ? h = (h + 1) % 5 : "rgba(" !== y.substr(-5) && "hsla(" !== y.substr(-5) || (h = 1), f !== (d = l[T++] || "") && (c = parseFloat(d) || 0, x = d.substr((c + "").length), (w = "=" === f.charAt(1) ? +(f.charAt(0) + "1") : 0) && (f = f.substr(2)), v = parseFloat(f), _ = f.substr((v + "").length), S = m.q.lastIndex - _.length, _ || (_ = _ || m.h.units[e] || x, S === r.length && (r += _, M.e += _)), x !== _ && (c = Q(t, e, d, _) || 0), M._pt = {
                        _next: M._pt,
                        p: y || 1 === T ? y : ",",
                        s: c,
                        c: w ? w * v : v - c,
                        m: h && h < 4 || "zIndex" === e ? Math.round : 0
                    });
                    M.c = S < r.length ? r.substring(S, r.length) : ""
                } else M.r = "display" === e && "none" === r ? R : k;
                return m.s.test(r) && (M.e = 0), this._pt = M, M
            },
            nt = {
                top: "0%",
                bottom: "100%",
                left: "0%",
                right: "100%",
                center: "50%"
            },
            it = function(t, data) {
                if (data.tween && data.tween._time === data.tween._dur) {
                    var e, n, i, r = data.t,
                        style = r.style,
                        o = data.u,
                        l = r._gsap;
                    if ("all" === o || !0 === o) style.cssText = "", n = 1;
                    else
                        for (i = (o = o.split(",")).length; --i > -1;) e = o[i], v[e] && (n = 1, e = "transformOrigin" === e ? B : z), Z(r, e);
                    n && (Z(r, z), l && (l.svg && r.removeAttribute("transform"), pt(r, 1), l.uncache = 1))
                }
            },
            ot = {
                clearProps: function(t, e, n, r, o) {
                    if ("isFromStart" !== o.data) {
                        var l = t._pt = new m.d(t._pt, e, n, 0, 0, it);
                        return l.u = r, l.pr = -10, l.tween = o, t._props.push(n), 1
                    }
                }
            },
            at = [1, 0, 0, 1, 0, 0],
            st = {},
            lt = function(t) {
                return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
            },
            ct = function(t) {
                var e = H(t, z);
                return lt(e) ? at : e.substr(7).match(m.p).map(m.v)
            },
            ut = function(t, e) {
                var n, r, o, c, h = t._gsap || Object(m.j)(t),
                    style = t.style,
                    d = ct(t);
                return h.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (d = [(o = t.transform.baseVal.consolidate().matrix).a, o.b, o.c, o.d, o.e, o.f]).join(",") ? at : d : (d !== at || t.offsetParent || t === l || h.svg || (o = style.display, style.display = "block", (n = t.parentNode) && t.offsetParent || (c = 1, r = t.nextSibling, l.appendChild(t)), d = ct(t), o ? style.display = o : Z(t, "display"), c && (r ? n.insertBefore(t, r) : n ? n.appendChild(t) : l.removeChild(t))), e && d.length > 6 ? [d[0], d[1], d[4], d[5], d[12], d[13]] : d)
            },
            ht = function(t, e, n, r, o, l) {
                var c, h, d, f = t._gsap,
                    m = o || ut(t, !0),
                    v = f.xOrigin || 0,
                    y = f.yOrigin || 0,
                    _ = f.xOffset || 0,
                    x = f.yOffset || 0,
                    a = m[0],
                    b = m[1],
                    w = m[2],
                    M = m[3],
                    S = m[4],
                    T = m[5],
                    E = e.split(" "),
                    A = parseFloat(E[0]) || 0,
                    C = parseFloat(E[1]) || 0;
                n ? m !== at && (h = a * M - b * w) && (d = A * (-b / h) + C * (a / h) - (a * T - b * S) / h, A = A * (M / h) + C * (-w / h) + (w * T - M * S) / h, C = d) : (A = (c = $(t)).x + (~E[0].indexOf("%") ? A / 100 * c.width : A), C = c.y + (~(E[1] || E[0]).indexOf("%") ? C / 100 * c.height : C)), r || !1 !== r && f.smooth ? (S = A - v, T = C - y, f.xOffset = _ + (S * a + T * w) - S, f.yOffset = x + (S * b + T * M) - T) : f.xOffset = f.yOffset = 0, f.xOrigin = A, f.yOrigin = C, f.smooth = !!r, f.origin = e, f.originIsAbsolute = !!n, t.style[B] = "0px 0px", l && (J(l, f, "xOrigin", v, A), J(l, f, "yOrigin", y, C), J(l, f, "xOffset", _, f.xOffset), J(l, f, "yOffset", x, f.yOffset)), t.setAttribute("data-svg-origin", A + " " + C)
            },
            pt = function(t, e) {
                var n = t._gsap || new m.b(t);
                if ("x" in n && !e && !n.uncache) return n;
                var r, o, l, c, h, d, v, w, M, S, T, E, A, C, L, k, R, a, b, P, D, O, I, N, F, U, j, V, G, W, X, $, style = t.style,
                    Z = n.scaleX < 0,
                    J = "px",
                    K = "deg",
                    Q = H(t, B) || "0";
                return r = o = l = d = v = w = M = S = T = 0, c = h = 1, n.svg = !(!t.getCTM || !Y(t)), C = ut(t, n.svg), n.svg && (N = (!n.uncache || "0px 0px" === Q) && !e && t.getAttribute("data-svg-origin"), ht(t, N || Q, !!N || n.originIsAbsolute, !1 !== n.smooth, C)), E = n.xOrigin || 0, A = n.yOrigin || 0, C !== at && (a = C[0], b = C[1], P = C[2], D = C[3], r = O = C[4], o = I = C[5], 6 === C.length ? (c = Math.sqrt(a * a + b * b), h = Math.sqrt(D * D + P * P), d = a || b ? x(b, a) * y : 0, (M = P || D ? x(P, D) * y + d : 0) && (h *= Math.abs(Math.cos(M * _))), n.svg && (r -= E - (E * a + A * P), o -= A - (E * b + A * D))) : ($ = C[6], W = C[7], j = C[8], V = C[9], G = C[10], X = C[11], r = C[12], o = C[13], l = C[14], v = (L = x($, G)) * y, L && (N = O * (k = Math.cos(-L)) + j * (R = Math.sin(-L)), F = I * k + V * R, U = $ * k + G * R, j = O * -R + j * k, V = I * -R + V * k, G = $ * -R + G * k, X = W * -R + X * k, O = N, I = F, $ = U), w = (L = x(-P, G)) * y, L && (k = Math.cos(-L), X = D * (R = Math.sin(-L)) + X * k, a = N = a * k - j * R, b = F = b * k - V * R, P = U = P * k - G * R), d = (L = x(b, a)) * y, L && (N = a * (k = Math.cos(L)) + b * (R = Math.sin(L)), F = O * k + I * R, b = b * k - a * R, I = I * k - O * R, a = N, O = F), v && Math.abs(v) + Math.abs(d) > 359.9 && (v = d = 0, w = 180 - w), c = Object(m.v)(Math.sqrt(a * a + b * b + P * P)), h = Object(m.v)(Math.sqrt(I * I + $ * $)), L = x(O, I), M = Math.abs(L) > 2e-4 ? L * y : 0, T = X ? 1 / (X < 0 ? -X : X) : 0), n.svg && (N = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !lt(H(t, z)), N && t.setAttribute("transform", N))), Math.abs(M) > 90 && Math.abs(M) < 270 && (Z ? (c *= -1, M += d <= 0 ? 180 : -180, d += d <= 0 ? 180 : -180) : (h *= -1, M += M <= 0 ? 180 : -180)), n.x = r - ((n.xPercent = r && (n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + J, n.y = o - ((n.yPercent = o && (n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-o) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + J, n.z = l + J, n.scaleX = Object(m.v)(c), n.scaleY = Object(m.v)(h), n.rotation = Object(m.v)(d) + K, n.rotationX = Object(m.v)(v) + K, n.rotationY = Object(m.v)(w) + K, n.skewX = M + K, n.skewY = S + K, n.transformPerspective = T + J, (n.zOrigin = parseFloat(Q.split(" ")[2]) || 0) && (style[B] = ft(Q)), n.xOffset = n.yOffset = 0, n.force3D = m.h.force3D, n.renderTransform = n.svg ? bt : f ? xt : gt, n.uncache = 0, n
            },
            ft = function(t) {
                return (t = t.split(" "))[0] + " " + t[1]
            },
            mt = function(t, e, n) {
                var r = Object(m.y)(e);
                return Object(m.v)(parseFloat(e) + parseFloat(Q(t, "x", n + "px", r))) + r
            },
            gt = function(t, e) {
                e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, xt(t, e)
            },
            vt = "0deg",
            yt = "0px",
            _t = ") ",
            xt = function(t, e) {
                var n = e || this,
                    r = n.xPercent,
                    o = n.yPercent,
                    l = n.x,
                    c = n.y,
                    h = n.z,
                    d = n.rotation,
                    f = n.rotationY,
                    m = n.rotationX,
                    v = n.skewX,
                    y = n.skewY,
                    x = n.scaleX,
                    w = n.scaleY,
                    M = n.transformPerspective,
                    S = n.force3D,
                    T = n.target,
                    E = n.zOrigin,
                    A = "",
                    C = "auto" === S && t && 1 !== t || !0 === S;
                if (E && (m !== vt || f !== vt)) {
                    var L, k = parseFloat(f) * _,
                        R = Math.sin(k),
                        P = Math.cos(k);
                    k = parseFloat(m) * _, L = Math.cos(k), l = mt(T, l, R * L * -E), c = mt(T, c, -Math.sin(k) * -E), h = mt(T, h, P * L * -E + E)
                }
                M !== yt && (A += "perspective(" + M + _t), (r || o) && (A += "translate(" + r + "%, " + o + "%) "), (C || l !== yt || c !== yt || h !== yt) && (A += h !== yt || C ? "translate3d(" + l + ", " + c + ", " + h + ") " : "translate(" + l + ", " + c + _t), d !== vt && (A += "rotate(" + d + _t), f !== vt && (A += "rotateY(" + f + _t), m !== vt && (A += "rotateX(" + m + _t), v === vt && y === vt || (A += "skew(" + v + ", " + y + _t), 1 === x && 1 === w || (A += "scale(" + x + ", " + w + _t), T.style[z] = A || "translate(0, 0)"
            },
            bt = function(t, e) {
                var n, r, o, l, c, h = e || this,
                    d = h.xPercent,
                    f = h.yPercent,
                    v = h.x,
                    y = h.y,
                    x = h.rotation,
                    w = h.skewX,
                    M = h.skewY,
                    S = h.scaleX,
                    T = h.scaleY,
                    E = h.target,
                    A = h.xOrigin,
                    C = h.yOrigin,
                    L = h.xOffset,
                    k = h.yOffset,
                    R = h.forceCSS,
                    P = parseFloat(v),
                    D = parseFloat(y);
                x = parseFloat(x), w = parseFloat(w), (M = parseFloat(M)) && (w += M = parseFloat(M), x += M), x || w ? (x *= _, w *= _, n = Math.cos(x) * S, r = Math.sin(x) * S, o = Math.sin(x - w) * -T, l = Math.cos(x - w) * T, w && (M *= _, c = Math.tan(w - M), o *= c = Math.sqrt(1 + c * c), l *= c, M && (c = Math.tan(M), n *= c = Math.sqrt(1 + c * c), r *= c)), n = Object(m.v)(n), r = Object(m.v)(r), o = Object(m.v)(o), l = Object(m.v)(l)) : (n = S, l = T, r = o = 0), (P && !~(v + "").indexOf("px") || D && !~(y + "").indexOf("px")) && (P = Q(E, "x", v, "px"), D = Q(E, "y", y, "px")), (A || C || L || k) && (P = Object(m.v)(P + A - (A * n + C * o) + L), D = Object(m.v)(D + C - (A * r + C * l) + k)), (d || f) && (c = E.getBBox(), P = Object(m.v)(P + d / 100 * c.width), D = Object(m.v)(D + f / 100 * c.height)), c = "matrix(" + n + "," + r + "," + o + "," + l + "," + P + "," + D + ")", E.setAttribute("transform", c), R && (E.style[z] = c)
            },
            wt = function(t, e, n, r, o, l) {
                var c, h, d = 360,
                    f = Object(m.m)(o),
                    v = parseFloat(o) * (f && ~o.indexOf("rad") ? y : 1),
                    _ = l ? v * l : v - r,
                    x = r + _ + "deg";
                return f && ("short" === (c = o.split("_")[1]) && (_ %= d) !== _ % 180 && (_ += _ < 0 ? d : -360), "cw" === c && _ < 0 ? _ = (_ + 36e9) % d - ~~(_ / d) * d : "ccw" === c && _ > 0 && (_ = (_ - 36e9) % d - ~~(_ / d) * d)), t._pt = h = new m.d(t._pt, e, n, r, _, A), h.e = x, h.u = "deg", t._props.push(n), h
            },
            Mt = function(t, source) {
                for (var p in source) t[p] = source[p];
                return t
            },
            St = function(t, e, n) {
                var r, p, o, l, c, h, d, f = Mt({}, n._gsap),
                    style = n.style;
                for (p in f.svg ? (o = n.getAttribute("transform"), n.setAttribute("transform", ""), style[z] = e, r = pt(n, 1), Z(n, z), n.setAttribute("transform", o)) : (o = getComputedStyle(n)[z], style[z] = e, r = pt(n, 1), style[z] = o), v)(o = f[p]) !== (l = r[p]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(p) < 0 && (c = Object(m.y)(o) !== (d = Object(m.y)(l)) ? Q(n, p, o, d) : parseFloat(o), h = parseFloat(l), t._pt = new m.d(t._pt, r, p, c, h - c, E), t._pt.u = d || 0, t._props.push(p));
                Mt(r, f)
            };
        Object(m.i)("padding,margin,Width,Radius", (function(t, e) {
            var n = "Top",
                r = "Right",
                b = "Bottom",
                o = "Left",
                l = (e < 3 ? [n, r, b, o] : [n + o, n + r, b + r, b + o]).map((function(n) {
                    return e < 2 ? t + n : "border" + n + t
                }));
            ot[e > 1 ? "border" + t : t] = function(t, e, n, r, o) {
                var a, c;
                if (arguments.length < 4) return a = l.map((function(e) {
                    return tt(t, e, n)
                })), 5 === (c = a.join(" ")).split(a[0]).length ? a[0] : c;
                a = (r + "").split(" "), c = {}, l.forEach((function(t, i) {
                    return c[t] = a[i] = a[i] || a[(i - 1) / 2 | 0]
                })), t.init(e, c, o)
            }
        }));
        var Tt, Et, At, Ct = {
            name: "css",
            register: G,
            targetTest: function(t) {
                return t.style && t.nodeType
            },
            init: function(t, e, n, r, o) {
                var l, h, d, f, y, _, p, x, w, M, A, k, R, P, D, O, I, N, F, B = this._props,
                    style = t.style,
                    U = n.vars.startAt;
                for (p in c || G(), e)
                    if ("autoRound" !== p && (h = e[p], !m.r[p] || !Object(m.e)(p, e, n, r, t, o)))
                        if (y = typeof h, _ = ot[p], "function" === y && (y = typeof(h = h.call(n, r, t, o))), "string" === y && ~h.indexOf("random(") && (h = Object(m.u)(h)), _) _(this, t, p, h, n) && (D = 1);
                        else if ("--" === p.substr(0, 2)) l = (getComputedStyle(t).getPropertyValue(p) + "").trim(), h += "", m.f.lastIndex = 0, m.f.test(l) || (x = Object(m.y)(l), w = Object(m.y)(h)), w ? x !== w && (l = Q(t, p, l, w) + w) : x && (h += x), this.add(style, "setProperty", l, h, r, o, 0, 0, p), B.push(p);
                else if ("undefined" !== y) {
                    if (U && p in U ? (l = "function" == typeof U[p] ? U[p].call(n, r, t, o) : U[p], p in m.h.units && !Object(m.y)(l) && (l += m.h.units[p]), "=" === (l + "").charAt(1) && (l = tt(t, p))) : l = tt(t, p), f = parseFloat(l), (M = "string" === y && "=" === h.charAt(1) ? +(h.charAt(0) + "1") : 0) && (h = h.substr(2)), d = parseFloat(h), p in T && ("autoAlpha" === p && (1 === f && "hidden" === tt(t, "visibility") && d && (f = 0), J(this, style, "visibility", f ? "inherit" : "hidden", d ? "inherit" : "hidden", !d)), "scale" !== p && "transform" !== p && ~(p = T[p]).indexOf(",") && (p = p.split(",")[0])), A = p in v)
                        if (k || ((R = t._gsap).renderTransform && !e.parseTransform || pt(t, e.parseTransform), P = !1 !== e.smoothOrigin && R.smooth, (k = this._pt = new m.d(this._pt, style, z, 0, 1, R.renderTransform, R, 0, -1)).dep = 1), "scale" === p) this._pt = new m.d(this._pt, R, "scaleY", R.scaleY, (M ? M * d : d - R.scaleY) || 0), B.push("scaleY", p), p += "X";
                        else {
                            if ("transformOrigin" === p) {
                                I = void 0, N = void 0, F = void 0, I = (O = h).split(" "), N = I[0], F = I[1] || "50%", "top" !== N && "bottom" !== N && "left" !== F && "right" !== F || (O = N, N = F, F = O), I[0] = nt[N] || N, I[1] = nt[F] || F, h = I.join(" "), R.svg ? ht(t, h, 0, P, 0, this) : ((w = parseFloat(h.split(" ")[2]) || 0) !== R.zOrigin && J(this, R, "zOrigin", R.zOrigin, w), J(this, style, p, ft(l), ft(h)));
                                continue
                            }
                            if ("svgOrigin" === p) {
                                ht(t, h, 1, P, 0, this);
                                continue
                            }
                            if (p in st) {
                                wt(this, R, p, f, h, M);
                                continue
                            }
                            if ("smoothOrigin" === p) {
                                J(this, R, "smooth", R.smooth, h);
                                continue
                            }
                            if ("force3D" === p) {
                                R[p] = h;
                                continue
                            }
                            if ("transform" === p) {
                                St(this, h, t);
                                continue
                            }
                        }
                    else p in style || (p = V(p) || p);
                    if (A || (d || 0 === d) && (f || 0 === f) && !S.test(h) && p in style) d || (d = 0), (x = (l + "").substr((f + "").length)) !== (w = Object(m.y)(h) || (p in m.h.units ? m.h.units[p] : x)) && (f = Q(t, p, l, w)), this._pt = new m.d(this._pt, A ? R : style, p, f, M ? M * d : d - f, A || "px" !== w && "zIndex" !== p || !1 === e.autoRound ? E : L), this._pt.u = w || 0, x !== w && (this._pt.b = l, this._pt.r = C);
                    else if (p in style) et.call(this, t, p, l, h);
                    else {
                        if (!(p in t)) {
                            Object(m.o)(p, h);
                            continue
                        }
                        this.add(t, p, l || t[p], h, r, o)
                    }
                    B.push(p)
                }
                D && Object(m.w)(this)
            },
            get: tt,
            aliases: T,
            getSetter: function(t, e, n) {
                var p = T[e];
                return p && p.indexOf(",") < 0 && (e = p), e in v && e !== B && (t._gsap.x || tt(t, "x")) ? n && d === n ? "scale" === e ? I : O : (d = n || {}) && ("scale" === e ? N : F) : t.style && !Object(m.n)(t.style[e]) ? P : ~e.indexOf("-") ? D : Object(m.l)(t, e)
            },
            core: {
                _removeProperty: Z,
                _getMatrix: ut
            }
        };
        m.z.utils.checkPrefix = V, Tt = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent", Et = "rotation,rotationX,rotationY,skewX,skewY", At = Object(m.i)(Tt + "," + Et + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(t) {
            v[t] = 1
        })), Object(m.i)(Et, (function(t) {
            m.h.units[t] = "deg", st[t] = 1
        })), T[At[13]] = Tt + "," + Et, Object(m.i)("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(t) {
            var e = t.split(":");
            T[e[1]] = At[e[0]]
        })), Object(m.i)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
            m.h.units[t] = "px"
        })), m.z.registerPlugin(Ct);
        var Lt = m.z.registerPlugin(Ct) || m.z;
        Lt.core.Tween
    }, , , function(t, e, n) {
        "use strict";
        var r = Object.prototype.hasOwnProperty;

        function o(object, t) {
            return r.call(object, t)
        }

        function l(t) {
            return !(t >= 55296 && t <= 57343) && (!(t >= 64976 && t <= 65007) && (65535 != (65535 & t) && 65534 != (65535 & t) && (!(t >= 0 && t <= 8) && (11 !== t && (!(t >= 14 && t <= 31) && (!(t >= 127 && t <= 159) && !(t > 1114111)))))))
        }

        function c(t) {
            if (t > 65535) {
                var e = 55296 + ((t -= 65536) >> 10),
                    n = 56320 + (1023 & t);
                return String.fromCharCode(e, n)
            }
            return String.fromCharCode(t)
        }
        var h = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g,
            d = new RegExp(h.source + "|" + /&([a-z#][a-z0-9]{1,31});/gi.source, "gi"),
            f = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i,
            m = n(228);
        var v = /[&<>"]/,
            y = /[&<>"]/g,
            _ = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;"
            };

        function x(t) {
            return _[t]
        }
        var w = /[.?*+^$[\]\\(){}|-]/g;
        var M = n(151);
        e.lib = {}, e.lib.mdurl = n(229), e.lib.ucmicro = n(348), e.assign = function(t) {
            var e = Array.prototype.slice.call(arguments, 1);
            return e.forEach((function(source) {
                if (source) {
                    if ("object" != typeof source) throw new TypeError(source + "must be object");
                    Object.keys(source).forEach((function(e) {
                        t[e] = source[e]
                    }))
                }
            })), t
        }, e.isString = function(t) {
            return "[object String]" === function(t) {
                return Object.prototype.toString.call(t)
            }(t)
        }, e.has = o, e.unescapeMd = function(t) {
            return t.indexOf("\\") < 0 ? t : t.replace(h, "$1")
        }, e.unescapeAll = function(t) {
            return t.indexOf("\\") < 0 && t.indexOf("&") < 0 ? t : t.replace(d, (function(t, e, n) {
                return e || function(t, e) {
                    var code = 0;
                    return o(m, e) ? m[e] : 35 === e.charCodeAt(0) && f.test(e) && l(code = "x" === e[1].toLowerCase() ? parseInt(e.slice(2), 16) : parseInt(e.slice(1), 10)) ? c(code) : t
                }(t, n)
            }))
        }, e.isValidEntityCode = l, e.fromCodePoint = c, e.escapeHtml = function(t) {
            return v.test(t) ? t.replace(y, x) : t
        }, e.arrayReplaceAt = function(t, e, n) {
            return [].concat(t.slice(0, e), n, t.slice(e + 1))
        }, e.isSpace = function(code) {
            switch (code) {
                case 9:
                case 32:
                    return !0
            }
            return !1
        }, e.isWhiteSpace = function(code) {
            if (code >= 8192 && code <= 8202) return !0;
            switch (code) {
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 32:
                case 160:
                case 5760:
                case 8239:
                case 8287:
                case 12288:
                    return !0
            }
            return !1
        }, e.isMdAsciiPunct = function(t) {
            switch (t) {
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 123:
                case 124:
                case 125:
                case 126:
                    return !0;
                default:
                    return !1
            }
        }, e.isPunctChar = function(t) {
            return M.test(t)
        }, e.escapeRE = function(t) {
            return t.replace(w, "\\$&")
        }, e.normalizeReference = function(t) {
            return t.trim().replace(/\s+/g, " ").toUpperCase()
        }
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, n) {
        "use strict";
        t.exports = function(t) {
            var e = [];
            return e.toString = function() {
                return this.map((function(e) {
                    var content = function(t, e) {
                        var content = t[1] || "",
                            n = t[3];
                        if (!n) return content;
                        if (e && "function" == typeof btoa) {
                            var r = (l = n, c = btoa(unescape(encodeURIComponent(JSON.stringify(l)))), data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(c), "/*# ".concat(data, " */")),
                                o = n.sources.map((function(source) {
                                    return "/*# sourceURL=".concat(n.sourceRoot || "").concat(source, " */")
                                }));
                            return [content].concat(o).concat([r]).join("\n")
                        }
                        var l, c, data;
                        return [content].join("\n")
                    }(e, t);
                    return e[2] ? "@media ".concat(e[2], " {").concat(content, "}") : content
                })).join("")
            }, e.i = function(t, n, r) {
                "string" == typeof t && (t = [
                    [null, t, ""]
                ]);
                var o = {};
                if (r)
                    for (var i = 0; i < this.length; i++) {
                        var l = this[i][0];
                        null != l && (o[l] = !0)
                    }
                for (var c = 0; c < t.length; c++) {
                    var h = [].concat(t[c]);
                    r && o[h[0]] || (n && (h[2] ? h[2] = "".concat(n, " and ").concat(h[2]) : h[2] = n), e.push(h))
                }
            }, e
        }
    }, function(t, e, n) {
        "use strict";

        function r(t, e) {
            for (var n = [], r = {}, i = 0; i < e.length; i++) {
                var o = e[i],
                    l = o[0],
                    c = {
                        id: t + ":" + i,
                        css: o[1],
                        media: o[2],
                        sourceMap: o[3]
                    };
                r[l] ? r[l].parts.push(c) : n.push(r[l] = {
                    id: l,
                    parts: [c]
                })
            }
            return n
        }
        n.r(e), n.d(e, "default", (function() {
            return _
        }));
        var o = "undefined" != typeof document;
        if ("undefined" != typeof DEBUG && DEBUG && !o) throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");
        var l = {},
            head = o && (document.head || document.getElementsByTagName("head")[0]),
            c = null,
            h = 0,
            d = !1,
            f = function() {},
            m = null,
            v = "data-vue-ssr-id",
            y = "undefined" != typeof navigator && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());

        function _(t, e, n, o) {
            d = n, m = o || {};
            var c = r(t, e);
            return x(c),
                function(e) {
                    for (var n = [], i = 0; i < c.length; i++) {
                        var o = c[i];
                        (h = l[o.id]).refs--, n.push(h)
                    }
                    e ? x(c = r(t, e)) : c = [];
                    for (i = 0; i < n.length; i++) {
                        var h;
                        if (0 === (h = n[i]).refs) {
                            for (var d = 0; d < h.parts.length; d++) h.parts[d]();
                            delete l[h.id]
                        }
                    }
                }
        }

        function x(t) {
            for (var i = 0; i < t.length; i++) {
                var e = t[i],
                    n = l[e.id];
                if (n) {
                    n.refs++;
                    for (var r = 0; r < n.parts.length; r++) n.parts[r](e.parts[r]);
                    for (; r < e.parts.length; r++) n.parts.push(M(e.parts[r]));
                    n.parts.length > e.parts.length && (n.parts.length = e.parts.length)
                } else {
                    var o = [];
                    for (r = 0; r < e.parts.length; r++) o.push(M(e.parts[r]));
                    l[e.id] = {
                        id: e.id,
                        refs: 1,
                        parts: o
                    }
                }
            }
        }

        function w() {
            var t = document.createElement("style");
            return t.type = "text/css", head.appendChild(t), t
        }

        function M(t) {
            var e, n, r = document.querySelector("style[" + v + '~="' + t.id + '"]');
            if (r) {
                if (d) return f;
                r.parentNode.removeChild(r)
            }
            if (y) {
                var o = h++;
                r = c || (c = w()), e = E.bind(null, r, o, !1), n = E.bind(null, r, o, !0)
            } else r = w(), e = A.bind(null, r), n = function() {
                r.parentNode.removeChild(r)
            };
            return e(t),
                function(r) {
                    if (r) {
                        if (r.css === t.css && r.media === t.media && r.sourceMap === t.sourceMap) return;
                        e(t = r)
                    } else n()
                }
        }
        var S, T = (S = [], function(t, e) {
            return S[t] = e, S.filter(Boolean).join("\n")
        });

        function E(t, e, n, r) {
            var o = n ? "" : r.css;
            if (t.styleSheet) t.styleSheet.cssText = T(e, o);
            else {
                var l = document.createTextNode(o),
                    c = t.childNodes;
                c[e] && t.removeChild(c[e]), c.length ? t.insertBefore(l, c[e]) : t.appendChild(l)
            }
        }

        function A(t, e) {
            var n = e.css,
                r = e.media,
                o = e.sourceMap;
            if (r && t.setAttribute("media", r), m.ssrId && t.setAttribute(v, e.id), o && (n += "\n/*# sourceURL=" + o.sources[0] + " */", n += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(o)))) + " */"), t.styleSheet) t.styleSheet.cssText = n;
            else {
                for (; t.firstChild;) t.removeChild(t.firstChild);
                t.appendChild(document.createTextNode(n))
            }
        }
    }, , , , , , , , function(t, e, n) {
        "use strict";
        n.d(e, "b", (function() {
            return Zn
        })), n.d(e, "a", (function() {
            return D.a
        }));
        var r = {};
        n.r(r), n.d(r, "CookiesBanner", (function() {
            return V
        })), n.d(r, "DotCursor", (function() {
            return G
        })), n.d(r, "Footer", (function() {
            return W
        })), n.d(r, "Header", (function() {
            return X
        })), n.d(r, "ImageFullWidth", (function() {
            return $
        })), n.d(r, "ImageIllustration", (function() {
            return Y
        })), n.d(r, "ImageTwoColumns", (function() {
            return Z
        })), n.d(r, "Loader", (function() {
            return J
        })), n.d(r, "Manifesto", (function() {
            return K
        })), n.d(r, "NextProject", (function() {
            return Q
        })), n.d(r, "Overlay", (function() {
            return tt
        })), n.d(r, "Partners", (function() {
            return et
        })), n.d(r, "Project", (function() {
            return nt
        })), n.d(r, "Projects", (function() {
            return it
        })), n.d(r, "SlideScrollText", (function() {
            return ot
        })), n.d(r, "Strenghts", (function() {
            return at
        })), n.d(r, "Team", (function() {
            return st
        })), n.d(r, "TeamMember", (function() {
            return lt
        })), n.d(r, "TextCTA", (function() {
            return ct
        })), n.d(r, "TextTwoColumns", (function() {
            return ut
        })), n.d(r, "TilesImages", (function() {
            return ht
        })), n.d(r, "VideoBanner", (function() {
            return pt
        })), n.d(r, "Lens3D", (function() {
            return ft
        })), n.d(r, "Lens3DJsAtmosphereShader", (function() {
            return mt
        })), n.d(r, "Lens3DJsBackground", (function() {
            return gt
        })), n.d(r, "Lens3DJsColors", (function() {
            return vt
        })), n.d(r, "Lens3DJsCommon", (function() {
            return yt
        })), n.d(r, "Lens3DJsFresnelShader", (function() {
            return _t
        })), n.d(r, "Lens", (function() {
            return xt
        })), n.d(r, "LensArtworkGL", (function() {
            return bt
        })), n.d(r, "Lens3DJsLights", (function() {
            return wt
        }));
        n(23), n(19), n(36), n(46), n(22), n(47);
        var o = n(7),
            l = n(18),
            c = (n(48), n(20), n(43), n(15), n(33), n(65), n(1)),
            h = n(98),
            d = n(95),
            f = n(155),
            m = n.n(f),
            v = n(80),
            y = n.n(v),
            _ = (n(27), n(32), n(156)),
            x = n(26),
            w = n(3);
        "scrollRestoration" in window.history && (Object(w.u)("manual"), window.addEventListener("beforeunload", (function() {
            Object(w.u)("auto")
        })), window.addEventListener("load", (function() {
            Object(w.u)("manual")
        })));

        function M(object, t) {
            var e = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(object);
                t && (n = n.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(object, t).enumerable
                }))), e.push.apply(e, n)
            }
            return e
        }

        function S(t) {
            for (var i = 1; i < arguments.length; i++) {
                var source = null != arguments[i] ? arguments[i] : {};
                i % 2 ? M(Object(source), !0).forEach((function(e) {
                    Object(l.a)(t, e, source[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(source)) : M(Object(source)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(source, e))
                }))
            }
            return t
        }
        var T = function() {
                return Object(w.m)(Promise.all([n.e(2), n.e(0), n.e(1), n.e(22)]).then(n.bind(null, 517)))
            },
            E = function() {
                return Object(w.m)(Promise.all([n.e(2), n.e(23)]).then(n.bind(null, 518)))
            },
            A = function() {};
        c.a.use(_.a);
        var C = {
            mode: "history",
            base: "/",
            linkActiveClass: "nuxt-link-active",
            linkExactActiveClass: "nuxt-link-exact-active",
            scrollBehavior: function(t, e, n) {
                var r = !1,
                    o = t !== e;
                n ? r = n : o && function(t) {
                    var e = Object(w.g)(t);
                    if (1 === e.length) {
                        var n = e[0].options;
                        return !1 !== (void 0 === n ? {} : n).scrollToTop
                    }
                    return e.some((function(t) {
                        var e = t.options;
                        return e && e.scrollToTop
                    }))
                }(t) && (r = {
                    x: 0,
                    y: 0
                });
                var l = window.$nuxt;
                return (!o || t.path === e.path && t.hash !== e.hash) && l.$nextTick((function() {
                    return l.$emit("triggerScroll")
                })), new Promise((function(e) {
                    l.$once("triggerScroll", (function() {
                        if (t.hash) {
                            var n = t.hash;
                            void 0 !== window.CSS && void 0 !== window.CSS.escape && (n = "#" + window.CSS.escape(n.substr(1)));
                            try {
                                document.querySelector(n) && (r = {
                                    selector: n
                                })
                            } catch (t) {
                                console.warn("Failed to save scroll position. Please add CSS.escape() polyfill (https://github.com/mathiasbynens/CSS.escape).")
                            }
                        }
                        e(r)
                    }))
                }))
            },
            routes: [{
                path: "/vn",
                component: T,
                name: "index___vn"
            }, {
                path: "/zh",
                component: T,
                name: "index___zh"
            }, {
                path: "/vn/project/:slug?",
                component: E,
                name: "project-slug___vn"
            }, {
                path: "/zh/project/:slug?",
                component: E,
                name: "project-slug___zh"
            }, {
                path: "/project/:slug?",
                component: E,
                name: "project-slug___en"
            }, {
                path: "/",
                component: T,
                name: "index___en"
            }],
            fallback: !1
        };

        function L(t, e) {
            var base = e._app && e._app.basePath || C.base,
                n = new _.a(S(S({}, C), {}, {
                    base: base
                })),
                r = n.push;
            n.push = function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : A,
                    n = arguments.length > 2 ? arguments[2] : void 0;
                return r.call(this, t, e, n)
            };
            var o = n.resolve.bind(n);
            return n.resolve = function(t, e, n) {
                return "string" == typeof t && (t = Object(x.d)(t)), o(t, e, n)
            }, n
        }
        var k = {
                name: "NuxtChild",
                functional: !0,
                props: {
                    nuxtChildKey: {
                        type: String,
                        default: ""
                    },
                    keepAlive: Boolean,
                    keepAliveProps: {
                        type: Object,
                        default: void 0
                    }
                },
                render: function(t, e) {
                    var n = e.parent,
                        data = e.data,
                        r = e.props,
                        o = n.$createElement;
                    data.nuxtChild = !0;
                    for (var l = n, c = n.$nuxt.nuxt.transitions, h = n.$nuxt.nuxt.defaultTransition, d = 0; n;) n.$vnode && n.$vnode.data.nuxtChild && d++, n = n.$parent;
                    data.nuxtChildDepth = d;
                    var f = c[d] || h,
                        m = {};
                    R.forEach((function(t) {
                        void 0 !== f[t] && (m[t] = f[t])
                    }));
                    var v = {};
                    P.forEach((function(t) {
                        "function" == typeof f[t] && (v[t] = f[t].bind(l))
                    }));
                    var y = v.beforeEnter;
                    if (v.beforeEnter = function(t) {
                            if (window.$nuxt.$nextTick((function() {
                                    window.$nuxt.$emit("triggerScroll")
                                })), y) return y.call(l, t)
                        }, !1 === f.css) {
                        var _ = v.leave;
                        (!_ || _.length < 2) && (v.leave = function(t, e) {
                            _ && _.call(l, t), l.$nextTick(e)
                        })
                    }
                    var x = o("routerView", data);
                    return r.keepAlive && (x = o("keep-alive", {
                        props: r.keepAliveProps
                    }, [x])), o("transition", {
                        props: m,
                        on: v
                    }, [x])
                }
            },
            R = ["name", "mode", "appear", "css", "type", "duration", "enterClass", "leaveClass", "appearClass", "enterActiveClass", "enterActiveClass", "leaveActiveClass", "appearActiveClass", "enterToClass", "leaveToClass", "appearToClass"],
            P = ["beforeEnter", "enter", "afterEnter", "enterCancelled", "beforeLeave", "leave", "afterLeave", "leaveCancelled", "beforeAppear", "appear", "afterAppear", "appearCancelled"],
            D = n(67),
            O = n(12),
            I = (n(101), {
                name: "Nuxt",
                components: {
                    NuxtChild: k,
                    NuxtError: D.a
                },
                props: {
                    nuxtChildKey: {
                        type: String,
                        default: void 0
                    },
                    keepAlive: Boolean,
                    keepAliveProps: {
                        type: Object,
                        default: void 0
                    },
                    name: {
                        type: String,
                        default: "default"
                    }
                },
                errorCaptured: function(t) {
                    this.displayingNuxtError && (this.errorFromNuxtError = t, this.$forceUpdate())
                },
                computed: {
                    routerViewKey: function() {
                        if (void 0 !== this.nuxtChildKey || this.$route.matched.length > 1) return this.nuxtChildKey || Object(w.c)(this.$route.matched[0].path)(this.$route.params);
                        var t = Object(O.a)(this.$route.matched, 1)[0];
                        if (!t) return this.$route.path;
                        var e = t.components.default;
                        if (e && e.options) {
                            var n = e.options;
                            if (n.key) return "function" == typeof n.key ? n.key(this.$route) : n.key
                        }
                        return /\/$/.test(t.path) ? this.$route.path : this.$route.path.replace(/\/$/, "")
                    }
                },
                beforeCreate: function() {
                    c.a.util.defineReactive(this, "nuxt", this.$root.$options.nuxt)
                },
                render: function(t) {
                    var e = this;
                    return this.nuxt.err ? this.errorFromNuxtError ? (this.$nextTick((function() {
                        return e.errorFromNuxtError = !1
                    })), t("div", {}, [t("h2", "An error occurred while showing the error page"), t("p", "Unfortunately an error occurred and while showing the error page another error occurred"), t("p", "Error details: ".concat(this.errorFromNuxtError.toString())), t("nuxt-link", {
                        props: {
                            to: "/"
                        }
                    }, "Go back to home")])) : (this.displayingNuxtError = !0, this.$nextTick((function() {
                        return e.displayingNuxtError = !1
                    })), t(D.a, {
                        props: {
                            error: this.nuxt.err
                        }
                    })) : t("NuxtChild", {
                        key: this.routerViewKey,
                        props: this.$props
                    })
                }
            }),
            N = (n(42), n(55), n(56), n(57), n(306), n(310), n(263));

        function F(t, e) {
            var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!n) {
                if (Array.isArray(t) || (n = function(t, e) {
                        if (!t) return;
                        if ("string" == typeof t) return z(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        "Object" === n && t.constructor && (n = t.constructor.name);
                        if ("Map" === n || "Set" === n) return Array.from(t);
                        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return z(t, e)
                    }(t)) || e && t && "number" == typeof t.length) {
                    n && (t = n);
                    var i = 0,
                        r = function() {};
                    return {
                        s: r,
                        n: function() {
                            return i >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[i++]
                            }
                        },
                        e: function(t) {
                            throw t
                        },
                        f: r
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var o, l = !0,
                c = !1;
            return {
                s: function() {
                    n = n.call(t)
                },
                n: function() {
                    var t = n.next();
                    return l = t.done, t
                },
                e: function(t) {
                    c = !0, o = t
                },
                f: function() {
                    try {
                        l || null == n.return || n.return()
                    } finally {
                        if (c) throw o
                    }
                }
            }
        }

        function z(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }
        var B = {
                _default: Object(w.s)(N.a)
            },
            U = {
                render: function(t, e) {
                    var n = t(this.layout || "nuxt"),
                        r = t("div", {
                            domProps: {
                                id: "__layout"
                            },
                            key: this.layoutName
                        }, [n]),
                        o = t("transition", {
                            props: {
                                name: "layout",
                                mode: "out-in"
                            },
                            on: {
                                beforeEnter: function(t) {
                                    window.$nuxt.$nextTick((function() {
                                        window.$nuxt.$emit("triggerScroll")
                                    }))
                                }
                            }
                        }, [r]);
                    return t("div", {
                        domProps: {
                            id: "__nuxt"
                        }
                    }, [o])
                },
                data: function() {
                    return {
                        isOnline: !0,
                        layout: null,
                        layoutName: "",
                        nbFetching: 0
                    }
                },
                beforeCreate: function() {
                    c.a.util.defineReactive(this, "nuxt", this.$options.nuxt)
                },
                created: function() {
                    this.$root.$options.$nuxt = this, window.$nuxt = this, this.refreshOnlineStatus(), window.addEventListener("online", this.refreshOnlineStatus), window.addEventListener("offline", this.refreshOnlineStatus), this.error = this.nuxt.error, this.context = this.$options.context
                },
                watch: {
                    "nuxt.err": "errorChanged"
                },
                computed: {
                    isOffline: function() {
                        return !this.isOnline
                    },
                    isFetching: function() {
                        return this.nbFetching > 0
                    },
                    isPreview: function() {
                        return Boolean(this.$options.previewData)
                    }
                },
                methods: {
                    refreshOnlineStatus: function() {
                        void 0 === window.navigator.onLine ? this.isOnline = !0 : this.isOnline = window.navigator.onLine
                    },
                    refresh: function() {
                        var t = this;
                        return Object(o.a)(regeneratorRuntime.mark((function e() {
                            var n, r;
                            return regeneratorRuntime.wrap((function(e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        if ((n = Object(w.h)(t.$route)).length) {
                                            e.next = 3;
                                            break
                                        }
                                        return e.abrupt("return");
                                    case 3:
                                        return r = n.map((function(e) {
                                            var p = [];
                                            if (e.$options.fetch && e.$options.fetch.length && p.push(Object(w.q)(e.$options.fetch, t.context)), e.$fetch) p.push(e.$fetch());
                                            else {
                                                var n, r = F(Object(w.e)(e.$vnode.componentInstance));
                                                try {
                                                    for (r.s(); !(n = r.n()).done;) {
                                                        var component = n.value;
                                                        p.push(component.$fetch())
                                                    }
                                                } catch (t) {
                                                    r.e(t)
                                                } finally {
                                                    r.f()
                                                }
                                            }
                                            return e.$options.asyncData && p.push(Object(w.q)(e.$options.asyncData, t.context).then((function(t) {
                                                for (var n in t) c.a.set(e.$data, n, t[n])
                                            }))), Promise.all(p)
                                        })), e.prev = 4, e.next = 7, Promise.all(r);
                                    case 7:
                                        e.next = 13;
                                        break;
                                    case 9:
                                        e.prev = 9, e.t0 = e.catch(4), Object(w.k)(e.t0), t.error(e.t0);
                                    case 13:
                                    case "end":
                                        return e.stop()
                                }
                            }), e, null, [
                                [4, 9]
                            ])
                        })))()
                    },
                    errorChanged: function() {
                        if (this.nuxt.err) {
                            var t = (D.a.options || D.a).layout;
                            "function" == typeof t && (t = t(this.context)), this.setLayout(t)
                        }
                    },
                    setLayout: function(t) {
                        return t && B["_" + t] || (t = "default"), this.layoutName = t, this.layout = B["_" + t], this.layout
                    },
                    loadLayout: function(t) {
                        return t && B["_" + t] || (t = "default"), Promise.resolve(B["_" + t])
                    }
                }
            };
        c.a.use(h.a);
        var H = {};
        (H = function(t, e) {
            if ((t = t.default || t).commit) throw new Error("[nuxt] ".concat(e, " should export a method that returns a Vuex instance."));
            return "function" != typeof t && (t = Object.assign({}, t)),
                function(t, e) {
                    if (t.state && "function" != typeof t.state) {
                        console.warn("'state' should be a method that returns an object in ".concat(e));
                        var n = Object.assign({}, t.state);
                        t = Object.assign({}, t, {
                            state: function() {
                                return n
                            }
                        })
                    }
                    return t
                }(t, e)
        }(n(335), "store/index.js")).modules = H.modules || {};
        var j = H instanceof Function ? H : function() {
            return new h.a.Store(Object.assign({
                strict: !1
            }, H))
        };
        n(50), n(58);
        var V = function() {
                return Promise.resolve().then(n.bind(null, 408)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            G = function() {
                return Promise.resolve().then(n.bind(null, 405)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            W = function() {
                return n.e(0).then(n.bind(null, 479)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            X = function() {
                return Promise.resolve().then(n.bind(null, 247)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            $ = function() {
                return n.e(5).then(n.bind(null, 483)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            Y = function() {
                return n.e(6).then(n.bind(null, 482)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            Z = function() {
                return n.e(7).then(n.bind(null, 481)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            J = function() {
                return Promise.resolve().then(n.bind(null, 406)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            K = function() {
                return n.e(10).then(n.bind(null, 473)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            Q = function() {
                return n.e(11).then(n.bind(null, 484)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            tt = function() {
                return Promise.resolve().then(n.bind(null, 407)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            et = function() {
                return n.e(12).then(n.bind(null, 472)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            nt = function() {
                return n.e(13).then(n.bind(null, 428)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            it = function() {
                return n.e(14).then(n.bind(null, 471)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            ot = function() {
                return n.e(15).then(n.bind(null, 475)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            at = function() {
                return n.e(16).then(n.bind(null, 474)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            st = function() {
                return n.e(1).then(n.bind(null, 512)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            lt = function() {
                return n.e(17).then(n.bind(null, 478)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            ct = function() {
                return n.e(18).then(n.bind(null, 476)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            ut = function() {
                return n.e(19).then(n.bind(null, 480)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            ht = function() {
                return n.e(20).then(n.bind(null, 477)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            pt = function() {
                return n.e(21).then(n.bind(null, 465)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            ft = function() {
                return Promise.resolve().then(n.bind(null, 269)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            mt = function() {
                return n.e(8).then(n.bind(null, 513)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            gt = function() {
                return Promise.resolve().then(n.bind(null, 264)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            vt = function() {
                return Promise.resolve().then(n.bind(null, 71)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            yt = function() {
                return Promise.resolve().then(n.bind(null, 16)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            _t = function() {
                return Promise.resolve().then(n.bind(null, 157)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            xt = function() {
                return Promise.resolve().then(n.bind(null, 252)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            bt = function() {
                return Promise.resolve().then(n.bind(null, 250)).then((function(t) {
                    return Mt(t.default || t)
                }))
            },
            wt = function() {
                return n.e(9).then(n.bind(null, 514)).then((function(t) {
                    return Mt(t.default || t)
                }))
            };

        function Mt(t) {
            if (!t || !t.functional) return t;
            var e = Array.isArray(t.props) ? t.props : Object.keys(t.props || {});
            return {
                render: function(n) {
                    var r = {},
                        o = {};
                    for (var l in this.$attrs) e.includes(l) ? o[l] = this.$attrs[l] : r[l] = this.$attrs[l];
                    return n(t, {
                        on: this.$listeners,
                        attrs: r,
                        props: o,
                        scopedSlots: this.$scopedSlots
                    }, this.$slots.default)
                }
            }
        }
        for (var St in r) c.a.component(St, r[St]), c.a.component("Lazy" + St, r[St]);
        var Tt = n(25),
            Et = (n(84), n(75), n(45), n(147), {
                COMPONENT_OPTIONS_KEY: "nuxtI18n",
                STRATEGIES: {
                    PREFIX: "prefix",
                    PREFIX_EXCEPT_DEFAULT: "prefix_except_default",
                    PREFIX_AND_DEFAULT: "prefix_and_default",
                    NO_PREFIX: "no_prefix"
                },
                REDIRECT_ON_OPTIONS: {
                    ALL: "all",
                    ROOT: "root",
                    NO_PREFIX: "no prefix"
                }
            }),
            At = !1,
            Ct = void 0,
            Lt = {
                vueI18n: {
                    fallbackLocale: "en"
                },
                vueI18nLoader: !1,
                locales: ["vn", "zh", "en"],
                defaultLocale: "en",
                defaultDirection: "ltr",
                routesNameSeparator: "___",
                defaultLocaleRouteNameSuffix: "default",
                sortRoutes: !0,
                strategy: "prefix_except_default",
                lazy: !1,
                langDir: null,
                rootRedirect: null,
                detectBrowserLanguage: {
                    alwaysRedirect: !1,
                    cookieCrossOrigin: !1,
                    cookieDomain: null,
                    cookieKey: "i18n_redirected",
                    cookieSecure: !1,
                    fallbackLocale: "",
                    redirectOn: "root",
                    useCookie: !0
                },
                differentDomains: !1,
                baseUrl: "",
                vuex: {
                    moduleName: "i18n",
                    syncRouteParams: !0
                },
                parsePages: !0,
                pages: {},
                skipSettingLocaleOnNavigate: !1,
                onBeforeLanguageSwitch: function() {},
                onLanguageSwitched: function() {
                    return null
                },
                normalizedLocales: [{
                    code: "vn"
                }, {
                    code: "zh"
                }, {
                    code: "en"
                }],
                localeCodes: ["vn", "zh", "en"]
            },
            kt = (n(336), n(168), n(102), n(92), n(341), n(160)),
            Rt = n.n(kt);

        function Pt(t, e) {
            var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!n) {
                if (Array.isArray(t) || (n = function(t, e) {
                        if (!t) return;
                        if ("string" == typeof t) return Dt(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        "Object" === n && t.constructor && (n = t.constructor.name);
                        if ("Map" === n || "Set" === n) return Array.from(t);
                        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Dt(t, e)
                    }(t)) || e && t && "number" == typeof t.length) {
                    n && (t = n);
                    var i = 0,
                        r = function() {};
                    return {
                        s: r,
                        n: function() {
                            return i >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[i++]
                            }
                        },
                        e: function(t) {
                            throw t
                        },
                        f: r
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var o, l = !0,
                c = !1;
            return {
                s: function() {
                    n = n.call(t)
                },
                n: function() {
                    var t = n.next();
                    return l = t.done, t
                },
                e: function(t) {
                    c = !0, o = t
                },
                f: function() {
                    try {
                        l || null == n.return || n.return()
                    } finally {
                        if (c) throw o
                    }
                }
            }
        }

        function Dt(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }

        function Ot(text) {
            return "[@nuxtjs/i18n] ".concat(text)
        }

        function It(t, e) {
            var n, r = [],
                o = [],
                l = Pt(t);
            try {
                for (l.s(); !(n = l.n()).done;) {
                    var c = n.value,
                        code = c.code,
                        h = c.iso || code;
                    o.push({
                        code: code,
                        iso: h
                    })
                }
            } catch (t) {
                l.e(t)
            } finally {
                l.f()
            }
            var d, f = Pt(e.entries());
            try {
                var m = function() {
                    var t = Object(O.a)(d.value, 2),
                        n = t[0],
                        l = t[1],
                        c = o.find((function(t) {
                            return t.iso.toLowerCase() === l.toLowerCase()
                        }));
                    if (c) return r.push({
                        code: c.code,
                        score: 1 - n / e.length
                    }), "break"
                };
                for (f.s(); !(d = f.n()).done;) {
                    if ("break" === m()) break
                }
            } catch (t) {
                f.e(t)
            } finally {
                f.f()
            }
            var v, y = Pt(e.entries());
            try {
                var _ = function() {
                    var t = Object(O.a)(v.value, 2),
                        n = t[0],
                        l = t[1].split("-")[0].toLowerCase(),
                        c = o.find((function(t) {
                            return t.iso.split("-")[0].toLowerCase() === l
                        }));
                    if (c) return r.push({
                        code: c.code,
                        score: .999 - n / e.length
                    }), "break"
                };
                for (y.s(); !(v = y.n()).done;) {
                    if ("break" === _()) break
                }
            } catch (t) {
                y.e(t)
            } finally {
                y.f()
            }
            return r.length > 1 && r.sort((function(t, e) {
                return t.score === e.score ? e.code.length - t.code.length : e.score - t.score
            })), r.length ? r[0].code : void 0
        }

        function Nt(t, e) {
            var n;
            if (n = window.location.host) {
                var r = t.find((function(t) {
                    return t.domain === n
                }));
                if (r) return r.code
            }
            return ""
        }

        function Ft(t) {
            return new RegExp("^/(".concat(t.join("|"), ")(?:/|$)"), "i")
        }

        function zt(t, e) {
            var n = e.routesNameSeparator,
                r = e.defaultLocaleRouteNameSuffix,
                o = "(".concat(t.join("|"), ")"),
                l = "(?:".concat(n).concat(r, ")?"),
                c = new RegExp("".concat(n).concat(o).concat(l, "$"), "i"),
                h = Ft(t);
            return function(t) {
                if (t.name) {
                    var e = t.name.match(c);
                    if (e && e.length > 1) return e[1]
                } else if (t.path) {
                    var n = t.path.match(h);
                    if (n && n.length > 1) return n[1]
                }
                return ""
            }
        }

        function Bt(t, e) {
            var n, r = e.useCookie,
                o = e.cookieKey,
                l = e.localeCodes;
            if (r && ((n = Rt.a.get(o)) && l.includes(n))) return n
        }

        function Ut(t, e, n) {
            var r = n.useCookie,
                o = n.cookieDomain,
                l = n.cookieKey,
                c = n.cookieSecure,
                h = n.cookieCrossOrigin;
            if (r) {
                var d = new Date,
                    f = {
                        expires: new Date(d.setDate(d.getDate() + 365)),
                        path: "/",
                        sameSite: h ? "none" : "lax",
                        secure: h || c
                    };
                o && (f.domain = o), Rt.a.set(l, t, f)
            }
        }

        function Ht(object, t) {
            var e = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(object);
                t && (n = n.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(object, t).enumerable
                }))), e.push.apply(e, n)
            }
            return e
        }

        function jt(t) {
            for (var i = 1; i < arguments.length; i++) {
                var source = null != arguments[i] ? arguments[i] : {};
                i % 2 ? Ht(Object(source), !0).forEach((function(e) {
                    Object(l.a)(t, e, source[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(source)) : Ht(Object(source)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(source, e))
                }))
            }
            return t
        }

        function Vt(t, e) {
            return Gt.apply(this, arguments)
        }

        function Gt() {
            return (Gt = Object(o.a)(regeneratorRuntime.mark((function t(e, n) {
                var r, o, l;
                return regeneratorRuntime.wrap((function(t) {
                    for (;;) switch (t.prev = t.next) {
                        case 0:
                            r = e.app, (o = r.i18n).loadedLanguages || (o.loadedLanguages = []), o.loadedLanguages.includes(n) || ((l = Lt.normalizedLocales.find((function(t) {
                                return t.code === n
                            }))) ? l.file || console.warn(Ot("Could not find lang file for locale ".concat(n))) : console.warn(Ot('Attempted to load messages for non-existant locale code "'.concat(n, '"'))));
                        case 4:
                        case "end":
                            return t.stop()
                    }
                }), t)
            })))).apply(this, arguments)
        }

        function Wt(t, e, n, r) {
            var o = r.differentDomains,
                l = r.normalizedLocales;
            if ("function" == typeof t) return t(e);
            if (o && n) {
                var c = qt(n, e.req, {
                    normalizedLocales: l
                });
                if (c) return c
            }
            return t
        }

        function qt(t, e, n) {
            var r, o = n.normalizedLocales.find((function(e) {
                return e.code === t
            }));
            if (o && o.domain) return Object(x.a)(o.domain) ? o.domain : (r = window.location.protocol.split(":")[0], "".concat(r, "://").concat(o.domain));
            console.warn(Ot("Could not find domain name for locale ".concat(t)))
        }

        function Xt(t, e, n) {
            var r = {
                namespaced: !0,
                state: function() {
                    return jt({}, e.syncRouteParams ? {
                        routeParams: {}
                    } : {})
                },
                actions: jt({}, e.syncRouteParams ? {
                    setRouteParams: function(t, e) {
                        (0, t.commit)("setRouteParams", e)
                    }
                } : {}),
                mutations: jt({}, e.syncRouteParams ? {
                    setRouteParams: function(t, e) {
                        t.routeParams = e
                    }
                } : {}),
                getters: jt({}, e.syncRouteParams ? {
                    localeRouteParams: function(t) {
                        var e = t.routeParams;
                        return function(t) {
                            return e && e[t] || {}
                        }
                    }
                } : {})
            };
            t.registerModule(e.moduleName, r, {
                preserveState: !!t.state[e.moduleName]
            })
        }
        var $t = n(266),
            Yt = n(93),
            Zt = function() {
                var t = Object(o.a)(regeneratorRuntime.mark((function t(e) {
                    var n, r, o, l, c, h, d;
                    return regeneratorRuntime.wrap((function(t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                if (n = e.app, !e.isHMR) {
                                    t.next = 3;
                                    break
                                }
                                return t.abrupt("return");
                            case 3:
                                return t.next = 5, n.i18n.__onNavigate(e.route);
                            case 5:
                                r = t.sent, o = Object(O.a)(r, 3), l = o[0], c = o[1], h = o[2], l && c && (d = h ? e.route.query : void 0, e.redirect(l, c, d));
                            case 11:
                            case "end":
                                return t.stop()
                        }
                    }), t)
                })));
                return function(e) {
                    return t.apply(this, arguments)
                }
            }();
        Yt.a.nuxti18n = Zt;
        var Jt = ["params"];

        function Kt(object, t) {
            var e = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(object);
                t && (n = n.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(object, t).enumerable
                }))), e.push.apply(e, n)
            }
            return e
        }

        function Qt(t) {
            for (var i = 1; i < arguments.length; i++) {
                var source = null != arguments[i] ? arguments[i] : {};
                i % 2 ? Kt(Object(source), !0).forEach((function(e) {
                    Object(l.a)(t, e, source[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(source)) : Kt(Object(source)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(source, e))
                }))
            }
            return t
        }

        function te(t, e) {
            var n = re.call(this, t, e);
            return n ? n.route.redirectedFrom || n.route.fullPath : ""
        }

        function ee(t, e) {
            var n = re.call(this, t, e);
            return n ? n.route : void 0
        }

        function ne(t, e) {
            var n = re.call(this, t, e);
            return n ? n.location : void 0
        }

        function re(t, e) {
            if (t) {
                var n = this.i18n;
                if (e = e || n.locale) {
                    "string" == typeof t && (t = "/" === t[0] ? {
                        path: t
                    } : {
                        name: t
                    });
                    var r = Object.assign({}, t);
                    if (r.path && !r.name) {
                        var o = this.router.resolve(r).route,
                            l = this.getRouteBaseName(o);
                        if (l) r = {
                            name: ae(l, e),
                            params: o.params,
                            query: o.query,
                            hash: o.hash
                        };
                        else !(e === Lt.defaultLocale && [Et.STRATEGIES.PREFIX_EXCEPT_DEFAULT, Et.STRATEGIES.PREFIX_AND_DEFAULT].includes(Lt.strategy) || Lt.strategy === Et.STRATEGIES.NO_PREFIX || n.differentDomains) && (r.path = "/".concat(e).concat(r.path)), r.path = Ct ? Object(x.f)(r.path, !0) : Object(x.g)(r.path, !0)
                    } else {
                        r.name || r.path || (r.name = this.getRouteBaseName()), r.name = ae(r.name, e);
                        var c = r.params;
                        c && void 0 === c[0] && c.pathMatch && (c[0] = c.pathMatch)
                    }
                    var h = this.router.resolve(r);
                    return h.route.name ? h : this.router.resolve(t)
                }
            }
        }

        function ie(t) {
            var e = this.getRouteBaseName();
            if (!e) return "";
            var n = this.i18n,
                r = this.route,
                o = this.store,
                l = r.params,
                c = Object($t.a)(r, Jt),
                h = {};
            Lt.vuex && Lt.vuex.syncRouteParams && o && (h = o.getters["".concat(Lt.vuex.moduleName, "/localeRouteParams")](t));
            var d = Object.assign({}, c, {
                    name: e,
                    params: Qt(Qt(Qt({}, l), h), {}, {
                        0: l.pathMatch
                    })
                }),
                path = this.localePath(d, t);
            if (n.differentDomains) {
                var f = {
                        differentDomains: n.differentDomains,
                        normalizedLocales: Lt.normalizedLocales
                    },
                    m = qt(t, this.req, f);
                m && (path = m + path)
            }
            return path
        }

        function oe(t) {
            var e = void 0 !== t ? t : this.route;
            if (e && e.name) return e.name.split(Lt.routesNameSeparator)[0]
        }

        function ae(t, e) {
            var n = t + (Lt.strategy === Et.STRATEGIES.NO_PREFIX ? "" : Lt.routesNameSeparator + e);
            return e === Lt.defaultLocale && Lt.strategy === Et.STRATEGIES.PREFIX_AND_DEFAULT && (n += Lt.routesNameSeparator + Lt.defaultLocaleRouteNameSuffix), n
        }
        var se = function(t) {
                return function() {
                    var e = {
                        getRouteBaseName: this.getRouteBaseName,
                        i18n: this.$i18n,
                        localePath: this.localePath,
                        localeRoute: this.localeRoute,
                        localeLocation: this.localeLocation,
                        req: null,
                        route: this.$route,
                        router: this.$router,
                        store: this.$store
                    };
                    return t.call.apply(t, [e].concat(Array.prototype.slice.call(arguments)))
                }
            },
            le = function(t, e) {
                return function() {
                    var n = t.app,
                        r = (t.req, t.route),
                        o = t.store,
                        l = {
                            getRouteBaseName: n.getRouteBaseName,
                            i18n: n.i18n,
                            localePath: n.localePath,
                            localeLocation: n.localeLocation,
                            localeRoute: n.localeRoute,
                            req: null,
                            route: r,
                            router: n.router,
                            store: o
                        };
                    return e.call.apply(e, [l].concat(Array.prototype.slice.call(arguments)))
                }
            },
            ce = {
                install: function(t) {
                    t.mixin({
                        methods: {
                            localePath: se(te),
                            localeRoute: se(ee),
                            localeLocation: se(ne),
                            switchLocalePath: se(ie),
                            getRouteBaseName: se(oe)
                        }
                    })
                }
            },
            ue = function(t) {
                c.a.use(ce);
                var e = t.app,
                    n = t.store;
                e.localePath = t.localePath = le(t, te), e.localeRoute = t.localeRoute = le(t, ee), e.localeLocation = t.localeLocation = le(t, ne), e.switchLocalePath = t.switchLocalePath = le(t, ie), e.getRouteBaseName = t.getRouteBaseName = le(t, oe), n && (n.localePath = e.localePath, n.localeRoute = e.localeRoute, n.localeLocation = e.localeLocation, n.switchLocalePath = e.switchLocalePath, n.getRouteBaseName = e.getRouteBaseName)
            },
            he = (n(115), ["compactDisplay", "currency", "currencyDisplay", "currencySign", "localeMatcher", "notation", "numberingSystem", "signDisplay", "style", "unit", "unitDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits"]);

        function de(t, e) {
            "undefined" != typeof console && (console.warn("[vue-i18n] " + t), e && console.warn(e.stack))
        }
        var pe = Array.isArray;

        function fe(t) {
            return null !== t && "object" == typeof t
        }

        function me(t) {
            return "string" == typeof t
        }
        var ge = Object.prototype.toString;

        function ve(t) {
            return "[object Object]" === ge.call(t)
        }

        function ye(t) {
            return null == t
        }

        function _e(t) {
            return "function" == typeof t
        }

        function xe() {
            for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
            var n = null,
                r = null;
            return 1 === t.length ? fe(t[0]) || pe(t[0]) ? r = t[0] : "string" == typeof t[0] && (n = t[0]) : 2 === t.length && ("string" == typeof t[0] && (n = t[0]), (fe(t[1]) || pe(t[1])) && (r = t[1])), {
                locale: n,
                params: r
            }
        }

        function be(t) {
            return JSON.parse(JSON.stringify(t))
        }

        function we(t, e) {
            return !!~t.indexOf(e)
        }
        var Me = Object.prototype.hasOwnProperty;

        function Se(t, e) {
            return Me.call(t, e)
        }

        function Te(t) {
            for (var e = arguments, output = Object(t), i = 1; i < arguments.length; i++) {
                var source = e[i];
                if (null != source) {
                    var n = void 0;
                    for (n in source) Se(source, n) && (fe(source[n]) ? output[n] = Te(output[n], source[n]) : output[n] = source[n])
                }
            }
            return output
        }

        function Ee(a, b) {
            if (a === b) return !0;
            var t = fe(a),
                e = fe(b);
            if (!t || !e) return !t && !e && String(a) === String(b);
            try {
                var n = pe(a),
                    r = pe(b);
                if (n && r) return a.length === b.length && a.every((function(t, i) {
                    return Ee(t, b[i])
                }));
                if (n || r) return !1;
                var o = Object.keys(a),
                    l = Object.keys(b);
                return o.length === l.length && o.every((function(t) {
                    return Ee(a[t], b[t])
                }))
            } catch (t) {
                return !1
            }
        }

        function Ae(t) {
            return null != t && Object.keys(t).forEach((function(e) {
                "string" == typeof t[e] && (t[e] = t[e].replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;"))
            })), t
        }
        var Ce = {
            name: "i18n",
            functional: !0,
            props: {
                tag: {
                    type: [String, Boolean, Object],
                    default: "span"
                },
                path: {
                    type: String,
                    required: !0
                },
                locale: {
                    type: String
                },
                places: {
                    type: [Array, Object]
                }
            },
            render: function(t, e) {
                var data = e.data,
                    n = e.parent,
                    r = e.props,
                    o = e.slots,
                    l = n.$i18n;
                if (l) {
                    var path = r.path,
                        c = r.locale,
                        h = r.places,
                        d = o(),
                        f = l.i(path, c, function(t) {
                            var e;
                            for (e in t)
                                if ("default" !== e) return !1;
                            return Boolean(e)
                        }(d) || h ? function(t, e) {
                            var n = e ? function(t) {
                                0;
                                return Array.isArray(t) ? t.reduce(ke, {}) : Object.assign({}, t)
                            }(e) : {};
                            if (!t) return n;
                            var r = (t = t.filter((function(t) {
                                return t.tag || "" !== t.text.trim()
                            }))).every(Re);
                            0;
                            return t.reduce(r ? Le : ke, n)
                        }(d.default, h) : d),
                        m = r.tag && !0 !== r.tag || !1 === r.tag ? r.tag : "span";
                    return m ? t(m, data, f) : f
                }
            }
        };

        function Le(t, e) {
            return e.data && e.data.attrs && e.data.attrs.place && (t[e.data.attrs.place] = e), t
        }

        function ke(t, e, n) {
            return t[n] = e, t
        }

        function Re(t) {
            return Boolean(t.data && t.data.attrs && t.data.attrs.place)
        }
        var Pe, De = {
            name: "i18n-n",
            functional: !0,
            props: {
                tag: {
                    type: [String, Boolean, Object],
                    default: "span"
                },
                value: {
                    type: Number,
                    required: !0
                },
                format: {
                    type: [String, Object]
                },
                locale: {
                    type: String
                }
            },
            render: function(t, e) {
                var n = e.props,
                    r = e.parent,
                    data = e.data,
                    o = r.$i18n;
                if (!o) return null;
                var l = null,
                    c = null;
                me(n.format) ? l = n.format : fe(n.format) && (n.format.key && (l = n.format.key), c = Object.keys(n.format).reduce((function(t, e) {
                    var r;
                    return we(he, e) ? Object.assign({}, t, ((r = {})[e] = n.format[e], r)) : t
                }), null));
                var h = n.locale || o.locale,
                    d = o._ntp(n.value, h, l, c),
                    f = d.map((function(t, e) {
                        var n, slot = data.scopedSlots && data.scopedSlots[t.type];
                        return slot ? slot(((n = {})[t.type] = t.value, n.index = e, n.parts = d, n)) : t.value
                    })),
                    m = n.tag && !0 !== n.tag || !1 === n.tag ? n.tag : "span";
                return m ? t(m, {
                    attrs: data.attrs,
                    class: data.class,
                    staticClass: data.staticClass
                }, f) : f
            }
        };

        function Oe(t, e, n) {
            Fe(t, n) && ze(t, e, n)
        }

        function Ie(t, e, n, r) {
            if (Fe(t, n)) {
                var o = n.context.$i18n;
                (function(t, e) {
                    var n = e.context;
                    return t._locale === n.$i18n.locale
                })(t, n) && Ee(e.value, e.oldValue) && Ee(t._localeMessage, o.getLocaleMessage(o.locale)) || ze(t, e, n)
            }
        }

        function Ne(t, e, n, r) {
            if (n.context) {
                var o = n.context.$i18n || {};
                e.modifiers.preserve || o.preserveDirectiveContent || (t.textContent = ""), t._vt = void 0, delete t._vt, t._locale = void 0, delete t._locale, t._localeMessage = void 0, delete t._localeMessage
            } else de("Vue instance does not exists in VNode context")
        }

        function Fe(t, e) {
            var n = e.context;
            return n ? !!n.$i18n || (de("VueI18n instance does not exists in Vue instance"), !1) : (de("Vue instance does not exists in VNode context"), !1)
        }

        function ze(t, e, n) {
            var r, o, l = function(t) {
                    var path, e, n, r;
                    me(t) ? path = t : ve(t) && (path = t.path, e = t.locale, n = t.args, r = t.choice);
                    return {
                        path: path,
                        locale: e,
                        args: n,
                        choice: r
                    }
                }(e.value),
                path = l.path,
                c = l.locale,
                h = l.args,
                d = l.choice;
            if (path || c || h)
                if (path) {
                    var f = n.context;
                    t._vt = t.textContent = null != d ? (r = f.$i18n).tc.apply(r, [path, d].concat(Be(c, h))) : (o = f.$i18n).t.apply(o, [path].concat(Be(c, h))), t._locale = f.$i18n.locale, t._localeMessage = f.$i18n.getLocaleMessage(f.$i18n.locale)
                } else de("`path` is required in v-t directive");
            else de("value type not supported")
        }

        function Be(t, e) {
            var n = [];
            return t && n.push(t), e && (Array.isArray(e) || ve(e)) && n.push(e), n
        }

        function Ue(t, e) {
            void 0 === e && (e = {
                bridge: !1
            }), Ue.installed = !0;
            (Pe = t).version && Number(Pe.version.split(".")[0]);
            (function(t) {
                t.prototype.hasOwnProperty("$i18n") || Object.defineProperty(t.prototype, "$i18n", {
                    get: function() {
                        return this._i18n
                    }
                }), t.prototype.$t = function(t) {
                    for (var e = [], n = arguments.length - 1; n-- > 0;) e[n] = arguments[n + 1];
                    var r = this.$i18n;
                    return r._t.apply(r, [t, r.locale, r._getMessages(), this].concat(e))
                }, t.prototype.$tc = function(t, e) {
                    for (var n = [], r = arguments.length - 2; r-- > 0;) n[r] = arguments[r + 2];
                    var o = this.$i18n;
                    return o._tc.apply(o, [t, o.locale, o._getMessages(), this, e].concat(n))
                }, t.prototype.$te = function(t, e) {
                    var n = this.$i18n;
                    return n._te(t, n.locale, n._getMessages(), e)
                }, t.prototype.$d = function(t) {
                    for (var e, n = [], r = arguments.length - 1; r-- > 0;) n[r] = arguments[r + 1];
                    return (e = this.$i18n).d.apply(e, [t].concat(n))
                }, t.prototype.$n = function(t) {
                    for (var e, n = [], r = arguments.length - 1; r-- > 0;) n[r] = arguments[r + 1];
                    return (e = this.$i18n).n.apply(e, [t].concat(n))
                }
            })(Pe), Pe.mixin(function(t) {
                function e() {
                    this !== this.$root && this.$options.__INTLIFY_META__ && this.$el && this.$el.setAttribute("data-intlify", this.$options.__INTLIFY_META__)
                }
                return void 0 === t && (t = !1), t ? {
                    mounted: e
                } : {
                    beforeCreate: function() {
                        var t = this.$options;
                        if (t.i18n = t.i18n || (t.__i18nBridge || t.__i18n ? {} : null), t.i18n) {
                            if (t.i18n instanceof nn) {
                                if (t.__i18nBridge || t.__i18n) try {
                                    var e = t.i18n && t.i18n.messages ? t.i18n.messages : {};
                                    (t.__i18nBridge || t.__i18n).forEach((function(t) {
                                        e = Te(e, JSON.parse(t))
                                    })), Object.keys(e).forEach((function(n) {
                                        t.i18n.mergeLocaleMessage(n, e[n])
                                    }))
                                } catch (t) {}
                                this._i18n = t.i18n, this._i18nWatcher = this._i18n.watchI18nData()
                            } else if (ve(t.i18n)) {
                                var n = this.$root && this.$root.$i18n && this.$root.$i18n instanceof nn ? this.$root.$i18n : null;
                                if (n && (t.i18n.root = this.$root, t.i18n.formatter = n.formatter, t.i18n.fallbackLocale = n.fallbackLocale, t.i18n.formatFallbackMessages = n.formatFallbackMessages, t.i18n.silentTranslationWarn = n.silentTranslationWarn, t.i18n.silentFallbackWarn = n.silentFallbackWarn, t.i18n.pluralizationRules = n.pluralizationRules, t.i18n.preserveDirectiveContent = n.preserveDirectiveContent), t.__i18nBridge || t.__i18n) try {
                                    var r = t.i18n && t.i18n.messages ? t.i18n.messages : {};
                                    (t.__i18nBridge || t.__i18n).forEach((function(t) {
                                        r = Te(r, JSON.parse(t))
                                    })), t.i18n.messages = r
                                } catch (t) {}
                                var o = t.i18n.sharedMessages;
                                o && ve(o) && (t.i18n.messages = Te(t.i18n.messages, o)), this._i18n = new nn(t.i18n), this._i18nWatcher = this._i18n.watchI18nData(), (void 0 === t.i18n.sync || t.i18n.sync) && (this._localeWatcher = this.$i18n.watchLocale()), n && n.onComponentInstanceCreated(this._i18n)
                            }
                        } else this.$root && this.$root.$i18n && this.$root.$i18n instanceof nn ? this._i18n = this.$root.$i18n : t.parent && t.parent.$i18n && t.parent.$i18n instanceof nn && (this._i18n = t.parent.$i18n)
                    },
                    beforeMount: function() {
                        var t = this.$options;
                        t.i18n = t.i18n || (t.__i18nBridge || t.__i18n ? {} : null), t.i18n ? (t.i18n instanceof nn || ve(t.i18n)) && (this._i18n.subscribeDataChanging(this), this._subscribing = !0) : (this.$root && this.$root.$i18n && this.$root.$i18n instanceof nn || t.parent && t.parent.$i18n && t.parent.$i18n instanceof nn) && (this._i18n.subscribeDataChanging(this), this._subscribing = !0)
                    },
                    mounted: e,
                    beforeDestroy: function() {
                        if (this._i18n) {
                            var t = this;
                            this.$nextTick((function() {
                                t._subscribing && (t._i18n.unsubscribeDataChanging(t), delete t._subscribing), t._i18nWatcher && (t._i18nWatcher(), t._i18n.destroyVM(), delete t._i18nWatcher), t._localeWatcher && (t._localeWatcher(), delete t._localeWatcher)
                            }))
                        }
                    }
                }
            }(e.bridge)), Pe.directive("t", {
                bind: Oe,
                update: Ie,
                unbind: Ne
            }), Pe.component(Ce.name, Ce), Pe.component(De.name, De), Pe.config.optionMergeStrategies.i18n = function(t, e) {
                return void 0 === e ? t : e
            }
        }
        var He = function() {
            this._caches = Object.create(null)
        };
        He.prototype.interpolate = function(t, e) {
            if (!e) return [t];
            var n = this._caches[t];
            return n || (n = function(t) {
                    var e = [],
                        n = 0,
                        text = "";
                    for (; n < t.length;) {
                        var r = t[n++];
                        if ("{" === r) {
                            text && e.push({
                                type: "text",
                                value: text
                            }), text = "";
                            var sub = "";
                            for (r = t[n++]; void 0 !== r && "}" !== r;) sub += r, r = t[n++];
                            var o = "}" === r,
                                l = je.test(sub) ? "list" : o && Ve.test(sub) ? "named" : "unknown";
                            e.push({
                                value: sub,
                                type: l
                            })
                        } else "%" === r ? "{" !== t[n] && (text += r) : text += r
                    }
                    return text && e.push({
                        type: "text",
                        value: text
                    }), e
                }(t), this._caches[t] = n),
                function(t, e) {
                    var n = [],
                        r = 0,
                        o = Array.isArray(e) ? "list" : fe(e) ? "named" : "unknown";
                    if ("unknown" === o) return n;
                    for (; r < t.length;) {
                        var l = t[r];
                        switch (l.type) {
                            case "text":
                                n.push(l.value);
                                break;
                            case "list":
                                n.push(e[parseInt(l.value, 10)]);
                                break;
                            case "named":
                                "named" === o && n.push(e[l.value])
                        }
                        r++
                    }
                    return n
                }(n, e)
        };
        var je = /^(?:\d)+/,
            Ve = /^(?:\w)+/;
        var Ge = [];
        Ge[0] = {
            ws: [0],
            ident: [3, 0],
            "[": [4],
            eof: [7]
        }, Ge[1] = {
            ws: [1],
            ".": [2],
            "[": [4],
            eof: [7]
        }, Ge[2] = {
            ws: [2],
            ident: [3, 0],
            0: [3, 0],
            number: [3, 0]
        }, Ge[3] = {
            ident: [3, 0],
            0: [3, 0],
            number: [3, 0],
            ws: [1, 1],
            ".": [2, 1],
            "[": [4, 1],
            eof: [7, 1]
        }, Ge[4] = {
            "'": [5, 0],
            '"': [6, 0],
            "[": [4, 2],
            "]": [1, 3],
            eof: 8,
            else: [4, 0]
        }, Ge[5] = {
            "'": [4, 0],
            eof: 8,
            else: [5, 0]
        }, Ge[6] = {
            '"': [4, 0],
            eof: 8,
            else: [6, 0]
        };
        var We = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

        function qe(t) {
            if (null == t) return "eof";
            switch (t.charCodeAt(0)) {
                case 91:
                case 93:
                case 46:
                case 34:
                case 39:
                    return t;
                case 95:
                case 36:
                case 45:
                    return "ident";
                case 9:
                case 10:
                case 13:
                case 160:
                case 65279:
                case 8232:
                case 8233:
                    return "ws"
            }
            return "ident"
        }

        function Xe(path) {
            var t, a, e, n = path.trim();
            return ("0" !== path.charAt(0) || !isNaN(path)) && (e = n, We.test(e) ? (a = (t = n).charCodeAt(0)) !== t.charCodeAt(t.length - 1) || 34 !== a && 39 !== a ? t : t.slice(1, -1) : "*" + n)
        }
        var $e = function() {
            this._cache = Object.create(null)
        };
        $e.prototype.parsePath = function(path) {
            var t = this._cache[path];
            return t || (t = function(path) {
                var t, e, n, r, o, l, c, h = [],
                    d = -1,
                    f = 0,
                    m = 0,
                    v = [];

                function y() {
                    var t = path[d + 1];
                    if (5 === f && "'" === t || 6 === f && '"' === t) return d++, n = "\\" + t, v[0](), !0
                }
                for (v[1] = function() {
                        void 0 !== e && (h.push(e), e = void 0)
                    }, v[0] = function() {
                        void 0 === e ? e = n : e += n
                    }, v[2] = function() {
                        v[0](), m++
                    }, v[3] = function() {
                        if (m > 0) m--, f = 4, v[0]();
                        else {
                            if (m = 0, void 0 === e) return !1;
                            if (!1 === (e = Xe(e))) return !1;
                            v[1]()
                        }
                    }; null !== f;)
                    if (d++, "\\" !== (t = path[d]) || !y()) {
                        if (r = qe(t), 8 === (o = (c = Ge[f])[r] || c.else || 8)) return;
                        if (f = o[0], (l = v[o[1]]) && (n = void 0 === (n = o[2]) ? t : n, !1 === l())) return;
                        if (7 === f) return h
                    }
            }(path), t && (this._cache[path] = t)), t || []
        }, $e.prototype.getPathValue = function(t, path) {
            if (!fe(t)) return null;
            var e = this.parsePath(path);
            if (0 === e.length) return null;
            for (var n = e.length, r = t, i = 0; i < n;) {
                var o = r[e[i]];
                if (null == o) return null;
                r = o, i++
            }
            return r
        };
        var Ye, Ze = /<\/?[\w\s="/.':;#-\/]+>/,
            Je = /(?:@(?:\.[a-z]+)?:(?:[\w\-_|./]+|\([\w\-_|./]+\)))/g,
            Ke = /^@(?:\.([a-z]+))?:/,
            Qe = /[()]/g,
            tn = {
                upper: function(t) {
                    return t.toLocaleUpperCase()
                },
                lower: function(t) {
                    return t.toLocaleLowerCase()
                },
                capitalize: function(t) {
                    return "" + t.charAt(0).toLocaleUpperCase() + t.substr(1)
                }
            },
            en = new He,
            nn = function(t) {
                var e = this;
                void 0 === t && (t = {}), !Pe && "undefined" != typeof window && window.Vue && Ue(window.Vue);
                var n = t.locale || "en-US",
                    r = !1 !== t.fallbackLocale && (t.fallbackLocale || "en-US"),
                    o = t.messages || {},
                    l = t.dateTimeFormats || t.datetimeFormats || {},
                    c = t.numberFormats || {};
                this._vm = null, this._formatter = t.formatter || en, this._modifiers = t.modifiers || {}, this._missing = t.missing || null, this._root = t.root || null, this._sync = void 0 === t.sync || !!t.sync, this._fallbackRoot = void 0 === t.fallbackRoot || !!t.fallbackRoot, this._formatFallbackMessages = void 0 !== t.formatFallbackMessages && !!t.formatFallbackMessages, this._silentTranslationWarn = void 0 !== t.silentTranslationWarn && t.silentTranslationWarn, this._silentFallbackWarn = void 0 !== t.silentFallbackWarn && !!t.silentFallbackWarn, this._dateTimeFormatters = {}, this._numberFormatters = {}, this._path = new $e, this._dataListeners = new Set, this._componentInstanceCreatedListener = t.componentInstanceCreatedListener || null, this._preserveDirectiveContent = void 0 !== t.preserveDirectiveContent && !!t.preserveDirectiveContent, this.pluralizationRules = t.pluralizationRules || {}, this._warnHtmlInMessage = t.warnHtmlInMessage || "off", this._postTranslation = t.postTranslation || null, this._escapeParameterHtml = t.escapeParameterHtml || !1, "__VUE_I18N_BRIDGE__" in t && (this.__VUE_I18N_BRIDGE__ = t.__VUE_I18N_BRIDGE__), this.getChoiceIndex = function(t, n) {
                    var r = Object.getPrototypeOf(e);
                    if (r && r.getChoiceIndex) return r.getChoiceIndex.call(e, t, n);
                    var o, l;
                    return e.locale in e.pluralizationRules ? e.pluralizationRules[e.locale].apply(e, [t, n]) : (o = t, l = n, o = Math.abs(o), 2 === l ? o ? o > 1 ? 1 : 0 : 1 : o ? Math.min(o, 2) : 0)
                }, this._exist = function(t, n) {
                    return !(!t || !n) && (!ye(e._path.getPathValue(t, n)) || !!t[n])
                }, "warn" !== this._warnHtmlInMessage && "error" !== this._warnHtmlInMessage || Object.keys(o).forEach((function(t) {
                    e._checkLocaleMessage(t, e._warnHtmlInMessage, o[t])
                })), this._initVM({
                    locale: n,
                    fallbackLocale: r,
                    messages: o,
                    dateTimeFormats: l,
                    numberFormats: c
                })
            },
            rn = {
                vm: {
                    configurable: !0
                },
                messages: {
                    configurable: !0
                },
                dateTimeFormats: {
                    configurable: !0
                },
                numberFormats: {
                    configurable: !0
                },
                availableLocales: {
                    configurable: !0
                },
                locale: {
                    configurable: !0
                },
                fallbackLocale: {
                    configurable: !0
                },
                formatFallbackMessages: {
                    configurable: !0
                },
                missing: {
                    configurable: !0
                },
                formatter: {
                    configurable: !0
                },
                silentTranslationWarn: {
                    configurable: !0
                },
                silentFallbackWarn: {
                    configurable: !0
                },
                preserveDirectiveContent: {
                    configurable: !0
                },
                warnHtmlInMessage: {
                    configurable: !0
                },
                postTranslation: {
                    configurable: !0
                },
                sync: {
                    configurable: !0
                }
            };
        nn.prototype._checkLocaleMessage = function(t, e, n) {
            var r = function(t, e, n, o) {
                if (ve(n)) Object.keys(n).forEach((function(l) {
                    var c = n[l];
                    ve(c) ? (o.push(l), o.push("."), r(t, e, c, o), o.pop(), o.pop()) : (o.push(l), r(t, e, c, o), o.pop())
                }));
                else if (pe(n)) n.forEach((function(n, l) {
                    ve(n) ? (o.push("[" + l + "]"), o.push("."), r(t, e, n, o), o.pop(), o.pop()) : (o.push("[" + l + "]"), r(t, e, n, o), o.pop())
                }));
                else if (me(n)) {
                    if (Ze.test(n)) {
                        var l = "Detected HTML in message '" + n + "' of keypath '" + o.join("") + "' at '" + e + "'. Consider component interpolation with '<i18n>' to avoid XSS. See https://bit.ly/2ZqJzkp";
                        "warn" === t ? de(l) : "error" === t && function(t, e) {
                            "undefined" != typeof console && (console.error("[vue-i18n] " + t), e && console.error(e.stack))
                        }(l)
                    }
                }
            };
            r(e, t, n, [])
        }, nn.prototype._initVM = function(data) {
            var t = Pe.config.silent;
            Pe.config.silent = !0, this._vm = new Pe({
                data: data,
                __VUE18N__INSTANCE__: !0
            }), Pe.config.silent = t
        }, nn.prototype.destroyVM = function() {
            this._vm.$destroy()
        }, nn.prototype.subscribeDataChanging = function(t) {
            this._dataListeners.add(t)
        }, nn.prototype.unsubscribeDataChanging = function(t) {
            ! function(t, e) {
                if (t.delete(e));
            }(this._dataListeners, t)
        }, nn.prototype.watchI18nData = function() {
            var t = this;
            return this._vm.$watch("$data", (function() {
                for (var e, n, r = (e = t._dataListeners, n = [], e.forEach((function(a) {
                        return n.push(a)
                    })), n), i = r.length; i--;) Pe.nextTick((function() {
                    r[i] && r[i].$forceUpdate()
                }))
            }), {
                deep: !0
            })
        }, nn.prototype.watchLocale = function() {
            if (!this._sync || !this._root) return null;
            var t = this._vm;
            return this._root.$i18n.vm.$watch("locale", (function(e) {
                t.$set(t, "locale", e), t.$forceUpdate()
            }), {
                immediate: !0
            })
        }, nn.prototype.onComponentInstanceCreated = function(t) {
            this._componentInstanceCreatedListener && this._componentInstanceCreatedListener(t, this)
        }, rn.vm.get = function() {
            return this._vm
        }, rn.messages.get = function() {
            return be(this._getMessages())
        }, rn.dateTimeFormats.get = function() {
            return be(this._getDateTimeFormats())
        }, rn.numberFormats.get = function() {
            return be(this._getNumberFormats())
        }, rn.availableLocales.get = function() {
            return Object.keys(this.messages).sort()
        }, rn.locale.get = function() {
            return this._vm.locale
        }, rn.locale.set = function(t) {
            this._vm.$set(this._vm, "locale", t)
        }, rn.fallbackLocale.get = function() {
            return this._vm.fallbackLocale
        }, rn.fallbackLocale.set = function(t) {
            this._localeChainCache = {}, this._vm.$set(this._vm, "fallbackLocale", t)
        }, rn.formatFallbackMessages.get = function() {
            return this._formatFallbackMessages
        }, rn.formatFallbackMessages.set = function(t) {
            this._formatFallbackMessages = t
        }, rn.missing.get = function() {
            return this._missing
        }, rn.missing.set = function(t) {
            this._missing = t
        }, rn.formatter.get = function() {
            return this._formatter
        }, rn.formatter.set = function(t) {
            this._formatter = t
        }, rn.silentTranslationWarn.get = function() {
            return this._silentTranslationWarn
        }, rn.silentTranslationWarn.set = function(t) {
            this._silentTranslationWarn = t
        }, rn.silentFallbackWarn.get = function() {
            return this._silentFallbackWarn
        }, rn.silentFallbackWarn.set = function(t) {
            this._silentFallbackWarn = t
        }, rn.preserveDirectiveContent.get = function() {
            return this._preserveDirectiveContent
        }, rn.preserveDirectiveContent.set = function(t) {
            this._preserveDirectiveContent = t
        }, rn.warnHtmlInMessage.get = function() {
            return this._warnHtmlInMessage
        }, rn.warnHtmlInMessage.set = function(t) {
            var e = this,
                n = this._warnHtmlInMessage;
            if (this._warnHtmlInMessage = t, n !== t && ("warn" === t || "error" === t)) {
                var r = this._getMessages();
                Object.keys(r).forEach((function(t) {
                    e._checkLocaleMessage(t, e._warnHtmlInMessage, r[t])
                }))
            }
        }, rn.postTranslation.get = function() {
            return this._postTranslation
        }, rn.postTranslation.set = function(t) {
            this._postTranslation = t
        }, rn.sync.get = function() {
            return this._sync
        }, rn.sync.set = function(t) {
            this._sync = t
        }, nn.prototype._getMessages = function() {
            return this._vm.messages
        }, nn.prototype._getDateTimeFormats = function() {
            return this._vm.dateTimeFormats
        }, nn.prototype._getNumberFormats = function() {
            return this._vm.numberFormats
        }, nn.prototype._warnDefault = function(t, e, n, r, o, l) {
            if (!ye(n)) return n;
            if (this._missing) {
                var c = this._missing.apply(null, [t, e, r, o]);
                if (me(c)) return c
            } else 0;
            if (this._formatFallbackMessages) {
                var h = xe.apply(void 0, o);
                return this._render(e, l, h.params, e)
            }
            return e
        }, nn.prototype._isFallbackRoot = function(t) {
            return !t && !ye(this._root) && this._fallbackRoot
        }, nn.prototype._isSilentFallbackWarn = function(t) {
            return this._silentFallbackWarn instanceof RegExp ? this._silentFallbackWarn.test(t) : this._silentFallbackWarn
        }, nn.prototype._isSilentFallback = function(t, e) {
            return this._isSilentFallbackWarn(e) && (this._isFallbackRoot() || t !== this.fallbackLocale)
        }, nn.prototype._isSilentTranslationWarn = function(t) {
            return this._silentTranslationWarn instanceof RegExp ? this._silentTranslationWarn.test(t) : this._silentTranslationWarn
        }, nn.prototype._interpolate = function(t, e, n, r, o, l, c) {
            if (!e) return null;
            var h, d = this._path.getPathValue(e, n);
            if (pe(d) || ve(d)) return d;
            if (ye(d)) {
                if (!ve(e)) return null;
                if (!me(h = e[n]) && !_e(h)) return null
            } else {
                if (!me(d) && !_e(d)) return null;
                h = d
            }
            return me(h) && (h.indexOf("@:") >= 0 || h.indexOf("@.") >= 0) && (h = this._link(t, e, h, r, "raw", l, c)), this._render(h, o, l, n)
        }, nn.prototype._link = function(t, e, n, r, o, l, c) {
            var h = n,
                d = h.match(Je);
            for (var f in d)
                if (d.hasOwnProperty(f)) {
                    var link = d[f],
                        m = link.match(Ke),
                        v = m[0],
                        y = m[1],
                        _ = link.replace(v, "").replace(Qe, "");
                    if (we(c, _)) return h;
                    c.push(_);
                    var x = this._interpolate(t, e, _, r, "raw" === o ? "string" : o, "raw" === o ? void 0 : l, c);
                    if (this._isFallbackRoot(x)) {
                        if (!this._root) throw Error("unexpected error");
                        var w = this._root.$i18n;
                        x = w._translate(w._getMessages(), w.locale, w.fallbackLocale, _, r, o, l)
                    }
                    x = this._warnDefault(t, _, x, r, pe(l) ? l : [l], o), this._modifiers.hasOwnProperty(y) ? x = this._modifiers[y](x) : tn.hasOwnProperty(y) && (x = tn[y](x)), c.pop(), h = x ? h.replace(link, x) : h
                }
            return h
        }, nn.prototype._createMessageContext = function(t, e, path, n) {
            var r = this,
                o = pe(t) ? t : [],
                l = fe(t) ? t : {},
                c = this._getMessages(),
                h = this.locale;
            return {
                list: function(t) {
                    return o[t]
                },
                named: function(t) {
                    return l[t]
                },
                values: t,
                formatter: e,
                path: path,
                messages: c,
                locale: h,
                linked: function(t) {
                    return r._interpolate(h, c[h] || {}, t, null, n, void 0, [t])
                }
            }
        }, nn.prototype._render = function(t, e, n, path) {
            if (_e(t)) return t(this._createMessageContext(n, this._formatter || en, path, e));
            var r = this._formatter.interpolate(t, n, path);
            return r || (r = en.interpolate(t, n, path)), "string" !== e || me(r) ? r : r.join("")
        }, nn.prototype._appendItemToChain = function(t, e, n) {
            var r = !1;
            return we(t, e) || (r = !0, e && (r = "!" !== e[e.length - 1], e = e.replace(/!/g, ""), t.push(e), n && n[e] && (r = n[e]))), r
        }, nn.prototype._appendLocaleToChain = function(t, e, n) {
            var r, o = e.split("-");
            do {
                var l = o.join("-");
                r = this._appendItemToChain(t, l, n), o.splice(-1, 1)
            } while (o.length && !0 === r);
            return r
        }, nn.prototype._appendBlockToChain = function(t, e, n) {
            for (var r = !0, i = 0; i < e.length && "boolean" == typeof r; i++) {
                var o = e[i];
                me(o) && (r = this._appendLocaleToChain(t, o, n))
            }
            return r
        }, nn.prototype._getLocaleChain = function(t, e) {
            if ("" === t) return [];
            this._localeChainCache || (this._localeChainCache = {});
            var n = this._localeChainCache[t];
            if (!n) {
                e || (e = this.fallbackLocale), n = [];
                for (var r, o = [t]; pe(o);) o = this._appendBlockToChain(n, o, e);
                (o = me(r = pe(e) ? e : fe(e) ? e.default ? e.default : null : e) ? [r] : r) && this._appendBlockToChain(n, o, null), this._localeChainCache[t] = n
            }
            return n
        }, nn.prototype._translate = function(t, e, n, r, o, l, c) {
            for (var h, d = this._getLocaleChain(e, n), i = 0; i < d.length; i++) {
                var f = d[i];
                if (!ye(h = this._interpolate(f, t[f], r, o, l, c, [r]))) return h
            }
            return null
        }, nn.prototype._t = function(t, e, n, r) {
            for (var o, l = [], c = arguments.length - 4; c-- > 0;) l[c] = arguments[c + 4];
            if (!t) return "";
            var h = xe.apply(void 0, l);
            this._escapeParameterHtml && (h.params = Ae(h.params));
            var d = h.locale || e,
                f = this._translate(n, d, this.fallbackLocale, t, r, "string", h.params);
            if (this._isFallbackRoot(f)) {
                if (!this._root) throw Error("unexpected error");
                return (o = this._root).$t.apply(o, [t].concat(l))
            }
            return f = this._warnDefault(d, t, f, r, l, "string"), this._postTranslation && null != f && (f = this._postTranslation(f, t)), f
        }, nn.prototype.t = function(t) {
            for (var e, n = [], r = arguments.length - 1; r-- > 0;) n[r] = arguments[r + 1];
            return (e = this)._t.apply(e, [t, this.locale, this._getMessages(), null].concat(n))
        }, nn.prototype._i = function(t, e, n, r, o) {
            var l = this._translate(n, e, this.fallbackLocale, t, r, "raw", o);
            if (this._isFallbackRoot(l)) {
                if (!this._root) throw Error("unexpected error");
                return this._root.$i18n.i(t, e, o)
            }
            return this._warnDefault(e, t, l, r, [o], "raw")
        }, nn.prototype.i = function(t, e, n) {
            return t ? (me(e) || (e = this.locale), this._i(t, e, this._getMessages(), null, n)) : ""
        }, nn.prototype._tc = function(t, e, n, r, o) {
            for (var l, c = [], h = arguments.length - 5; h-- > 0;) c[h] = arguments[h + 5];
            if (!t) return "";
            void 0 === o && (o = 1);
            var d = {
                    count: o,
                    n: o
                },
                f = xe.apply(void 0, c);
            return f.params = Object.assign(d, f.params), c = null === f.locale ? [f.params] : [f.locale, f.params], this.fetchChoice((l = this)._t.apply(l, [t, e, n, r].concat(c)), o)
        }, nn.prototype.fetchChoice = function(t, e) {
            if (!t || !me(t)) return null;
            var n = t.split("|");
            return n[e = this.getChoiceIndex(e, n.length)] ? n[e].trim() : t
        }, nn.prototype.tc = function(t, e) {
            for (var n, r = [], o = arguments.length - 2; o-- > 0;) r[o] = arguments[o + 2];
            return (n = this)._tc.apply(n, [t, this.locale, this._getMessages(), null, e].concat(r))
        }, nn.prototype._te = function(t, e, n) {
            for (var r = [], o = arguments.length - 3; o-- > 0;) r[o] = arguments[o + 3];
            var l = xe.apply(void 0, r).locale || e;
            return this._exist(n[l], t)
        }, nn.prototype.te = function(t, e) {
            return this._te(t, this.locale, this._getMessages(), e)
        }, nn.prototype.getLocaleMessage = function(t) {
            return be(this._vm.messages[t] || {})
        }, nn.prototype.setLocaleMessage = function(t, e) {
            "warn" !== this._warnHtmlInMessage && "error" !== this._warnHtmlInMessage || this._checkLocaleMessage(t, this._warnHtmlInMessage, e), this._vm.$set(this._vm.messages, t, e)
        }, nn.prototype.mergeLocaleMessage = function(t, e) {
            "warn" !== this._warnHtmlInMessage && "error" !== this._warnHtmlInMessage || this._checkLocaleMessage(t, this._warnHtmlInMessage, e), this._vm.$set(this._vm.messages, t, Te(void 0 !== this._vm.messages[t] && Object.keys(this._vm.messages[t]).length ? Object.assign({}, this._vm.messages[t]) : {}, e))
        }, nn.prototype.getDateTimeFormat = function(t) {
            return be(this._vm.dateTimeFormats[t] || {})
        }, nn.prototype.setDateTimeFormat = function(t, e) {
            this._vm.$set(this._vm.dateTimeFormats, t, e), this._clearDateTimeFormat(t, e)
        }, nn.prototype.mergeDateTimeFormat = function(t, e) {
            this._vm.$set(this._vm.dateTimeFormats, t, Te(this._vm.dateTimeFormats[t] || {}, e)), this._clearDateTimeFormat(t, e)
        }, nn.prototype._clearDateTimeFormat = function(t, e) {
            for (var n in e) {
                var r = t + "__" + n;
                this._dateTimeFormatters.hasOwnProperty(r) && delete this._dateTimeFormatters[r]
            }
        }, nn.prototype._localizeDateTime = function(t, e, n, r, o) {
            for (var l = e, c = r[l], h = this._getLocaleChain(e, n), i = 0; i < h.length; i++) {
                var d = h[i];
                if (l = d, !ye(c = r[d]) && !ye(c[o])) break
            }
            if (ye(c) || ye(c[o])) return null;
            var f = c[o],
                m = l + "__" + o,
                v = this._dateTimeFormatters[m];
            return v || (v = this._dateTimeFormatters[m] = new Intl.DateTimeFormat(l, f)), v.format(t)
        }, nn.prototype._d = function(t, e, n) {
            if (!n) return new Intl.DateTimeFormat(e).format(t);
            var r = this._localizeDateTime(t, e, this.fallbackLocale, this._getDateTimeFormats(), n);
            if (this._isFallbackRoot(r)) {
                if (!this._root) throw Error("unexpected error");
                return this._root.$i18n.d(t, n, e)
            }
            return r || ""
        }, nn.prototype.d = function(t) {
            for (var e = [], n = arguments.length - 1; n-- > 0;) e[n] = arguments[n + 1];
            var r = this.locale,
                o = null;
            return 1 === e.length ? me(e[0]) ? o = e[0] : fe(e[0]) && (e[0].locale && (r = e[0].locale), e[0].key && (o = e[0].key)) : 2 === e.length && (me(e[0]) && (o = e[0]), me(e[1]) && (r = e[1])), this._d(t, r, o)
        }, nn.prototype.getNumberFormat = function(t) {
            return be(this._vm.numberFormats[t] || {})
        }, nn.prototype.setNumberFormat = function(t, e) {
            this._vm.$set(this._vm.numberFormats, t, e), this._clearNumberFormat(t, e)
        }, nn.prototype.mergeNumberFormat = function(t, e) {
            this._vm.$set(this._vm.numberFormats, t, Te(this._vm.numberFormats[t] || {}, e)), this._clearNumberFormat(t, e)
        }, nn.prototype._clearNumberFormat = function(t, e) {
            for (var n in e) {
                var r = t + "__" + n;
                this._numberFormatters.hasOwnProperty(r) && delete this._numberFormatters[r]
            }
        }, nn.prototype._getNumberFormatter = function(t, e, n, r, o, l) {
            for (var c = e, h = r[c], d = this._getLocaleChain(e, n), i = 0; i < d.length; i++) {
                var f = d[i];
                if (c = f, !ye(h = r[f]) && !ye(h[o])) break
            }
            if (ye(h) || ye(h[o])) return null;
            var m, v = h[o];
            if (l) m = new Intl.NumberFormat(c, Object.assign({}, v, l));
            else {
                var y = c + "__" + o;
                (m = this._numberFormatters[y]) || (m = this._numberFormatters[y] = new Intl.NumberFormat(c, v))
            }
            return m
        }, nn.prototype._n = function(t, e, n, r) {
            if (!nn.availabilities.numberFormat) return "";
            if (!n) return (r ? new Intl.NumberFormat(e, r) : new Intl.NumberFormat(e)).format(t);
            var o = this._getNumberFormatter(t, e, this.fallbackLocale, this._getNumberFormats(), n, r),
                l = o && o.format(t);
            if (this._isFallbackRoot(l)) {
                if (!this._root) throw Error("unexpected error");
                return this._root.$i18n.n(t, Object.assign({}, {
                    key: n,
                    locale: e
                }, r))
            }
            return l || ""
        }, nn.prototype.n = function(t) {
            for (var e = [], n = arguments.length - 1; n-- > 0;) e[n] = arguments[n + 1];
            var r = this.locale,
                o = null,
                l = null;
            return 1 === e.length ? me(e[0]) ? o = e[0] : fe(e[0]) && (e[0].locale && (r = e[0].locale), e[0].key && (o = e[0].key), l = Object.keys(e[0]).reduce((function(t, n) {
                var r;
                return we(he, n) ? Object.assign({}, t, ((r = {})[n] = e[0][n], r)) : t
            }), null)) : 2 === e.length && (me(e[0]) && (o = e[0]), me(e[1]) && (r = e[1])), this._n(t, r, o, l)
        }, nn.prototype._ntp = function(t, e, n, r) {
            if (!nn.availabilities.numberFormat) return [];
            if (!n) return (r ? new Intl.NumberFormat(e, r) : new Intl.NumberFormat(e)).formatToParts(t);
            var o = this._getNumberFormatter(t, e, this.fallbackLocale, this._getNumberFormats(), n, r),
                l = o && o.formatToParts(t);
            if (this._isFallbackRoot(l)) {
                if (!this._root) throw Error("unexpected error");
                return this._root.$i18n._ntp(t, e, n, r)
            }
            return l || []
        }, Object.defineProperties(nn.prototype, rn), Object.defineProperty(nn, "availabilities", {
            get: function() {
                if (!Ye) {
                    var t = "undefined" != typeof Intl;
                    Ye = {
                        dateTimeFormat: t && void 0 !== Intl.DateTimeFormat,
                        numberFormat: t && void 0 !== Intl.NumberFormat
                    }
                }
                return Ye
            }
        }), nn.install = Ue, nn.version = "8.26.5";
        var on = nn,
            an = n(78);
        n(207), n(209), n(210), n(211), n(212), n(213), n(214), n(215), n(216), n(217), n(218), n(219), n(220), n(221);

        function sn(object, t) {
            var e = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(object);
                t && (n = n.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(object, t).enumerable
                }))), e.push.apply(e, n)
            }
            return e
        }

        function ln(t) {
            for (var i = 1; i < arguments.length; i++) {
                var source = null != arguments[i] ? arguments[i] : {};
                i % 2 ? sn(Object(source), !0).forEach((function(e) {
                    Object(l.a)(t, e, source[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(source)) : sn(Object(source)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(source, e))
                }))
            }
            return t
        }

        function cn(t, e) {
            var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!n) {
                if (Array.isArray(t) || (n = function(t, e) {
                        if (!t) return;
                        if ("string" == typeof t) return un(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        "Object" === n && t.constructor && (n = t.constructor.name);
                        if ("Map" === n || "Set" === n) return Array.from(t);
                        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return un(t, e)
                    }(t)) || e && t && "number" == typeof t.length) {
                    n && (t = n);
                    var i = 0,
                        r = function() {};
                    return {
                        s: r,
                        n: function() {
                            return i >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[i++]
                            }
                        },
                        e: function(t) {
                            throw t
                        },
                        f: r
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var o, l = !0,
                c = !1;
            return {
                s: function() {
                    n = n.call(t)
                },
                n: function() {
                    var t = n.next();
                    return l = t.done, t
                },
                e: function(t) {
                    c = !0, o = t
                },
                f: function() {
                    try {
                        l || null == n.return || n.return()
                    } finally {
                        if (c) throw o
                    }
                }
            }
        }

        function un(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }

        function hn() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                e = t.addDirAttribute,
                n = void 0 !== e && e,
                r = t.addSeoAttributes,
                o = void 0 !== r && r;
            if (!this.$i18n) return {};
            var l = {
                    htmlAttrs: {},
                    link: [],
                    meta: []
                },
                c = this.$i18n.localeProperties,
                h = c.iso,
                f = c.dir || Lt.defaultDirection;
            if (n && (l.htmlAttrs.dir = f), o && (d.a.hasMetaInfo ? d.a.hasMetaInfo(this) : this._hasMetaInfo) && this.$i18n.locale && this.$i18n.locales) {
                h && (l.htmlAttrs.lang = h);
                var m = this.$i18n.locales;
                v.bind(this)(m, this.$i18n.__baseUrl, l.link), y.bind(this)(this.$i18n.__baseUrl, l.link), _.bind(this)(c, h, l.meta), x.bind(this)(m, h, l.meta)
            }

            function v(t, e, link) {
                if (Lt.strategy !== Et.STRATEGIES.NO_PREFIX) {
                    var n, r = new Map,
                        o = cn(t);
                    try {
                        for (o.s(); !(n = o.n()).done;) {
                            var l = n.value,
                                c = l.iso;
                            if (c) {
                                var h = c.split("-"),
                                    d = Object(O.a)(h, 2),
                                    f = d[0],
                                    m = d[1];
                                f && m && (l.isCatchallLocale || !r.has(f)) && r.set(f, l), r.set(c, l)
                            } else console.warn(Ot("Locale ISO code is required to generate alternate link"))
                        }
                    } catch (t) {
                        o.e(t)
                    } finally {
                        o.f()
                    }
                    var v, y = cn(r.entries());
                    try {
                        for (y.s(); !(v = y.n()).done;) {
                            var _ = Object(O.a)(v.value, 2),
                                x = _[0],
                                w = _[1],
                                S = this.switchLocalePath(w.code);
                            S && link.push({
                                hid: "i18n-alt-".concat(x),
                                rel: "alternate",
                                href: M(S, e),
                                hreflang: x
                            })
                        }
                    } catch (t) {
                        y.e(t)
                    } finally {
                        y.f()
                    }
                    if (Lt.defaultLocale) {
                        var T = this.switchLocalePath(Lt.defaultLocale);
                        T && link.push({
                            hid: "i18n-xd",
                            rel: "alternate",
                            href: M(T, e),
                            hreflang: "x-default"
                        })
                    }
                }
            }

            function y(t, link) {
                var e = this.localeRoute(ln(ln({}, this.$route), {}, {
                        name: this.getRouteBaseName()
                    })),
                    n = e ? e.path : null;
                n && link.push({
                    hid: "i18n-can",
                    rel: "canonical",
                    href: M(n, t)
                })
            }

            function _(t, e, meta) {
                t && e && meta.push({
                    hid: "i18n-og",
                    property: "og:locale",
                    content: w(e)
                })
            }

            function x(t, e, meta) {
                var n = t.filter((function(t) {
                    var n = t.iso;
                    return n && n !== e
                }));
                if (n.length) {
                    var r = n.map((function(t) {
                        return {
                            hid: "i18n-og-alt-".concat(t.iso),
                            property: "og:locale:alternate",
                            content: w(t.iso)
                        }
                    }));
                    meta.push.apply(meta, Object(an.a)(r))
                }
            }

            function w(t) {
                return (t || "").replace(/-/g, "_")
            }

            function M(t, e) {
                return t.match(/^https?:\/\//) ? t : e + t
            }
            return l
        }

        function dn(t, e, n) {
            "object" == typeof n.value && (n.value = pn(n.value)), n.enumerable && !n.get && !n.set && n.configurable && n.writable && "__proto__" !== e ? t[e] = n.value : Object.defineProperty(t, e, n)
        }

        function pn(t) {
            if ("object" != typeof t) return t;
            var e, n, r, i = 0,
                o = Object.prototype.toString.call(t);
            if ("[object Object]" === o ? r = Object.create(t.__proto__ || null) : "[object Array]" === o ? r = Array(t.length) : "[object Set]" === o ? (r = new Set, t.forEach((function(t) {
                    r.add(pn(t))
                }))) : "[object Map]" === o ? (r = new Map, t.forEach((function(t, e) {
                    r.set(pn(e), pn(t))
                }))) : "[object Date]" === o ? r = new Date(+t) : "[object RegExp]" === o ? r = new RegExp(t.source, t.flags) : "[object DataView]" === o ? r = new t.constructor(pn(t.buffer)) : "[object ArrayBuffer]" === o ? r = t.slice(0) : "Array]" === o.slice(-6) && (r = new t.constructor(t)), r) {
                for (n = Object.getOwnPropertySymbols(t); i < n.length; i++) dn(r, n[i], Object.getOwnPropertyDescriptor(t, n[i]));
                for (i = 0, n = Object.getOwnPropertyNames(t); i < n.length; i++) Object.hasOwnProperty.call(r, e = n[i]) && r[e] === t[e] || dn(r, e, Object.getOwnPropertyDescriptor(t, e))
            }
            return r || t
        }

        function fn(t, e) {
            var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!n) {
                if (Array.isArray(t) || (n = function(t, e) {
                        if (!t) return;
                        if ("string" == typeof t) return mn(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        "Object" === n && t.constructor && (n = t.constructor.name);
                        if ("Map" === n || "Set" === n) return Array.from(t);
                        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return mn(t, e)
                    }(t)) || e && t && "number" == typeof t.length) {
                    n && (t = n);
                    var i = 0,
                        r = function() {};
                    return {
                        s: r,
                        n: function() {
                            return i >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[i++]
                            }
                        },
                        e: function(t) {
                            throw t
                        },
                        f: r
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var o, l = !0,
                c = !1;
            return {
                s: function() {
                    n = n.call(t)
                },
                n: function() {
                    var t = n.next();
                    return l = t.done, t
                },
                e: function(t) {
                    c = !0, o = t
                },
                f: function() {
                    try {
                        l || null == n.return || n.return()
                    } finally {
                        if (c) throw o
                    }
                }
            }
        }

        function mn(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }
        c.a.use(on);
        var gn = function() {
                var t = Object(o.a)(regeneratorRuntime.mark((function t(e) {
                    var n, r, l, h, d, f, m, v, y, _, w, M, S, T, E, A, C, L, k, R, P, D, I, N, F, z, B, U, H, j, V, G, W, X, $, Y, Z, J, K, Q;
                    return regeneratorRuntime.wrap((function(t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                n = e.app, r = e.route, l = e.store, h = e.req, e.res, d = e.redirect, Lt.vuex && l && Xt(l, Lt.vuex, Lt.localeCodes), f = Lt.lazy, f && (!0 === f || !0 !== f.skipNuxtState), t.next = 9;
                                break;
                            case 7:
                                m = t.sent.default, e.beforeNuxtRender((function(t) {
                                    var e = t.nuxtState,
                                        r = {},
                                        o = n.i18n,
                                        l = o.fallbackLocale,
                                        c = o.locale;
                                    if (c && c !== l) {
                                        var h = n.i18n._getMessages()[c];
                                        if (h) try {
                                            m(h), r[c] = h
                                        } catch (t) {}
                                    }
                                    e.__i18n = {
                                        langs: r
                                    }
                                }));
                            case 9:
                                if (v = Lt.detectBrowserLanguage, y = v.alwaysRedirect, _ = v.fallbackLocale, w = v.redirectOn, M = v.useCookie, S = v.cookieKey, T = v.cookieDomain, E = v.cookieSecure, A = v.cookieCrossOrigin, C = function() {
                                        var t = Object(o.a)(regeneratorRuntime.mark((function t(r) {
                                            var o, l, h, f, m, v, y, _, x, w, S, T, E, A, C, L, R, P, D = arguments;
                                            return regeneratorRuntime.wrap((function(t) {
                                                for (;;) switch (t.prev = t.next) {
                                                    case 0:
                                                        if (o = D.length > 1 && void 0 !== D[1] ? D[1] : {}, l = o.initialSetup, h = void 0 !== l && l, r) {
                                                            t.next = 3;
                                                            break
                                                        }
                                                        return t.abrupt("return");
                                                    case 3:
                                                        if (h || !n.i18n.differentDomains) {
                                                            t.next = 5;
                                                            break
                                                        }
                                                        return t.abrupt("return");
                                                    case 5:
                                                        if (f = n.i18n.locale, r !== f) {
                                                            t.next = 8;
                                                            break
                                                        }
                                                        return t.abrupt("return");
                                                    case 8:
                                                        if (!(m = n.i18n.onBeforeLanguageSwitch(f, r, h, e)) || !n.i18n.localeCodes.includes(m)) {
                                                            t.next = 13;
                                                            break
                                                        }
                                                        if (m !== f) {
                                                            t.next = 12;
                                                            break
                                                        }
                                                        return t.abrupt("return");
                                                    case 12:
                                                        r = m;
                                                    case 13:
                                                        if (M && n.i18n.setLocaleCookie(r), !Lt.langDir) {
                                                            t.next = 28;
                                                            break
                                                        }
                                                        if (v = n.i18n.fallbackLocale, !Lt.lazy) {
                                                            t.next = 26;
                                                            break
                                                        }
                                                        if (!v) {
                                                            t.next = 22;
                                                            break
                                                        }
                                                        return y = [], Array.isArray(v) ? y = v.map((function(t) {
                                                            return Vt(e, t)
                                                        })) : "object" === Object(Tt.a)(v) ? (v[r] && (y = y.concat(v[r].map((function(t) {
                                                            return Vt(e, t)
                                                        })))), v.default && (y = y.concat(v.default.map((function(t) {
                                                            return Vt(e, t)
                                                        }))))) : r !== v && y.push(Vt(e, v)), t.next = 22, Promise.all(y);
                                                    case 22:
                                                        return t.next = 24, Vt(e, r);
                                                    case 24:
                                                        t.next = 28;
                                                        break;
                                                    case 26:
                                                        return t.next = 28, Promise.all(Lt.localeCodes.map((function(t) {
                                                            return Vt(e, t)
                                                        })));
                                                    case 28:
                                                        for (n.i18n.locale = r, _ = Lt.normalizedLocales.find((function(t) {
                                                                return t.code === r
                                                            })) || {
                                                                code: r
                                                            }, x = 0, w = Object.keys(n.i18n.localeProperties); x < w.length; x++) S = w[x], n.i18n.localeProperties[S] = void 0;
                                                        for (T = 0, E = Object.entries(_); T < E.length; T++) A = Object(O.a)(E[T], 2), C = A[0], L = A[1], c.a.set(n.i18n.localeProperties, C, pn(L));
                                                        R = e.route, P = k(R, r), h ? n.i18n.__redirect = P : (n.i18n.onLanguageSwitched(f, r), P && d(P));
                                                    case 35:
                                                    case "end":
                                                        return t.stop()
                                                }
                                            }), t)
                                        })));
                                        return function(e) {
                                            return t.apply(this, arguments)
                                        }
                                    }(), L = zt(Lt.localeCodes, {
                                        routesNameSeparator: Lt.routesNameSeparator,
                                        defaultLocaleRouteNameSuffix: Lt.defaultLocaleRouteNameSuffix
                                    }), k = function(t, e) {
                                        if (!e || n.i18n.differentDomains || Lt.strategy === Et.STRATEGIES.NO_PREFIX) return "";
                                        if (L(t) === e && (w === Et.REDIRECT_ON_OPTIONS.ALL || e !== Lt.defaultLocale || Lt.strategy !== Et.STRATEGIES.PREFIX_AND_DEFAULT)) return "";
                                        var r = n.switchLocalePath(e);
                                        return r || (r = n.localePath(t.fullPath, e)), !r || r === t.fullPath || r.startsWith("//") ? "" : r
                                    }, R = function() {
                                        var t = Object(o.a)(regeneratorRuntime.mark((function t(r) {
                                            var o, path, l, c, h;
                                            return regeneratorRuntime.wrap((function(t) {
                                                for (;;) switch (t.prev = t.next) {
                                                    case 0:
                                                        if ("/" !== r.path || !Lt.rootRedirect) {
                                                            t.next = 5;
                                                            break
                                                        }
                                                        return o = 302, path = Lt.rootRedirect, "string" != typeof Lt.rootRedirect && (o = Lt.rootRedirect.statusCode, path = Lt.rootRedirect.path), t.abrupt("return", [o, "/".concat(path), !0]);
                                                    case 5:
                                                        if (!(l = n.i18n.__redirect)) {
                                                            t.next = 9;
                                                            break
                                                        }
                                                        return n.i18n.__redirect = null, t.abrupt("return", [302, l]);
                                                    case 9:
                                                        if (c = {
                                                                differentDomains: Lt.differentDomains,
                                                                normalizedLocales: Lt.normalizedLocales
                                                            }, n.i18n.__baseUrl = Wt(Lt.baseUrl, e, n.i18n.locale, c), h = Lt.detectBrowserLanguage && N(r) || !Lt.differentDomains && L(r) || n.i18n.locale || n.i18n.defaultLocale || "", !Lt.skipSettingLocaleOnNavigate) {
                                                            t.next = 17;
                                                            break
                                                        }
                                                        n.i18n.__pendingLocale = h, n.i18n.__pendingLocalePromise = new Promise((function(t) {
                                                            n.i18n.__resolvePendingLocalePromise = t
                                                        })), t.next = 19;
                                                        break;
                                                    case 17:
                                                        return t.next = 19, n.i18n.setLocale(h);
                                                    case 19:
                                                        return t.abrupt("return", [null, null]);
                                                    case 20:
                                                    case "end":
                                                        return t.stop()
                                                }
                                            }), t)
                                        })));
                                        return function(e) {
                                            return t.apply(this, arguments)
                                        }
                                    }(), P = function() {
                                        var t = Object(o.a)(regeneratorRuntime.mark((function t() {
                                            return regeneratorRuntime.wrap((function(t) {
                                                for (;;) switch (t.prev = t.next) {
                                                    case 0:
                                                        if (n.i18n.__pendingLocale) {
                                                            t.next = 2;
                                                            break
                                                        }
                                                        return t.abrupt("return");
                                                    case 2:
                                                        return t.next = 4, n.i18n.setLocale(n.i18n.__pendingLocale);
                                                    case 4:
                                                        n.i18n.__resolvePendingLocalePromise(""), n.i18n.__pendingLocale = null;
                                                    case 6:
                                                    case "end":
                                                        return t.stop()
                                                }
                                            }), t)
                                        })));
                                        return function() {
                                            return t.apply(this, arguments)
                                        }
                                    }(), D = function() {
                                        var t = Object(o.a)(regeneratorRuntime.mark((function t() {
                                            return regeneratorRuntime.wrap((function(t) {
                                                for (;;) switch (t.prev = t.next) {
                                                    case 0:
                                                        if (!n.i18n.__pendingLocale) {
                                                            t.next = 3;
                                                            break
                                                        }
                                                        return t.next = 3, n.i18n.__pendingLocalePromise;
                                                    case 3:
                                                    case "end":
                                                        return t.stop()
                                                }
                                            }), t)
                                        })));
                                        return function() {
                                            return t.apply(this, arguments)
                                        }
                                    }(), I = function() {
                                        return "undefined" != typeof navigator && navigator.languages ? It(Lt.normalizedLocales, navigator.languages) : h && void 0 !== h.headers["accept-language"] ? It(Lt.normalizedLocales, h.headers["accept-language"].split(",").map((function(t) {
                                            return t.split(";")[0]
                                        }))) : void 0
                                    }, N = function(t) {
                                        if (Lt.strategy !== Et.STRATEGIES.NO_PREFIX)
                                            if (w === Et.REDIRECT_ON_OPTIONS.ROOT) {
                                                if ("/" !== t.path) return ""
                                            } else if (w === Et.REDIRECT_ON_OPTIONS.NO_PREFIX && !y && t.path.match(Ft(Lt.localeCodes))) return "";
                                        var e;
                                        M && (e = n.i18n.getLocaleCookie()) || (e = I());
                                        var r = e || _;
                                        return !r || M && !y && n.i18n.getLocaleCookie() || r === n.i18n.locale ? "" : r
                                    }, F = function(t) {
                                        t.locales = pn(Lt.locales), t.localeCodes = pn(Lt.localeCodes), t.localeProperties = c.a.observable(pn(Lt.normalizedLocales.find((function(e) {
                                            return e.code === t.locale
                                        })) || {
                                            code: t.locale
                                        })), t.defaultLocale = Lt.defaultLocale, t.differentDomains = Lt.differentDomains, t.onBeforeLanguageSwitch = Lt.onBeforeLanguageSwitch, t.onLanguageSwitched = Lt.onLanguageSwitched, t.setLocaleCookie = function(t) {
                                            return Ut(t, 0, {
                                                useCookie: M,
                                                cookieDomain: T,
                                                cookieKey: S,
                                                cookieSecure: E,
                                                cookieCrossOrigin: A
                                            })
                                        }, t.getLocaleCookie = function() {
                                            return Bt(0, {
                                                useCookie: M,
                                                cookieKey: S,
                                                localeCodes: Lt.localeCodes
                                            })
                                        }, t.setLocale = function(t) {
                                            return C(t)
                                        }, t.getBrowserLocale = function() {
                                            return I()
                                        }, t.finalizePendingLocaleChange = P, t.waitForPendingLocaleChange = D, t.__baseUrl = n.i18n.__baseUrl, t.__pendingLocale = n.i18n.__pendingLocale, t.__pendingLocalePromise = n.i18n.__pendingLocalePromise, t.__resolvePendingLocalePromise = n.i18n.__resolvePendingLocalePromise
                                    }, "function" != typeof Lt.vueI18n) {
                                    t.next = 25;
                                    break
                                }
                                return t.next = 22, Lt.vueI18n(e);
                            case 22:
                                t.t0 = t.sent, t.next = 26;
                                break;
                            case 25:
                                t.t0 = pn(Lt.vueI18n);
                            case 26:
                                if ((z = t.t0).componentInstanceCreatedListener = F, n.i18n = e.i18n = new on(z), n.i18n.locale = "", n.i18n.fallbackLocale = z.fallbackLocale || "", l && (l.$i18n = n.i18n, l.state.localeDomains)) {
                                    B = fn(Lt.normalizedLocales.entries());
                                    try {
                                        for (B.s(); !(U = B.n()).done;) H = Object(O.a)(U.value, 2), j = H[0], V = H[1], (G = l.state.localeDomains[V.code]) && (V.domain = G, "string" != typeof(W = Lt.locales[j]) && (W.domain = G))
                                    } catch (t) {
                                        B.e(t)
                                    } finally {
                                        B.f()
                                    }
                                }
                                return F(n.i18n), X = {
                                    differentDomains: Lt.differentDomains,
                                    normalizedLocales: Lt.normalizedLocales
                                }, n.i18n.__baseUrl = Wt(Lt.baseUrl, e, "", X), n.i18n.__onNavigate = R, c.a.prototype.$nuxtI18nHead = hn, ($ = Lt.detectBrowserLanguage ? N(r) : "") || (n.i18n.differentDomains ? (Y = Nt(Lt.normalizedLocales), $ = Y) : Lt.strategy !== Et.STRATEGIES.NO_PREFIX && (Z = L(r), $ = Z)), !$ && M && ($ = n.i18n.getLocaleCookie()), $ || ($ = n.i18n.defaultLocale || ""), t.next = 43, C($, {
                                    initialSetup: !0
                                });
                            case 43:
                                if (!At) {
                                    t.next = 51;
                                    break
                                }
                                return t.next = 46, R(e.route);
                            case 46:
                                J = t.sent, K = Object(O.a)(J, 2), K[0], (Q = K[1]) && location.assign(Object(x.c)(e.base, Q));
                            case 51:
                            case "end":
                                return t.stop()
                        }
                    }), t)
                })));
                return function(e) {
                    return t.apply(this, arguments)
                }
            }(),
            vn = n(254),
            yn = n.n(vn);

        function _n(object, t) {
            var e = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(object);
                t && (n = n.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(object, t).enumerable
                }))), e.push.apply(e, n)
            }
            return e
        }

        function xn(t) {
            for (var i = 1; i < arguments.length; i++) {
                var source = null != arguments[i] ? arguments[i] : {};
                i % 2 ? _n(Object(source), !0).forEach((function(e) {
                    Object(l.a)(t, e, source[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(source)) : _n(Object(source)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(source, e))
                }))
            }
            return t
        }
        var bn = function() {
                var t = Object(o.a)(regeneratorRuntime.mark((function t(e, n) {
                    var r, o;
                    return regeneratorRuntime.wrap((function(t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                if (r = e.$config && e.$config.googleAnalytics || {}, "function" != typeof(o = xn(xn({}, {
                                        dev: !0,
                                        debug: {
                                            sendHitTask: !0
                                        },
                                        id: "UA-211018226-1"
                                    }), r)).asyncID) {
                                    t.next = 7;
                                    break
                                }
                                return t.next = 6, o.asyncID(e);
                            case 6:
                                o.id = t.sent;
                            case 7:
                                c.a.use(yn.a, xn(xn({}, {
                                    router: e.app.router
                                }), o)), e.$ga = c.a.$ga, n("ga", c.a.$ga);
                            case 10:
                            case "end":
                                return t.stop()
                        }
                    }), t)
                })));
                return function(e, n) {
                    return t.apply(this, arguments)
                }
            }(),
            wn = n(255),
            Mn = n(256),
            Sn = n.n(Mn),
            Tn = function(t, e) {
                Object(wn.a)(t), e("md", new Sn.a("default", {
                    linkify: !0,
                    breaks: !0
                }))
            },
            En = (n(397), n(161)),
            An = n.n(En);

        function Cn(object, t) {
            var e = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(object);
                t && (n = n.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(object, t).enumerable
                }))), e.push.apply(e, n)
            }
            return e
        }

        function Ln(t, e) {
            var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!n) {
                if (Array.isArray(t) || (n = function(t, e) {
                        if (!t) return;
                        if ("string" == typeof t) return kn(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        "Object" === n && t.constructor && (n = t.constructor.name);
                        if ("Map" === n || "Set" === n) return Array.from(t);
                        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return kn(t, e)
                    }(t)) || e && t && "number" == typeof t.length) {
                    n && (t = n);
                    var i = 0,
                        r = function() {};
                    return {
                        s: r,
                        n: function() {
                            return i >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[i++]
                            }
                        },
                        e: function(t) {
                            throw t
                        },
                        f: r
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var o, l = !0,
                c = !1;
            return {
                s: function() {
                    n = n.call(t)
                },
                n: function() {
                    var t = n.next();
                    return l = t.done, t
                },
                e: function(t) {
                    c = !0, o = t
                },
                f: function() {
                    try {
                        l || null == n.return || n.return()
                    } finally {
                        if (c) throw o
                    }
                }
            }
        }

        function kn(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }
        var Rn = ["class-name", "class", "style"],
            Pn = /^@|^v-on:/,
            Dn = /^:|^v-bind:/,
            On = /^v-model/,
            In = ["select", "textarea", "input"];

        function Nn(code, t) {
            return new Function("with(this) { return (" + code + ") }").call(t)
        }

        function Fn(t, e, n) {
            if ("text" === t.type) return t.value;
            var r, o = function(t, e, n) {
                    var data = {};
                    return (t.children || []).forEach((function(t) {
                        if (Un(t) && !Bn(t)) {
                            data.scopedSlots = data.scopedSlots || {};
                            var template = t,
                                r = Hn(template),
                                o = template.content.map((function(t) {
                                    return Fn(t, e, n)
                                }));
                            data.scopedSlots[r] = function() {
                                return o
                            }
                        }
                    })), data
                }(t || {}, e, n),
                l = function(t, e) {
                    var n = t.tag,
                        r = t.props;
                    return Object.keys(r).reduce((function(data, t) {
                        var o = t.replace(/.*:/, ""),
                            l = Rn.includes(o) ? data : data.attrs,
                            c = r[t],
                            h = An.a.find(An.a.html, t).attribute,
                            d = In.includes(n);
                        if (On.test(t) && c in e && !d) {
                            var f = t.replace(On, "").split(".").filter((function(t) {
                                    return t
                                })).reduce((function(t, e) {
                                    return t[e] = !0, t
                                }), {}),
                                m = f.lazy ? "change" : "input",
                                v = f.number ? function(t) {
                                    return +t
                                } : f.trim ? function(t) {
                                    return t.trim()
                                } : function(t) {
                                    return t
                                };
                            l.value = Nn(c, e), data.on = data.on || {}, data.on[m] = function(t) {
                                return e[c] = v(t)
                            }
                        } else if ("v-bind" === t) {
                            var y = c in e ? e[c] : Nn(c, e);
                            l = Object.assign(l, y)
                        } else Pn.test(t) ? (t = t.replace(Pn, ""), data.on = data.on || {}, data.on[t] = Nn(c, e)) : Dn.test(t) ? l[t = t.replace(Dn, "")] = c in e ? e[c] : Nn(c, e) : Array.isArray(c) ? l[h] = c.join(" ") : l[h] = c;
                        return data
                    }), {
                        attrs: {}
                    })
                }(t || {}, n),
                data = Object.assign({}, o, l),
                c = [],
                h = Ln(t.children);
            try {
                for (h.s(); !(r = h.n()).done;) {
                    var d = r.value;
                    if (!Un(d) || Bn(d)) {
                        var f = Bn(d) ? d.content : [d];
                        c.push.apply(c, Object(an.a)(f.map((function(t) {
                            return Fn(t, e, n)
                        }))))
                    }
                }
            } catch (t) {
                h.e(t)
            } finally {
                h.f()
            }
            return e(t.tag, data, c)
        }
        var zn = "default";

        function Bn(t) {
            return Un(t) && Hn(t) === zn
        }

        function Un(t) {
            return "template" === t.tag
        }

        function Hn(t) {
            for (var e = "", n = 0, r = Object.keys(t.props); n < r.length; n++) {
                var o = r[n];
                if (o.startsWith("#") || o.startsWith("v-slot:")) {
                    e = o.split(/[:#]/, 2)[1];
                    break
                }
            }
            return e || zn
        }
        var jn = {
                name: "NuxtContent",
                functional: !0,
                props: {
                    document: {
                        required: !0
                    }
                },
                render: function(t, e) {
                    var data = e.data,
                        n = e.props.document,
                        body = (n || {}).body;
                    if (body && body.children && Array.isArray(body.children)) {
                        var r = [];
                        if (Array.isArray(data.class)) r = data.class;
                        else if ("object" === Object(Tt.a)(data.class)) {
                            r = Object.keys(data.class).filter((function(t) {
                                return data.class[t]
                            }))
                        } else r = [data.class];
                        return data.class = r.concat("nuxt-content"), data.props = Object.assign(function(t) {
                            for (var i = 1; i < arguments.length; i++) {
                                var source = null != arguments[i] ? arguments[i] : {};
                                i % 2 ? Cn(Object(source), !0).forEach((function(e) {
                                    Object(l.a)(t, e, source[e])
                                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(source)) : Cn(Object(source)).forEach((function(e) {
                                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(source, e))
                                }))
                            }
                            return t
                        }({}, body.props), data.props), t("div", data, body.children.map((function(e) {
                            return Fn(e, t, n)
                        })))
                    }
                }
            },
            Vn = function() {
                return n.e(26).then(n.bind(null, 516))
            };
        c.a.component(jn.name, jn);
        var Gn = function(t, e) {
                var n = null,
                    r = (t.$config ? t.$config.content : t.nuxtState.content).dbHash,
                    l = function() {
                        for (var t = arguments.length, e = new Array(t), l = 0; l < t; l++) e[l] = arguments[l];
                        if (n) return n.apply(void 0, e);
                        for (var c = ["only", "without", "sortBy", "limit", "skip", "where", "search", "surround"], h = {}, d = [], f = function() {
                                var t = v[m];
                                h[t] = function() {
                                    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
                                    return d.push({
                                        key: t,
                                        args: n
                                    }), h
                                }
                            }, m = 0, v = c; m < v.length; m++) f();
                        return h.fetch = Object(o.a)(regeneratorRuntime.mark((function t() {
                            var o, l;
                            return regeneratorRuntime.wrap((function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        return t.next = 2, fetch("/_nuxt/content/db-".concat(r, ".json")).then((function(t) {
                                            return t.json()
                                        }));
                                    case 2:
                                        return o = t.sent, t.next = 5, Vn();
                                    case 5:
                                        return n = t.sent.default(o), l = n.apply(void 0, e), d.forEach((function(t) {
                                            var e, n = t.key,
                                                r = t.args;
                                            l = (e = l)[n].apply(e, Object(an.a)(r))
                                        })), t.abrupt("return", l.fetch());
                                    case 9:
                                    case "end":
                                        return t.stop()
                                }
                            }), t)
                        }))), h
                    };
                e("content", l), t.$content = l
            },
            Wn = (n(257), n(162)),
            qn = n(163);

        function Xn(object, t) {
            var e = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(object);
                t && (n = n.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(object, t).enumerable
                }))), e.push.apply(e, n)
            }
            return e
        }

        function $n(t) {
            for (var i = 1; i < arguments.length; i++) {
                var source = null != arguments[i] ? arguments[i] : {};
                i % 2 ? Xn(Object(source), !0).forEach((function(e) {
                    Object(l.a)(t, e, source[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(source)) : Xn(Object(source)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(source, e))
                }))
            }
            return t
        }
        c.a.component(m.a.name, m.a), c.a.component(y.a.name, $n($n({}, y.a), {}, {
            render: function(t, e) {
                return y.a._warned || (y.a._warned = !0, console.warn("<no-ssr> has been deprecated and will be removed in Nuxt 3, please use <client-only> instead")), y.a.render(t, e)
            }
        })), c.a.component(k.name, k), c.a.component("NChild", k), c.a.component(I.name, I), Object.defineProperty(c.a.prototype, "$nuxt", {
            get: function() {
                var t = this.$root.$options.$nuxt;
                return t || "undefined" == typeof window ? t : window.$nuxt
            },
            configurable: !0
        }), c.a.use(d.a, {
            keyName: "head",
            attribute: "data-n-head",
            ssrAttribute: "data-n-head-ssr",
            tagIDKeyName: "hid"
        });
        var Yn = {
            name: "page",
            mode: "out-in",
            appear: !0,
            appearClass: "appear",
            appearActiveClass: "appear-active",
            appearToClass: "appear-to"
        };
        h.a.Store.prototype.registerModule;

        function Zn(t) {
            return Jn.apply(this, arguments)
        }

        function Jn() {
            return Jn = Object(o.a)(regeneratorRuntime.mark((function t(e) {
                var n, r, l, h, d, f, path, m, v = arguments;
                return regeneratorRuntime.wrap((function(t) {
                    for (;;) switch (t.prev = t.next) {
                        case 0:
                            return m = function(t, e) {
                                if (!t) throw new Error("inject(key, value) has no key provided");
                                if (void 0 === e) throw new Error("inject('".concat(t, "', value) has no value provided"));
                                h[t = "$" + t] = e, h.context[t] || (h.context[t] = e), l[t] = h[t];
                                var n = "__nuxt_" + t + "_installed__";
                                c.a[n] || (c.a[n] = !0, c.a.use((function() {
                                    Object.prototype.hasOwnProperty.call(c.a.prototype, t) || Object.defineProperty(c.a.prototype, t, {
                                        get: function() {
                                            return this.$root.$options[t]
                                        }
                                    })
                                })))
                            }, n = v.length > 1 && void 0 !== v[1] ? v[1] : {}, t.next = 4, L(0, n);
                        case 4:
                            return r = t.sent, (l = j(e)).$router = r, h = $n({
                                head: {
                                    title: "monopo-saigon",
                                    htmlAttrs: {
                                        lang: "en"
                                    },
                                    meta: [{
                                        charset: "utf-8"
                                    }, {
                                        name: "viewport",
                                        content: "width=device-width, initial-scale=1"
                                    }, {
                                        hid: "description",
                                        name: "description",
                                        content: ""
                                    }, {
                                        name: "format-detection",
                                        content: "telephone=no"
                                    }, {
                                        name: "msapplication-TileColor",
                                        content: "#da532c"
                                    }, {
                                        name: "theme-color",
                                        content: "#ffffff"
                                    }, {
                                        hid: "og:image",
                                        property: "og:image",
                                        content: "/saigon-web-ogp.jpg"
                                    }, {
                                        hid: "og:title",
                                        property: "og:title",
                                        content: "monopo saigon | Tokyo-born digitally-driven creative studio"
                                    }, {
                                        hid: "og:descripton",
                                        property: "og:descripton",
                                        content: "We Integrate collaborate, and challenge. We are digital natives embracing the creative freedom to produce solutions that connect, communicate, and inspire."
                                    }, {
                                        hid: "twitter:card",
                                        name: "twitter:card",
                                        content: "summary_large_image"
                                    }, {
                                        hid: "twitter:title",
                                        name: "twitter:title",
                                        content: "monopo saigon | Tokyo-born digitally-driven creative studio"
                                    }, {
                                        hid: "twitter:description",
                                        name: "twitter:description",
                                        content: "We Integrate collaborate, and challenge. We are digital natives embracing the creative freedom to produce solutions that connect, communicate, and inspire."
                                    }, {
                                        hid: "twitter:image",
                                        name: "twitter:image",
                                        content: "/saigon-web-ogp.jpg"
                                    }],
                                    link: [{
                                        rel: "apple-touch-icon",
                                        sizes: "180x180",
                                        href: "/apple_touch_icon@2x.png"
                                    }, {
                                        rel: "icon",
                                        type: "image/x-icon",
                                        href: "/favicon.ico"
                                    }, {
                                        rel: "icon",
                                        type: "image/png",
                                        sizes: "32x32",
                                        href: "/favicon-32x32.png"
                                    }, {
                                        rel: "icon",
                                        type: "image/png",
                                        sizes: "16x16",
                                        href: "/favicon-16x16.png"
                                    }, {
                                        rel: "manifest",
                                        href: "/site.webmanifest"
                                    }, {
                                        rel: "mask-icon",
                                        color: "#5bbad5",
                                        href: "/safari-pinned-tab.svg"
                                    }],
                                    script: [{
                                        src: "https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.6.0/polyfill.min.js",
                                        body: !0
                                    }, {
                                        src: "https://polyfill.io/v3/polyfill.min.js?features=fetch%2CObject.entries%2CObject.assign%2CCustomEvent%2CElement.prototype.append%2CNodeList.prototype.forEach%2CIntersectionObserver%2Csmoothscroll",
                                        body: !0
                                    }],
                                    style: []
                                },
                                store: l,
                                router: r,
                                nuxt: {
                                    defaultTransition: Yn,
                                    transitions: [Yn],
                                    setTransitions: function(t) {
                                        return Array.isArray(t) || (t = [t]), t = t.map((function(t) {
                                            return t = t ? "string" == typeof t ? Object.assign({}, Yn, {
                                                name: t
                                            }) : Object.assign({}, Yn, t) : Yn
                                        })), this.$options.nuxt.transitions = t, t
                                    },
                                    err: null,
                                    dateErr: null,
                                    error: function(t) {
                                        t = t || null, h.context._errored = Boolean(t), t = t ? Object(w.p)(t) : null;
                                        var n = h.nuxt;
                                        return this && (n = this.nuxt || this.$options.nuxt), n.dateErr = Date.now(), n.err = t, e && (e.nuxt.error = t), t
                                    }
                                }
                            }, U), l.app = h, d = e ? e.next : function(t) {
                                return h.router.push(t)
                            }, e ? f = r.resolve(e.url).route : (path = Object(w.f)(r.options.base, r.options.mode), f = r.resolve(path).route), t.next = 13, Object(w.t)(h, {
                                store: l,
                                route: f,
                                next: d,
                                error: h.nuxt.error.bind(h),
                                payload: e ? e.payload : void 0,
                                req: e ? e.req : void 0,
                                res: e ? e.res : void 0,
                                beforeRenderFns: e ? e.beforeRenderFns : void 0,
                                ssrContext: e
                            });
                        case 13:
                            m("config", n), window.__NUXT__ && window.__NUXT__.state && l.replaceState(window.__NUXT__.state), h.context.enablePreview = function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                h.previewData = Object.assign({}, t), m("preview", t)
                            }, t.next = 19;
                            break;
                        case 19:
                            t.next = 22;
                            break;
                        case 22:
                            return t.next = 25, ue(h.context);
                        case 25:
                            if ("function" != typeof gn) {
                                t.next = 28;
                                break
                            }
                            return t.next = 28, gn(h.context, m);
                        case 28:
                            if ("function" != typeof bn) {
                                t.next = 31;
                                break
                            }
                            return t.next = 31, bn(h.context, m);
                        case 31:
                            return t.next = 34, Tn(h.context, m);
                        case 34:
                            return t.next = 37, Gn(h.context, m);
                        case 37:
                            t.next = 40;
                            break;
                        case 40:
                            if ("function" != typeof Wn.default) {
                                t.next = 43;
                                break
                            }
                            return t.next = 43, Object(Wn.default)(h.context, m);
                        case 43:
                            if ("function" != typeof qn.default) {
                                t.next = 46;
                                break
                            }
                            return t.next = 46, Object(qn.default)(h.context, m);
                        case 46:
                            return h.context.enablePreview = function() {
                                console.warn("You cannot call enablePreview() outside a plugin.")
                            }, t.next = 49, new Promise((function(t, e) {
                                if (!r.resolve(h.context.route.fullPath).route.matched.length) return t();
                                r.replace(h.context.route.fullPath, t, (function(n) {
                                    if (!n._isRouter) return e(n);
                                    if (2 !== n.type) return t();
                                    var l = r.afterEach(function() {
                                        var e = Object(o.a)(regeneratorRuntime.mark((function e(n, r) {
                                            return regeneratorRuntime.wrap((function(e) {
                                                for (;;) switch (e.prev = e.next) {
                                                    case 0:
                                                        return e.next = 3, Object(w.j)(n);
                                                    case 3:
                                                        h.context.route = e.sent, h.context.params = n.params || {}, h.context.query = n.query || {}, l(), t();
                                                    case 8:
                                                    case "end":
                                                        return e.stop()
                                                }
                                            }), e)
                                        })));
                                        return function(t, n) {
                                            return e.apply(this, arguments)
                                        }
                                    }())
                                }))
                            }));
                        case 49:
                            return t.abrupt("return", {
                                store: l,
                                app: h,
                                router: r
                            });
                        case 50:
                        case "end":
                            return t.stop()
                    }
                }), t)
            }))), Jn.apply(this, arguments)
        }
    }, , , , , , function(t, e, n) {
        "use strict";
        n.d(e, "b", (function() {
            return o
        })), n.d(e, "a", (function() {
            return h
        }));
        var r = n(2);
        class o {
            constructor() {
                this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
            }
            setSize() {}
            render() {
                console.error("THREE.Pass: .render() must be implemented in derived pass.")
            }
        }
        const l = new r.k(-1, 1, 1, -1, 0, 1),
            c = new r.b;
        c.setAttribute("position", new r.f([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), c.setAttribute("uv", new r.f([0, 2, 0, 0, 2, 0], 2));
        class h {
            constructor(t) {
                this._mesh = new r.j(c, t)
            }
            dispose() {
                this._mesh.geometry.dispose()
            }
            render(t) {
                t.render(this._mesh, l)
            }
            get material() {
                return this._mesh.material
            }
            set material(t) {
                this._mesh.material = t
            }
        }
    }, , , , , , , , function(t, e, n) {
        "use strict";
        var r = n(154),
            o = n(238),
            l = n(240);
        t.exports = function(t) {
            var e, n, c = t.space,
                h = t.mustUseProperty || [],
                d = t.attributes || {},
                f = t.properties,
                m = t.transform,
                v = {},
                y = {};
            for (e in f) n = new l(e, m(d, e), f[e], c), -1 !== h.indexOf(e) && (n.mustUseProperty = !0), v[e] = n, y[r(e)] = e, y[r(n.attribute)] = e;
            return new o(v, y, c)
        }
    }, , , , function(t, e, n) {
        "use strict";
        var r = {
            name: "NoSsr",
            functional: !0,
            props: {
                placeholder: String,
                placeholderTag: {
                    type: String,
                    default: "div"
                }
            },
            render: function(t, e) {
                var n = e.parent,
                    r = e.slots,
                    o = e.props,
                    l = r(),
                    c = l.default;
                void 0 === c && (c = []);
                var h = l.placeholder;
                return n._isMounted ? c : (n.$once("hook:mounted", (function() {
                    n.$forceUpdate()
                })), o.placeholderTag && (o.placeholder || h) ? t(o.placeholderTag, {
                    class: ["no-ssr-placeholder"]
                }, o.placeholder || h) : c.length > 0 ? c.map((function() {
                    return t(!1)
                })) : t(!1))
            }
        };
        t.exports = r
    }, , , , , , , , , , , , , function(t, e, n) {
        "use strict";
        e.a = {}
    }, , , function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
            return l
        }));
        var r = n(2),
            o = n(68);
        class l extends o.b {
            constructor(t, e) {
                super(), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof r.r ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = r.u.clone(t.uniforms), this.material = new r.r({
                    defines: Object.assign({}, t.defines),
                    uniforms: this.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                })), this.fsQuad = new o.a(this.material)
            }
            render(t, e, n) {
                this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
            }
        }
    }, , , , , , , , , , , , , , , , , , , , function(t, e, n) {
        "use strict";
        var r = 0;

        function o() {
            return Math.pow(2, ++r)
        }
        e.boolean = o(), e.booleanish = o(), e.overloadedBoolean = o(), e.number = o(), e.spaceSeparated = o(), e.commaSeparated = o(), e.commaOrSpaceSeparated = o()
    }, , , , , function(t, e, n) {
        "use strict";
        n(81), n(22), n(50), n(58), n(43), n(36), n(15), n(42), n(20), n(55), n(27), n(19), n(56), n(57), n(32);
        var r = n(1);

        function o(t, e) {
            var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!n) {
                if (Array.isArray(t) || (n = function(t, e) {
                        if (!t) return;
                        if ("string" == typeof t) return l(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        "Object" === n && t.constructor && (n = t.constructor.name);
                        if ("Map" === n || "Set" === n) return Array.from(t);
                        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return l(t, e)
                    }(t)) || e && t && "number" == typeof t.length) {
                    n && (t = n);
                    var i = 0,
                        r = function() {};
                    return {
                        s: r,
                        n: function() {
                            return i >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[i++]
                            }
                        },
                        e: function(t) {
                            throw t
                        },
                        f: r
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var o, c = !0,
                h = !1;
            return {
                s: function() {
                    n = n.call(t)
                },
                n: function() {
                    var t = n.next();
                    return c = t.done, t
                },
                e: function(t) {
                    h = !0, o = t
                },
                f: function() {
                    try {
                        c || null == n.return || n.return()
                    } finally {
                        if (h) throw o
                    }
                }
            }
        }

        function l(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
            return n
        }
        var c = window.requestIdleCallback || function(t) {
                var e = Date.now();
                return setTimeout((function() {
                    t({
                        didTimeout: !1,
                        timeRemaining: function() {
                            return Math.max(0, 50 - (Date.now() - e))
                        }
                    })
                }), 1)
            },
            h = window.cancelIdleCallback || function(t) {
                clearTimeout(t)
            },
            d = window.IntersectionObserver && new window.IntersectionObserver((function(t) {
                t.forEach((function(t) {
                    var e = t.intersectionRatio,
                        link = t.target;
                    e <= 0 || !link.__prefetch || link.__prefetch()
                }))
            }));
        e.a = {
            name: "NuxtLink",
            extends: r.a.component("RouterLink"),
            props: {
                prefetch: {
                    type: Boolean,
                    default: !0
                },
                noPrefetch: {
                    type: Boolean,
                    default: !1
                }
            },
            mounted: function() {
                this.prefetch && !this.noPrefetch && (this.handleId = c(this.observe, {
                    timeout: 2e3
                }))
            },
            beforeDestroy: function() {
                h(this.handleId), this.__observed && (d.unobserve(this.$el), delete this.$el.__prefetch)
            },
            methods: {
                observe: function() {
                    d && this.shouldPrefetch() && (this.$el.__prefetch = this.prefetchLink.bind(this), d.observe(this.$el), this.__observed = !0)
                },
                shouldPrefetch: function() {
                    return this.getPrefetchComponents().length > 0
                },
                canPrefetch: function() {
                    var t = navigator.connection;
                    return !(this.$nuxt.isOffline || t && ((t.effectiveType || "").includes("2g") || t.saveData))
                },
                getPrefetchComponents: function() {
                    return this.$router.resolve(this.to, this.$route, this.append).resolved.matched.map((function(t) {
                        return t.components.default
                    })).filter((function(t) {
                        return "function" == typeof t && !t.options && !t.__prefetched
                    }))
                },
                prefetchLink: function() {
                    if (this.canPrefetch()) {
                        d.unobserve(this.$el);
                        var t, e = o(this.getPrefetchComponents());
                        try {
                            for (e.s(); !(t = e.n()).done;) {
                                var n = t.value,
                                    r = n();
                                r instanceof Promise && r.catch((function() {})), n.__prefetched = !0
                            }
                        } catch (t) {
                            e.e(t)
                        } finally {
                            e.f()
                        }
                    }
                }
            }
        }
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e) {
        t.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/
    }, function(t, e, n) {
        "use strict";

        function r() {
            this.__rules__ = [], this.__cache__ = null
        }
        r.prototype.__find__ = function(t) {
            for (var i = 0; i < this.__rules__.length; i++)
                if (this.__rules__[i].name === t) return i;
            return -1
        }, r.prototype.__compile__ = function() {
            var t = this,
                e = [""];
            t.__rules__.forEach((function(t) {
                t.enabled && t.alt.forEach((function(t) {
                    e.indexOf(t) < 0 && e.push(t)
                }))
            })), t.__cache__ = {}, e.forEach((function(e) {
                t.__cache__[e] = [], t.__rules__.forEach((function(n) {
                    n.enabled && (e && n.alt.indexOf(e) < 0 || t.__cache__[e].push(n.fn))
                }))
            }))
        }, r.prototype.at = function(t, e, n) {
            var r = this.__find__(t),
                o = n || {};
            if (-1 === r) throw new Error("Parser rule not found: " + t);
            this.__rules__[r].fn = e, this.__rules__[r].alt = o.alt || [], this.__cache__ = null
        }, r.prototype.before = function(t, e, n, r) {
            var o = this.__find__(t),
                l = r || {};
            if (-1 === o) throw new Error("Parser rule not found: " + t);
            this.__rules__.splice(o, 0, {
                name: e,
                enabled: !0,
                fn: n,
                alt: l.alt || []
            }), this.__cache__ = null
        }, r.prototype.after = function(t, e, n, r) {
            var o = this.__find__(t),
                l = r || {};
            if (-1 === o) throw new Error("Parser rule not found: " + t);
            this.__rules__.splice(o + 1, 0, {
                name: e,
                enabled: !0,
                fn: n,
                alt: l.alt || []
            }), this.__cache__ = null
        }, r.prototype.push = function(t, e, n) {
            var r = n || {};
            this.__rules__.push({
                name: t,
                enabled: !0,
                fn: e,
                alt: r.alt || []
            }), this.__cache__ = null
        }, r.prototype.enable = function(t, e) {
            Array.isArray(t) || (t = [t]);
            var n = [];
            return t.forEach((function(t) {
                var r = this.__find__(t);
                if (r < 0) {
                    if (e) return;
                    throw new Error("Rules manager: invalid rule name " + t)
                }
                this.__rules__[r].enabled = !0, n.push(t)
            }), this), this.__cache__ = null, n
        }, r.prototype.enableOnly = function(t, e) {
            Array.isArray(t) || (t = [t]), this.__rules__.forEach((function(t) {
                t.enabled = !1
            })), this.enable(t, e)
        }, r.prototype.disable = function(t, e) {
            Array.isArray(t) || (t = [t]);
            var n = [];
            return t.forEach((function(t) {
                var r = this.__find__(t);
                if (r < 0) {
                    if (e) return;
                    throw new Error("Rules manager: invalid rule name " + t)
                }
                this.__rules__[r].enabled = !1, n.push(t)
            }), this), this.__cache__ = null, n
        }, r.prototype.getRules = function(t) {
            return null === this.__cache__ && this.__compile__(), this.__cache__[t] || []
        }, t.exports = r
    }, function(t, e, n) {
        "use strict";

        function r(t, e, n) {
            this.type = t, this.tag = e, this.attrs = null, this.map = null, this.nesting = n, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1
        }
        r.prototype.attrIndex = function(t) {
            var e, i, n;
            if (!this.attrs) return -1;
            for (i = 0, n = (e = this.attrs).length; i < n; i++)
                if (e[i][0] === t) return i;
            return -1
        }, r.prototype.attrPush = function(t) {
            this.attrs ? this.attrs.push(t) : this.attrs = [t]
        }, r.prototype.attrSet = function(t, e) {
            var n = this.attrIndex(t),
                r = [t, e];
            n < 0 ? this.attrPush(r) : this.attrs[n] = r
        }, r.prototype.attrGet = function(t) {
            var e = this.attrIndex(t),
                n = null;
            return e >= 0 && (n = this.attrs[e][1]), n
        }, r.prototype.attrJoin = function(t, e) {
            var n = this.attrIndex(t);
            n < 0 ? this.attrPush([t, e]) : this.attrs[n][1] = this.attrs[n][1] + " " + e
        }, t.exports = r
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t) {
            return t.toLowerCase()
        }
    }, function(t, e, n) {
        "use strict";
        var r = {
            name: "ClientOnly",
            functional: !0,
            props: {
                placeholder: String,
                placeholderTag: {
                    type: String,
                    default: "div"
                }
            },
            render: function(t, e) {
                var n = e.parent,
                    r = e.slots,
                    o = e.props,
                    l = r(),
                    c = l.default;
                void 0 === c && (c = []);
                var h = l.placeholder;
                return n._isMounted ? c : (n.$once("hook:mounted", (function() {
                    n.$forceUpdate()
                })), o.placeholderTag && (o.placeholder || h) ? t(o.placeholderTag, {
                    class: ["client-only-placeholder"]
                }, o.placeholder || h) : c.length > 0 ? c.map((function() {
                    return t(!1)
                })) : t(!1))
            }
        };
        t.exports = r
    }, , , , function(t, e, n) {
        "use strict";
        var r, o = "object" == typeof Reflect ? Reflect : null,
            l = o && "function" == typeof o.apply ? o.apply : function(t, e, n) {
                return Function.prototype.apply.call(t, e, n)
            };
        r = o && "function" == typeof o.ownKeys ? o.ownKeys : Object.getOwnPropertySymbols ? function(t) {
            return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
        } : function(t) {
            return Object.getOwnPropertyNames(t)
        };
        var c = Number.isNaN || function(t) {
            return t != t
        };

        function h() {
            h.init.call(this)
        }
        t.exports = h, t.exports.once = function(t, e) {
            return new Promise((function(n, r) {
                function o(n) {
                    t.removeListener(e, l), r(n)
                }

                function l() {
                    "function" == typeof t.removeListener && t.removeListener("error", o), n([].slice.call(arguments))
                }
                S(t, e, l, {
                    once: !0
                }), "error" !== e && function(t, e, n) {
                    "function" == typeof t.on && S(t, "error", e, n)
                }(t, o, {
                    once: !0
                })
            }))
        }, h.EventEmitter = h, h.prototype._events = void 0, h.prototype._eventsCount = 0, h.prototype._maxListeners = void 0;
        var d = 10;

        function f(t) {
            if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
        }

        function m(t) {
            return void 0 === t._maxListeners ? h.defaultMaxListeners : t._maxListeners
        }

        function v(t, e, n, r) {
            var o, l, c, h;
            if (f(n), void 0 === (l = t._events) ? (l = t._events = Object.create(null), t._eventsCount = 0) : (void 0 !== l.newListener && (t.emit("newListener", e, n.listener ? n.listener : n), l = t._events), c = l[e]), void 0 === c) c = l[e] = n, ++t._eventsCount;
            else if ("function" == typeof c ? c = l[e] = r ? [n, c] : [c, n] : r ? c.unshift(n) : c.push(n), (o = m(t)) > 0 && c.length > o && !c.warned) {
                c.warned = !0;
                var d = new Error("Possible EventEmitter memory leak detected. " + c.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                d.name = "MaxListenersExceededWarning", d.emitter = t, d.type = e, d.count = c.length, h = d, console && console.warn && console.warn(h)
            }
            return t
        }

        function y() {
            if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
        }

        function _(t, e, n) {
            var r = {
                    fired: !1,
                    wrapFn: void 0,
                    target: t,
                    type: e,
                    listener: n
                },
                o = y.bind(r);
            return o.listener = n, r.wrapFn = o, o
        }

        function x(t, e, n) {
            var r = t._events;
            if (void 0 === r) return [];
            var o = r[e];
            return void 0 === o ? [] : "function" == typeof o ? n ? [o.listener || o] : [o] : n ? function(t) {
                for (var e = new Array(t.length), i = 0; i < e.length; ++i) e[i] = t[i].listener || t[i];
                return e
            }(o) : M(o, o.length)
        }

        function w(t) {
            var e = this._events;
            if (void 0 !== e) {
                var n = e[t];
                if ("function" == typeof n) return 1;
                if (void 0 !== n) return n.length
            }
            return 0
        }

        function M(t, e) {
            for (var n = new Array(e), i = 0; i < e; ++i) n[i] = t[i];
            return n
        }

        function S(t, e, n, r) {
            if ("function" == typeof t.on) r.once ? t.once(e, n) : t.on(e, n);
            else {
                if ("function" != typeof t.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
                t.addEventListener(e, (function o(l) {
                    r.once && t.removeEventListener(e, o), n(l)
                }))
            }
        }
        Object.defineProperty(h, "defaultMaxListeners", {
            enumerable: !0,
            get: function() {
                return d
            },
            set: function(t) {
                if ("number" != typeof t || t < 0 || c(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
                d = t
            }
        }), h.init = function() {
            void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
        }, h.prototype.setMaxListeners = function(t) {
            if ("number" != typeof t || t < 0 || c(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
            return this._maxListeners = t, this
        }, h.prototype.getMaxListeners = function() {
            return m(this)
        }, h.prototype.emit = function(t) {
            for (var e = [], i = 1; i < arguments.length; i++) e.push(arguments[i]);
            var n = "error" === t,
                r = this._events;
            if (void 0 !== r) n = n && void 0 === r.error;
            else if (!n) return !1;
            if (n) {
                var o;
                if (e.length > 0 && (o = e[0]), o instanceof Error) throw o;
                var c = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
                throw c.context = o, c
            }
            var h = r[t];
            if (void 0 === h) return !1;
            if ("function" == typeof h) l(h, this, e);
            else {
                var d = h.length,
                    f = M(h, d);
                for (i = 0; i < d; ++i) l(f[i], this, e)
            }
            return !0
        }, h.prototype.addListener = function(t, e) {
            return v(this, t, e, !1)
        }, h.prototype.on = h.prototype.addListener, h.prototype.prependListener = function(t, e) {
            return v(this, t, e, !0)
        }, h.prototype.once = function(t, e) {
            return f(e), this.on(t, _(this, t, e)), this
        }, h.prototype.prependOnceListener = function(t, e) {
            return f(e), this.prependListener(t, _(this, t, e)), this
        }, h.prototype.removeListener = function(t, e) {
            var n, r, o, i, l;
            if (f(e), void 0 === (r = this._events)) return this;
            if (void 0 === (n = r[t])) return this;
            if (n === e || n.listener === e) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[t], r.removeListener && this.emit("removeListener", t, n.listener || e));
            else if ("function" != typeof n) {
                for (o = -1, i = n.length - 1; i >= 0; i--)
                    if (n[i] === e || n[i].listener === e) {
                        l = n[i].listener, o = i;
                        break
                    }
                if (o < 0) return this;
                0 === o ? n.shift() : function(t, e) {
                    for (; e + 1 < t.length; e++) t[e] = t[e + 1];
                    t.pop()
                }(n, o), 1 === n.length && (r[t] = n[0]), void 0 !== r.removeListener && this.emit("removeListener", t, l || e)
            }
            return this
        }, h.prototype.off = h.prototype.removeListener, h.prototype.removeAllListeners = function(t) {
            var e, n, i;
            if (void 0 === (n = this._events)) return this;
            if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[t]), this;
            if (0 === arguments.length) {
                var r, o = Object.keys(n);
                for (i = 0; i < o.length; ++i) "removeListener" !== (r = o[i]) && this.removeAllListeners(r);
                return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
            }
            if ("function" == typeof(e = n[t])) this.removeListener(t, e);
            else if (void 0 !== e)
                for (i = e.length - 1; i >= 0; i--) this.removeListener(t, e[i]);
            return this
        }, h.prototype.listeners = function(t) {
            return x(this, t, !0)
        }, h.prototype.rawListeners = function(t) {
            return x(this, t, !1)
        }, h.listenerCount = function(t, e) {
            return "function" == typeof t.listenerCount ? t.listenerCount(e) : w.call(t, e)
        }, h.prototype.listenerCount = w, h.prototype.eventNames = function() {
            return this._eventsCount > 0 ? r(this._events) : []
        }
    }, , function(t, e, n) {
        "use strict";
        e.html = n(399), e.svg = n(402), e.normalize = n(154), e.find = n(404)
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, n) {
        "use strict";
        t.exports = function(t, e) {
            return e || (e = {}), "string" != typeof(t = t && t.__esModule ? t.default : t) ? t : (/^['"].*['"]$/.test(t) && (t = t.slice(1, -1)), e.hash && (t += e.hash), /["'() \t\n]/.test(t) || e.needQuotes ? '"'.concat(t.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"') : t)
        }
    }, , , , , , , , , , , , , , , , , , , , , , , function(t, e, n) {
        "use strict";
        t.exports = n(343)
    }, function(t, e, n) {
        "use strict";
        t.exports.encode = n(344), t.exports.decode = n(345), t.exports.format = n(346), t.exports.parse = n(347)
    }, function(t, e) {
        t.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
    }, function(t, e) {
        t.exports = /[\0-\x1F\x7F-\x9F]/
    }, function(t, e) {
        t.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
    }, function(t, e, n) {
        "use strict";
        var r = "<[A-Za-z][A-Za-z0-9\\-]*(?:\\s+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:\\s*=\\s*(?:[^\"'=<>`\\x00-\\x20]+|'[^']*'|\"[^\"]*\"))?)*\\s*\\/?>",
            o = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>",
            l = new RegExp("^(?:" + r + "|" + o + "|\x3c!----\x3e|\x3c!--(?:-?[^>-])(?:-?[^-])*--\x3e|<[?].*?[?]>|<![A-Z]+\\s+[^>]*>|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>)"),
            c = new RegExp("^(?:" + r + "|" + o + ")");
        t.exports.HTML_TAG_RE = l, t.exports.HTML_OPEN_CLOSE_TAG_RE = c
    }, function(t, e, n) {
        "use strict";
        t.exports.tokenize = function(t, e) {
            var i, n, r, o, l = t.pos,
                marker = t.src.charCodeAt(l);
            if (e) return !1;
            if (126 !== marker) return !1;
            if (r = (n = t.scanDelims(t.pos, !0)).length, o = String.fromCharCode(marker), r < 2) return !1;
            for (r % 2 && (t.push("text", "", 0).content = o, r--), i = 0; i < r; i += 2) t.push("text", "", 0).content = o + o, t.delimiters.push({
                marker: marker,
                jump: i,
                token: t.tokens.length - 1,
                level: t.level,
                end: -1,
                open: n.can_open,
                close: n.can_close
            });
            return t.pos += n.length, !0
        }, t.exports.postProcess = function(t) {
            var i, e, n, r, o, l = [],
                c = t.delimiters,
                h = t.delimiters.length;
            for (i = 0; i < h; i++) 126 === (n = c[i]).marker && -1 !== n.end && (r = c[n.end], (o = t.tokens[n.token]).type = "s_open", o.tag = "s", o.nesting = 1, o.markup = "~~", o.content = "", (o = t.tokens[r.token]).type = "s_close", o.tag = "s", o.nesting = -1, o.markup = "~~", o.content = "", "text" === t.tokens[r.token - 1].type && "~" === t.tokens[r.token - 1].content && l.push(r.token - 1));
            for (; l.length;) {
                for (e = (i = l.pop()) + 1; e < t.tokens.length && "s_close" === t.tokens[e].type;) e++;
                i !== --e && (o = t.tokens[e], t.tokens[e] = t.tokens[i], t.tokens[i] = o)
            }
        }
    }, function(t, e, n) {
        "use strict";
        t.exports.tokenize = function(t, e) {
            var i, n, r = t.pos,
                marker = t.src.charCodeAt(r);
            if (e) return !1;
            if (95 !== marker && 42 !== marker) return !1;
            for (n = t.scanDelims(t.pos, 42 === marker), i = 0; i < n.length; i++) t.push("text", "", 0).content = String.fromCharCode(marker), t.delimiters.push({
                marker: marker,
                length: n.length,
                jump: i,
                token: t.tokens.length - 1,
                level: t.level,
                end: -1,
                open: n.can_open,
                close: n.can_close
            });
            return t.pos += n.length, !0
        }, t.exports.postProcess = function(t) {
            var i, e, n, r, o, l, c = t.delimiters;
            for (i = t.delimiters.length - 1; i >= 0; i--) 95 !== (e = c[i]).marker && 42 !== e.marker || -1 !== e.end && (n = c[e.end], l = i > 0 && c[i - 1].end === e.end + 1 && c[i - 1].token === e.token - 1 && c[e.end + 1].token === n.token + 1 && c[i - 1].marker === e.marker, o = String.fromCharCode(e.marker), (r = t.tokens[e.token]).type = l ? "strong_open" : "em_open", r.tag = l ? "strong" : "em", r.nesting = 1, r.markup = l ? o + o : o, r.content = "", (r = t.tokens[n.token]).type = l ? "strong_close" : "em_close", r.tag = l ? "strong" : "em", r.nesting = -1, r.markup = l ? o + o : o, r.content = "", l && (t.tokens[c[i - 1].token].content = "", t.tokens[c[e.end + 1].token].content = "", i--))
        }
    }, , function(t, e, n) {
        "use strict";
        var r = n(400),
            o = n(238);
        t.exports = function(t) {
            var e, n, l = t.length,
                c = [],
                h = [],
                d = -1;
            for (; ++d < l;) e = t[d], c.push(e.property), h.push(e.normal), n = e.space;
            return new o(r.apply(null, c), r.apply(null, h), n)
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = o;
        var r = o.prototype;

        function o(t, e, n) {
            this.property = t, this.normal = e, n && (this.space = n)
        }
        r.space = null, r.normal = {}, r.property = {}
    }, function(t, e, n) {
        "use strict";
        var r = n(76);
        t.exports = r({
            space: "xlink",
            transform: function(t, e) {
                return "xlink:" + e.slice(5).toLowerCase()
            },
            properties: {
                xLinkActuate: null,
                xLinkArcRole: null,
                xLinkHref: null,
                xLinkRole: null,
                xLinkShow: null,
                xLinkTitle: null,
                xLinkType: null
            }
        })
    }, function(t, e, n) {
        "use strict";
        var r = n(241),
            o = n(116);
        t.exports = h, h.prototype = new r, h.prototype.defined = !0;
        var l = ["boolean", "booleanish", "overloadedBoolean", "number", "commaSeparated", "spaceSeparated", "commaOrSpaceSeparated"],
            c = l.length;

        function h(t, e, mask, n) {
            var h, d = -1;
            for (mark(this, "space", n), r.call(this, t, e); ++d < c;) mark(this, h = l[d], (mask & o[h]) === o[h])
        }

        function mark(t, e, n) {
            n && (t[e] = n)
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = o;
        var r = o.prototype;

        function o(t, e) {
            this.property = t, this.attribute = e
        }
        r.space = null, r.attribute = null, r.property = null, r.boolean = !1, r.booleanish = !1, r.overloadedBoolean = !1, r.number = !1, r.commaSeparated = !1, r.spaceSeparated = !1, r.commaOrSpaceSeparated = !1, r.mustUseProperty = !1, r.defined = !1
    }, function(t, e, n) {
        "use strict";
        var r = n(76);
        t.exports = r({
            space: "xml",
            transform: function(t, e) {
                return "xml:" + e.slice(3).toLowerCase()
            },
            properties: {
                xmlLang: null,
                xmlBase: null,
                xmlSpace: null
            }
        })
    }, function(t, e, n) {
        "use strict";
        var r = n(76),
            o = n(244);
        t.exports = r({
            space: "xmlns",
            attributes: {
                xmlnsxlink: "xmlns:xlink"
            },
            transform: o,
            properties: {
                xmlns: null,
                xmlnsXLink: null
            }
        })
    }, function(t, e, n) {
        "use strict";
        var r = n(245);
        t.exports = function(t, e) {
            return r(t, e.toLowerCase())
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t, e) {
            return e in t ? t[e] : e
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(116),
            o = n(76),
            l = r.booleanish,
            c = r.number,
            h = r.spaceSeparated;
        t.exports = o({
            transform: function(t, e) {
                return "role" === e ? e : "aria-" + e.slice(4).toLowerCase()
            },
            properties: {
                ariaActiveDescendant: null,
                ariaAtomic: l,
                ariaAutoComplete: null,
                ariaBusy: l,
                ariaChecked: l,
                ariaColCount: c,
                ariaColIndex: c,
                ariaColSpan: c,
                ariaControls: h,
                ariaCurrent: null,
                ariaDescribedBy: h,
                ariaDetails: null,
                ariaDisabled: l,
                ariaDropEffect: h,
                ariaErrorMessage: null,
                ariaExpanded: l,
                ariaFlowTo: h,
                ariaGrabbed: l,
                ariaHasPopup: null,
                ariaHidden: l,
                ariaInvalid: null,
                ariaKeyShortcuts: null,
                ariaLabel: null,
                ariaLabelledBy: h,
                ariaLevel: c,
                ariaLive: null,
                ariaModal: l,
                ariaMultiLine: l,
                ariaMultiSelectable: l,
                ariaOrientation: null,
                ariaOwns: h,
                ariaPlaceholder: null,
                ariaPosInSet: c,
                ariaPressed: l,
                ariaReadOnly: l,
                ariaRelevant: null,
                ariaRequired: l,
                ariaRoleDescription: h,
                ariaRowCount: c,
                ariaRowIndex: c,
                ariaRowSpan: c,
                ariaSelected: l,
                ariaSetSize: c,
                ariaSort: null,
                ariaValueMax: c,
                ariaValueMin: c,
                ariaValueNow: c,
                ariaValueText: null,
                role: null
            }
        })
    }, , function(t, e, n) {
        "use strict";
        e.a = function(t, e) {
            return e = e || {}, new Promise((function(n, r) {
                var s = new XMLHttpRequest,
                    o = [],
                    u = [],
                    i = {},
                    a = function() {
                        return {
                            ok: 2 == (s.status / 100 | 0),
                            statusText: s.statusText,
                            status: s.status,
                            url: s.responseURL,
                            text: function() {
                                return Promise.resolve(s.responseText)
                            },
                            json: function() {
                                return Promise.resolve(s.responseText).then(JSON.parse)
                            },
                            blob: function() {
                                return Promise.resolve(new Blob([s.response]))
                            },
                            clone: a,
                            headers: {
                                keys: function() {
                                    return o
                                },
                                entries: function() {
                                    return u
                                },
                                get: function(t) {
                                    return i[t.toLowerCase()]
                                },
                                has: function(t) {
                                    return t.toLowerCase() in i
                                }
                            }
                        }
                    };
                for (var l in s.open(e.method || "get", t, !0), s.onload = function() {
                        s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, (function(t, e, n) {
                            o.push(e = e.toLowerCase()), u.push([e, n]), i[e] = i[e] ? i[e] + "," + n : n
                        })), n(a())
                    }, s.onerror = r, s.withCredentials = "include" == e.credentials, e.headers) s.setRequestHeader(l, e.headers[l]);
                s.send(e.body || null)
            }))
        }
    }, function(t, e, n) {
        "use strict";
        var r = function(t) {
            return function(t) {
                return !!t && "object" == typeof t
            }(t) && ! function(t) {
                var e = Object.prototype.toString.call(t);
                return "[object RegExp]" === e || "[object Date]" === e || function(t) {
                    return t.$$typeof === o
                }(t)
            }(t)
        };
        var o = "function" == typeof Symbol && Symbol.for ? Symbol.for("react.element") : 60103;

        function l(t, e) {
            return !1 !== e.clone && e.isMergeableObject(t) ? m((n = t, Array.isArray(n) ? [] : {}), t, e) : t;
            var n
        }

        function c(t, source, e) {
            return t.concat(source).map((function(element) {
                return l(element, e)
            }))
        }

        function h(t) {
            return Object.keys(t).concat(function(t) {
                return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t).filter((function(symbol) {
                    return t.propertyIsEnumerable(symbol)
                })) : []
            }(t))
        }

        function d(object, t) {
            try {
                return t in object
            } catch (t) {
                return !1
            }
        }

        function f(t, source, e) {
            var n = {};
            return e.isMergeableObject(t) && h(t).forEach((function(r) {
                n[r] = l(t[r], e)
            })), h(source).forEach((function(r) {
                (function(t, e) {
                    return d(t, e) && !(Object.hasOwnProperty.call(t, e) && Object.propertyIsEnumerable.call(t, e))
                })(t, r) || (d(t, r) && e.isMergeableObject(source[r]) ? n[r] = function(t, e) {
                    if (!e.customMerge) return m;
                    var n = e.customMerge(t);
                    return "function" == typeof n ? n : m
                }(r, e)(t[r], source[r], e) : n[r] = l(source[r], e))
            })), n
        }

        function m(t, source, e) {
            (e = e || {}).arrayMerge = e.arrayMerge || c, e.isMergeableObject = e.isMergeableObject || r, e.cloneUnlessOtherwiseSpecified = l;
            var n = Array.isArray(source);
            return n === Array.isArray(t) ? n ? e.arrayMerge(t, source, e) : f(t, source, e) : l(source, e)
        }
        m.all = function(t, e) {
            if (!Array.isArray(t)) throw new Error("first argument should be an array");
            return t.reduce((function(t, n) {
                return m(t, n, e)
            }), {})
        };
        var v = m;
        t.exports = v
    }, , function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
            return l
        }));
        var r = n(2),
            o = n(68);
        class l extends o.b {
            constructor(t, e, n, o, l) {
                super(), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = o, this.clearAlpha = void 0 !== l ? l : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new r.d
            }
            render(t, e, n) {
                const r = t.autoClear;
                let o, l;
                t.autoClear = !1, void 0 !== this.overrideMaterial && (l = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (t.getClearColor(this._oldClearColor), o = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(this._oldClearColor, o), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = l), t.autoClear = r
            }
        }
    }, , , function(t, e, n) {
        "undefined" != typeof self && self, t.exports = function(t) {
            var e = {};

            function n(r) {
                if (e[r]) return e[r].exports;
                var o = e[r] = {
                    i: r,
                    l: !1,
                    exports: {}
                };
                return t[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports
            }
            return n.m = t, n.c = e, n.d = function(t, e, r) {
                n.o(t, e) || Object.defineProperty(t, e, {
                    enumerable: !0,
                    get: r
                })
            }, n.r = function(t) {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                    value: "Module"
                }), Object.defineProperty(t, "__esModule", {
                    value: !0
                })
            }, n.t = function(t, e) {
                if (1 & e && (t = n(t)), 8 & e) return t;
                if (4 & e && "object" == typeof t && t && t.__esModule) return t;
                var r = Object.create(null);
                if (n.r(r), Object.defineProperty(r, "default", {
                        enumerable: !0,
                        value: t
                    }), 2 & e && "string" != typeof t)
                    for (var o in t) n.d(r, o, function(e) {
                        return t[e]
                    }.bind(null, o));
                return r
            }, n.n = function(t) {
                var e = t && t.__esModule ? function() {
                    return t.default
                } : function() {
                    return t
                };
                return n.d(e, "a", e), e
            }, n.o = function(t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }, n.p = "", n(n.s = 0)
        }([function(t, e, n) {
            "use strict";

            function r(t, e) {
                var n = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(t);
                    e && (r = r.filter((function(e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    }))), n.push.apply(n, r)
                }
                return n
            }

            function o(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var n = null != arguments[e] ? arguments[e] : {};
                    e % 2 ? r(n, !0).forEach((function(e) {
                        i(t, e, n[e])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : r(n).forEach((function(e) {
                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                    }))
                }
                return t
            }

            function i(t, e, n) {
                return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = n, t
            }
            n.r(e);
            var a = o({}, {
                $vue: null,
                id: null,
                router: null,
                fields: {},
                customIdFields: {},
                ignoreRoutes: [],
                linkers: [],
                commands: {},
                disabled: !1,
                customResourceURL: null,
                set: [],
                require: [],
                ecommerce: {
                    enabled: !1,
                    options: null,
                    enhanced: !1
                },
                autoTracking: {
                    screenview: !1,
                    shouldRouterUpdate: null,
                    skipSamePath: !1,
                    exception: !1,
                    exceptionLogs: !0,
                    page: !0,
                    transformQueryString: !0,
                    pageviewOnLoad: !0,
                    pageviewTemplate: null,
                    untracked: !0,
                    prependBase: !0
                },
                debug: {
                    enabled: !1,
                    trace: !1,
                    sendHitTask: !0
                },
                batch: {
                    enabled: !1,
                    delay: 500,
                    amount: 2
                },
                checkDuplicatedScript: !1,
                disableScriptLoader: !1,
                beforeFirstHit: s,
                ready: s,
                untracked: []
            });

            function u(t) {
                ! function t(e, n) {
                    return Object.keys(n).forEach((function(r) {
                        var o = e[r] && Object.prototype.toString.call(e[r]);
                        "[object Object]" !== o && "[object Array]" !== o ? e[r] = n[r] : t(e[r], n[r])
                    })), e
                }(a, t)
            }

            function l() {
                return a.id ? [].concat(a.id) : []
            }
            var c = a;

            function s() {}
            var p = function(t) {
                console.warn("[vue-analytics] ".concat(t))
            };

            function h(t, e) {
                return new Promise((function(n, r) {
                    var o = document.head || document.getElementsByTagName("head")[0],
                        i = document.createElement("script");
                    if (i.async = !0, i.src = t, i.charset = "utf-8", e) {
                        var l = document.createElement("link");
                        l.href = e, l.rel = "preconnect", o.appendChild(l)
                    }
                    o.appendChild(i), i.onload = n, i.onerror = r
                }))
            }

            function d(t) {
                return t.name || t.replace(/-/gi, "")
            }

            function b(t, e) {
                if (l().length > 1) {
                    var n = d(e);
                    return "".concat(n, ".").concat(t)
                }
                return t
            }
            var f, m = function(t) {
                if (t.then) return t;
                if ("function" == typeof t) {
                    var e = t();
                    return e.then ? e : Promise.resolve(e)
                }
                return Promise.resolve(t)
            };

            function g(t) {
                return function(t) {
                    if (Array.isArray(t)) {
                        for (var e = 0, n = new Array(t.length); e < t.length; e++) n[e] = t[e];
                        return n
                    }
                }(t) || function(t) {
                    if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t)) return Array.from(t)
                }(t) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance")
                }()
            }
            var v = [];

            function y(t) {
                for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
                "undefined" != typeof window && l().forEach((function(e) {
                    var r, o = {
                        m: b(t, e),
                        a: n
                    };
                    window.ga ? c.batch.enabled ? (v.push(o), f || (f = setInterval((function() {
                        v.length ? v.splice(0, c.batch.amount).forEach((function(t) {
                            var e;
                            (e = window).ga.apply(e, [t.m].concat(g(t.a)))
                        })) : (clearInterval(f), f = null)
                    }), c.batch.delay))) : (r = window).ga.apply(r, [b(t, e)].concat(n)) : c.untracked.push(o)
                }))
            }

            function _(t) {
                return (_ = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                })(t)
            }

            function x() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                "object" !== _(e[0]) || e[0].constructor !== Object ? y("set", e[0], e[1]) : y("set", e[0])
            }

            function w(t, e) {
                var n = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(t);
                    e && (r = r.filter((function(e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    }))), n.push.apply(n, r)
                }
                return n
            }

            function M(t, e, n) {
                return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = n, t
            }

            function S() {
                if (window.ga || !c.debug.enabled) {
                    if (window.ga) {
                        var t = l();
                        c.debug.enabled && (window.ga_debug = {
                            trace: c.debug.trace
                        }), t.forEach((function(e) {
                            var n = d(e),
                                r = c.customIdFields[e] || {},
                                o = t.length > 1 ? function(t) {
                                    for (var e = 1; e < arguments.length; e++) {
                                        var n = null != arguments[e] ? arguments[e] : {};
                                        e % 2 ? w(n, !0).forEach((function(e) {
                                            M(t, e, n[e])
                                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : w(n).forEach((function(e) {
                                            Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                                        }))
                                    }
                                    return t
                                }({}, c.fields, {}, r, {
                                    name: n
                                }) : c.fields;
                            window.ga("create", e.id || e, "auto", o)
                        })), c.beforeFirstHit();
                        var e = c.ecommerce;
                        if (e.enabled) {
                            var n = e.enhanced ? "ec" : "ecommerce";
                            e.options ? y("require", n, e.options) : y("require", n)
                        }
                        c.linkers.length > 0 && (y("require", "linker"), y("linker:autoLink", c.linkers)), c.debug.sendHitTask || x("sendHitTask", null)
                    }
                } else p("Google Analytics has probably been blocked.")
            }
            var T = function() {
                2 != arguments.length ? y("require", arguments.length <= 0 ? void 0 : arguments[0]) : y("require", arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1])
            };

            function E(t) {
                return (E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                })(t)
            }
            var A = function() {
                var t;
                c.set.forEach((function(t) {
                    var e = t.field,
                        n = t.value;
                    if (void 0 === e || void 0 === n) throw new Error('[vue-analytics] Wrong configuration in the plugin options.\nThe "set" array requires each item to have a "field" and a "value" property.');
                    x(e, n)
                })), t = ["ec", "ecommerce"], c.require.forEach((function(e) {
                    if (-1 !== t.indexOf(e) || -1 !== t.indexOf(e.name)) throw new Error("[vue-analytics] The ecommerce features are built-in in the plugin. \nFollow the ecommerce instructions available in the documentation.");
                    if ("string" != typeof e && "object" !== E(e)) throw new Error('[vue-analytics] Wrong configuration in the plugin options. \nThe "require" array requires each item to be a string or to have a "name" and an "options" property.');
                    var n = e.name || e;
                    e.options ? T(n, e.options) : T(n)
                }))
            };

            function C() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                var r = e[0];
                if (1 === e.length && "string" == typeof r) return y("send", "screenview", {
                    screenName: r
                });
                y.apply(void 0, ["send", "screenview"].concat(e))
            }

            function L(t) {
                return (L = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                })(t)
            }

            function q() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                var r;
                e.length && !e[0] || (e.length && e[0].currentRoute && (r = e[0].currentRoute), e.length && function(t) {
                    return t.query && t.params
                }(e[0]) && (r = e[0]), r ? k(r) : (x("page", "object" === L(e[0]) ? e[0].page : e[0]), y.apply(void 0, ["send", "pageview"].concat(e))))
            }

            function k(t) {
                if (![(e = t).name, e.path].filter(Boolean).find((function(t) {
                        return -1 !== c.ignoreRoutes.indexOf(t)
                    }))) {
                    var e, n = c.autoTracking,
                        r = t.meta.analytics,
                        o = (void 0 === r ? {} : r).pageviewTemplate || n.pageviewTemplate;
                    if (n.screenview && !t.name) throw new Error("[vue-analytics] Route name is mandatory when using screenview.");
                    if (n.screenview) C(t.name);
                    else if (o) q(o(t));
                    else {
                        var i = c.router,
                            l = c.autoTracking,
                            a = l.transformQueryString,
                            u = l.prependBase,
                            h = function(t) {
                                var e = Object.keys(t).reduce((function(e, n, r, o) {
                                    var i = r === o.length - 1,
                                        l = t[n];
                                    return null == l ? e : e += "".concat(n, "=").concat(l).concat(i ? "" : "&")
                                }), "");
                                return "" !== e ? "?".concat(e) : ""
                            }(t.query),
                            s = i && i.options.base,
                            p = u && s,
                            d = t.path + (a ? h : "");
                        q(d = p ? function(t, e) {
                            var n = e.split("/"),
                                r = t.split("/");
                            return "" === n[0] && "/" === t[t.length - 1] && n.shift(), r.join("/") + n.join("/")
                        }(s, d) : d)
                    }
                }
            }

            function R(t) {
                return function(t) {
                    if (Array.isArray(t)) {
                        for (var e = 0, n = new Array(t.length); e < t.length; e++) n[e] = t[e];
                        return n
                    }
                }(t) || function(t) {
                    if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t)) return Array.from(t)
                }(t) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance")
                }()
            }
            var P = function() {
                    var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    "undefined" != typeof window && l().forEach((function(e) {
                        window["ga-disable-".concat(e)] = t
                    }))
                },
                D = function() {
                    if ("undefined" != typeof document && "undefined" != typeof window) {
                        if (c.id) {
                            var t, e, n = [m(c.id), m(c.disabled)];
                            if (t = c.checkDuplicatedScript, e = c.disableScriptLoader, [Boolean(window && window.ga), t && !(Array.prototype.slice.call(document.getElementsByTagName("script")).filter((function(t) {
                                    return -1 !== t.src.indexOf("analytics") || -1 !== t.src.indexOf("gtag")
                                })).length > 0), !e].some(Boolean)) {
                                var r = "https://www.google-analytics.com",
                                    o = c.debug.enabled ? "analytics_debug" : "analytics",
                                    i = c.customResourceURL ? h(c.customResourceURL) : h("".concat(r, "/").concat(o, ".js"), r);
                                n.push(i.catch((function() {
                                    p("An error occured! Please check your connection or disable your AD blocker")
                                })))
                            }
                            return Promise.all(n).then((function(t) {
                                var e, n, r;
                                u({
                                    id: t[0],
                                    disabled: t[1]
                                }), P(c.disabled), S(), A(), c.untracked.forEach((function(t) {
                                    y.apply(void 0, [t.m].concat(R(t.a)))
                                })), e = c.router, n = c.autoTracking, r = c.$vue, n.page && e && e.onReady((function() {
                                    n.pageviewOnLoad && e.history.ready && k(e.currentRoute), e.afterEach((function(t, o) {
                                        var i = n.skipSamePath,
                                            l = n.shouldRouterUpdate;
                                        i && t.path === o.path || ("function" != typeof l || l(t, o)) && r.nextTick().then((function() {
                                            k(e.currentRoute)
                                        }))
                                    }))
                                })), c.ready()
                            })).catch((function(t) {
                                c.debug.enabled && p(t.message)
                            }))
                        }
                        p('Missing the "id" parameter. Add at least one tracking domain ID')
                    }
                },
                O = function(t) {
                    y("send", "exception", {
                        exDescription: t,
                        exFatal: arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                    })
                },
                I = function(t) {
                    if (c.autoTracking.exception) {
                        window.addEventListener("error", (function(t) {
                            O(t.message)
                        }));
                        var e = t.config.errorHandler;
                        t.config.errorHandler = function(t, n, r) {
                            O(t.message), c.autoTracking.exceptionLogs && console.error(t), "function" == typeof e && e.call(void 0, t, n, r)
                        }
                    }
                },
                N = O;

            function F(t, e) {
                var n = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(t);
                    e && (r = r.filter((function(e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    }))), n.push.apply(n, r)
                }
                return n
            }

            function z(t, e, n) {
                return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = n, t
            }
            var B = function(t) {
                    return "".concat(c.ecommerce.enhanced ? "ec" : "ecommerce", ":").concat(t)
                },
                U = ["addItem", "addTransaction", "addProduct", "addImpression", "setAction", "addPromo", "send"].reduce((function(t, e) {
                    return function(t) {
                        for (var e = 1; e < arguments.length; e++) {
                            var n = null != arguments[e] ? arguments[e] : {};
                            e % 2 ? F(n, !0).forEach((function(e) {
                                z(t, e, n[e])
                            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : F(n).forEach((function(e) {
                                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                            }))
                        }
                        return t
                    }({}, t, z({}, e, (function() {
                        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
                        y.apply(void 0, [B(e)].concat(n))
                    })))
                }), {}),
                H = {
                    event: function() {
                        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        y.apply(void 0, ["send", "event"].concat(e))
                    },
                    exception: N,
                    page: q,
                    query: y,
                    require: T,
                    set: x,
                    social: function() {
                        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        y.apply(void 0, ["send", "social"].concat(e))
                    },
                    time: function() {
                        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        y.apply(void 0, ["send", "timing"].concat(e))
                    },
                    screenview: C,
                    ecommerce: U,
                    disable: function() {
                        return P(!0)
                    },
                    enable: function() {
                        return P(!1)
                    },
                    commands: c.commands
                },
                j = {
                    inserted: function(t, e, n) {
                        var r = Object.keys(e.modifiers);
                        0 === r.length && r.push("click"), r.forEach((function(r) {
                            t.addEventListener(r, (function() {
                                var t = "string" == typeof e.value ? c.commands[e.value] : e.value;
                                if (!t) throw new Error("[vue-analytics] The value passed to v-ga is not defined in the commands list.");
                                t.apply(n.context)
                            }))
                        }))
                    }
                };

            function V(t) {
                return function(t) {
                    if (Array.isArray(t)) {
                        for (var e = 0, n = new Array(t.length); e < t.length; e++) n[e] = t[e];
                        return n
                    }
                }(t) || function(t) {
                    if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t)) return Array.from(t)
                }(t) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance")
                }()
            }

            function G(t, e) {
                return function(t) {
                    if (Array.isArray(t)) return t
                }(t) || function(t, e) {
                    if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t)) {
                        var n = [],
                            r = !0,
                            o = !1,
                            i = void 0;
                        try {
                            for (var l, a = t[Symbol.iterator](); !(r = (l = a.next()).done) && (n.push(l.value), !e || n.length !== e); r = !0);
                        } catch (t) {
                            o = !0, i = t
                        } finally {
                            try {
                                r || null == a.return || a.return()
                            } finally {
                                if (o) throw i
                            }
                        }
                        return n
                    }
                }(t, e) || function() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance")
                }()
            }

            function W(t, e) {
                var n = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(t);
                    e && (r = r.filter((function(e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    }))), n.push.apply(n, r)
                }
                return n
            }

            function X(t, e, n) {
                return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = n, t
            }

            function $(t) {
                u(function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var n = null != arguments[e] ? arguments[e] : {};
                        e % 2 ? W(n, !0).forEach((function(e) {
                            X(t, e, n[e])
                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : W(n).forEach((function(e) {
                            Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                        }))
                    }
                    return t
                }({}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, {
                    $vue: t
                })), t.directive("ga", j), t.prototype.$ga = t.$ga = H, I(t), D()
            }
            n.d(e, "default", (function() {
                return $
            })), n.d(e, "analyticsMiddleware", (function() {
                return Y
            })), n.d(e, "onAnalyticsReady", (function() {
                return Z
            })), n.d(e, "event", (function() {
                return J
            })), n.d(e, "ecommerce", (function() {
                return K
            })), n.d(e, "set", (function() {
                return Q
            })), n.d(e, "page", (function() {
                return tt
            })), n.d(e, "query", (function() {
                return et
            })), n.d(e, "screenview", (function() {
                return nt
            })), n.d(e, "time", (function() {
                return it
            })), n.d(e, "require", (function() {
                return ot
            })), n.d(e, "exception", (function() {
                return at
            })), n.d(e, "social", (function() {
                return st
            }));
            var Y = function(t) {
                    t.subscribe((function(t) {
                        var e = t.payload;
                        if (e && e.meta && e.meta.analytics) {
                            var n = e.meta.analytics;
                            if (!Array.isArray(n)) throw new Error('The "analytics" property needs to be an array');
                            n.forEach((function(t) {
                                var e, n, r = t.shift(),
                                    o = t;
                                if (r.includes(":")) {
                                    var i = G(r.split(":"), 2);
                                    r = i[0], e = i[1]
                                }
                                if (!(r in H)) throw new Error('[vue-analytics:vuex] The type "'.concat(r, "\" doesn't exist."));
                                if (e && !(e in H[r])) throw new Error('[vue-analytics:vuex] The type "'.concat(r, '" has not method "').concat(e, '".'));
                                if ("ecommerce" === r && !e) throw new Error('[vue-analytics:vuex] The type "'.concat(r, '" needs to call a method. Check documentation.'));
                                e ? (n = H[r])[e].apply(n, V(o)) : H[r].apply(H, V(o))
                            }))
                        }
                    }))
                },
                Z = function() {
                    return new Promise((function(t, e) {
                        var n = setInterval((function() {
                            "undefined" != typeof window && window.ga && (t(), clearInterval(n))
                        }), 10)
                    }))
                },
                J = H.event,
                K = H.ecommerce,
                Q = H.set,
                tt = H.page,
                et = H.query,
                nt = H.screenview,
                it = H.time,
                ot = H.require,
                at = H.exception,
                st = H.social
        }])
    }, , function(t, e, n) {
        "use strict";
        t.exports = n(342)
    }, function(t, e) {}, function(t, e, n) {
        "use strict";
        var r = n(259),
            o = n(260),
            l = n.n(o),
            c = 0;

        function h(t) {
            var e = this;
            this.player.on(t, (function(i) {
                e.$emit(t, i, e.player)
            }))
        }
        var d = ["play", "playing", "pause", "ended", "timeupdate", "progress", "seeking", "seeked", "texttrackchange", "chapterchange", "cuechange", "cuepoint", "volumechange", "playbackratechange", "bufferstart", "bufferend", "error", "loaded", "durationchange", "fullscreenchange", "qualitychange", "camerachange", "resize"],
            f = {
                props: {
                    playerHeight: {
                        default: 320
                    },
                    playerWidth: {
                        default: 640
                    },
                    options: {
                        type: Object,
                        default: function() {
                            return {}
                        }
                    },
                    videoId: {
                        type: String,
                        default: ""
                    },
                    videoUrl: {
                        type: String,
                        default: ""
                    },
                    loop: {
                        type: Boolean,
                        default: !1
                    },
                    autoplay: {
                        type: Boolean,
                        default: !1
                    },
                    controls: {
                        type: Boolean,
                        default: !0
                    },
                    eventsToEmit: {
                        type: Array,
                        default: function() {
                            return d
                        }
                    }
                },
                data: function() {
                    return {
                        elementId: "vimeo-player-" + (c += 1),
                        player: null
                    }
                },
                computed: {
                    getOptions: function() {
                        var t = {
                            width: this.playerWidth,
                            height: this.playerHeight,
                            loop: this.loop,
                            autoplay: this.autoplay,
                            controls: this.controls
                        };
                        return this.videoUrl && (t.url = this.videoUrl), this.videoId && (t.id = this.videoId), l()(t, this.options)
                    }
                },
                watch: {
                    videoId: "update",
                    videoUrl: "update",
                    controls: "update"
                },
                mounted: function() {
                    this.videoUrl || this.videoId || console.warn("[VueVimeoPlayer]: You must provide at least a videoUrl or videoId"), this.player = new r.a(this.elementId, this.getOptions), this.setEvents()
                },
                beforeDestroy: function() {
                    this.player.unload()
                },
                methods: {
                    update: function() {
                        return this.player.loadVideo(this.getOptions)
                    },
                    play: function() {
                        return this.player.play()
                    },
                    pause: function() {
                        return this.player.pause()
                    },
                    mute: function() {
                        return this.player.setVolume(0)
                    },
                    unmute: function(t) {
                        return void 0 === t && (t = .5), this.player.setVolume(t)
                    },
                    setEvents: function() {
                        var t = this;
                        this.player.ready().then((function() {
                            t.$emit("ready", t.player)
                        })).catch((function(e) {
                            t.$emit("error", e, t.player)
                        })), this.eventsToEmit.forEach((function(e) {
                            return h.call(t, e)
                        }))
                    }
                },
                render: function(t) {
                    return t("div", {
                        attrs: {
                            id: this.elementId
                        }
                    })
                }
            };

        function m(t, e) {
            t.component("vimeo-player", f)
        }
        m.version = "0.2.2", "undefined" != typeof window && window.Vue && window.Vue.use(m), e.a = m
    }, function(t, e, n) {
        "use strict";
        (function(t, n) {
            function r(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            function o(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            var l = void 0 !== t && "[object global]" === {}.toString.call(t);

            function c(t, e) {
                return 0 === t.indexOf(e.toLowerCase()) ? t : "".concat(e.toLowerCase()).concat(t.substr(0, 1).toUpperCase()).concat(t.substr(1))
            }

            function h(element) {
                return Boolean(element && 1 === element.nodeType && "nodeName" in element && element.ownerDocument && element.ownerDocument.defaultView)
            }

            function d(t) {
                return !isNaN(parseFloat(t)) && isFinite(t) && Math.floor(t) == t
            }

            function f(t) {
                return /^(https?:)?\/\/((player|www)\.)?vimeo\.com(?=$|\/)/.test(t)
            }

            function m() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    e = t.id,
                    n = t.url,
                    r = e || n;
                if (!r) throw new Error("An id or url must be passed, either in an options object or as a data-vimeo-id or data-vimeo-url attribute.");
                if (d(r)) return "https://vimeo.com/".concat(r);
                if (f(r)) return r.replace("http:", "https:");
                if (e) throw new TypeError("".concat(e, " is not a valid video id."));
                throw new TypeError("".concat(r, " is not a vimeo.com url."))
            }
            var v = void 0 !== Array.prototype.indexOf,
                y = "undefined" != typeof window && void 0 !== window.postMessage;
            if (!(l || v && y)) throw new Error("Sorry, the Vimeo Player API is not available in this browser.");
            var _ = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== t ? t : "undefined" != typeof self ? self : {};
            ! function(t) {
                if (!t.WeakMap) {
                    var e = Object.prototype.hasOwnProperty,
                        n = function(object, t, e) {
                            Object.defineProperty ? Object.defineProperty(object, t, {
                                configurable: !0,
                                writable: !0,
                                value: e
                            }) : object[t] = e
                        };
                    t.WeakMap = function() {
                        function t() {
                            if (void 0 === this) throw new TypeError("Constructor WeakMap requires 'new'");
                            if (n(this, "_id", l("_WeakMap")), arguments.length > 0) throw new TypeError("WeakMap iterable is not supported")
                        }

                        function o(t, n) {
                            if (!r(t) || !e.call(t, "_id")) throw new TypeError(n + " method called on incompatible receiver " + typeof t)
                        }

                        function l(t) {
                            return t + "_" + c() + "." + c()
                        }

                        function c() {
                            return Math.random().toString().substring(2)
                        }
                        return n(t.prototype, "delete", (function(t) {
                            if (o(this, "delete"), !r(t)) return !1;
                            var e = t[this._id];
                            return !(!e || e[0] !== t) && (delete t[this._id], !0)
                        })), n(t.prototype, "get", (function(t) {
                            if (o(this, "get"), r(t)) {
                                var e = t[this._id];
                                return e && e[0] === t ? e[1] : void 0
                            }
                        })), n(t.prototype, "has", (function(t) {
                            if (o(this, "has"), !r(t)) return !1;
                            var e = t[this._id];
                            return !(!e || e[0] !== t)
                        })), n(t.prototype, "set", (function(t, e) {
                            if (o(this, "set"), !r(t)) throw new TypeError("Invalid value used as weak map key");
                            var l = t[this._id];
                            return l && l[0] === t ? (l[1] = e, this) : (n(t, this._id, [t, e]), this)
                        })), n(t, "_polyfill", !0), t
                    }()
                }

                function r(t) {
                    return Object(t) === t
                }
            }("undefined" != typeof self ? self : "undefined" != typeof window ? window : _);
            var x = function(t, e) {
                    return t(e = {
                        exports: {}
                    }, e.exports), e.exports
                }((function(t) {
                    var e, r, o;
                    o = function() {
                        var t, e, r, o = Object.prototype.toString,
                            l = void 0 !== n ? function(t) {
                                return n(t)
                            } : setTimeout;
                        try {
                            Object.defineProperty({}, "x", {}), t = function(t, e, n, r) {
                                return Object.defineProperty(t, e, {
                                    value: n,
                                    writable: !0,
                                    configurable: !1 !== r
                                })
                            }
                        } catch (e) {
                            t = function(t, e, n) {
                                return t[e] = n, t
                            }
                        }

                        function c(t, n) {
                            r.add(t, n), e || (e = l(r.drain))
                        }

                        function h(t) {
                            var e, n = typeof t;
                            return null == t || "object" != n && "function" != n || (e = t.then), "function" == typeof e && e
                        }

                        function d() {
                            for (var i = 0; i < this.chain.length; i++) f(this, 1 === this.state ? this.chain[i].success : this.chain[i].failure, this.chain[i]);
                            this.chain.length = 0
                        }

                        function f(t, e, n) {
                            var r, o;
                            try {
                                !1 === e ? n.reject(t.msg) : (r = !0 === e ? t.msg : e.call(void 0, t.msg)) === n.promise ? n.reject(TypeError("Promise-chain cycle")) : (o = h(r)) ? o.call(r, n.resolve, n.reject) : n.resolve(r)
                            } catch (t) {
                                n.reject(t)
                            }
                        }

                        function m(t) {
                            var e, n = this;
                            if (!n.triggered) {
                                n.triggered = !0, n.def && (n = n.def);
                                try {
                                    (e = h(t)) ? c((function() {
                                        var r = new _(n);
                                        try {
                                            e.call(t, (function() {
                                                m.apply(r, arguments)
                                            }), (function() {
                                                v.apply(r, arguments)
                                            }))
                                        } catch (t) {
                                            v.call(r, t)
                                        }
                                    })): (n.msg = t, n.state = 1, n.chain.length > 0 && c(d, n))
                                } catch (t) {
                                    v.call(new _(n), t)
                                }
                            }
                        }

                        function v(t) {
                            var e = this;
                            e.triggered || (e.triggered = !0, e.def && (e = e.def), e.msg = t, e.state = 2, e.chain.length > 0 && c(d, e))
                        }

                        function y(t, e, n, r) {
                            for (var o = 0; o < e.length; o++) ! function(o) {
                                t.resolve(e[o]).then((function(t) {
                                    n(o, t)
                                }), r)
                            }(o)
                        }

                        function _(t) {
                            this.def = t, this.triggered = !1
                        }

                        function x(t) {
                            this.promise = t, this.state = 0, this.triggered = !1, this.chain = [], this.msg = void 0
                        }

                        function w(t) {
                            if ("function" != typeof t) throw TypeError("Not a function");
                            if (0 !== this.__NPO__) throw TypeError("Not a promise");
                            this.__NPO__ = 1;
                            var e = new x(this);
                            this.then = function(t, n) {
                                var r = {
                                    success: "function" != typeof t || t,
                                    failure: "function" == typeof n && n
                                };
                                return r.promise = new this.constructor((function(t, e) {
                                    if ("function" != typeof t || "function" != typeof e) throw TypeError("Not a function");
                                    r.resolve = t, r.reject = e
                                })), e.chain.push(r), 0 !== e.state && c(d, e), r.promise
                            }, this.catch = function(t) {
                                return this.then(void 0, t)
                            };
                            try {
                                t.call(void 0, (function(t) {
                                    m.call(e, t)
                                }), (function(t) {
                                    v.call(e, t)
                                }))
                            } catch (t) {
                                v.call(e, t)
                            }
                        }
                        r = function() {
                            var t, n, r;

                            function o(t, e) {
                                this.fn = t, this.self = e, this.next = void 0
                            }
                            return {
                                add: function(e, l) {
                                    r = new o(e, l), n ? n.next = r : t = r, n = r, r = void 0
                                },
                                drain: function() {
                                    var r = t;
                                    for (t = n = e = void 0; r;) r.fn.call(r.self), r = r.next
                                }
                            }
                        }();
                        var M = t({}, "constructor", w, !1);
                        return w.prototype = M, t(M, "__NPO__", 0, !1), t(w, "resolve", (function(t) {
                            return t && "object" == typeof t && 1 === t.__NPO__ ? t : new this((function(e, n) {
                                if ("function" != typeof e || "function" != typeof n) throw TypeError("Not a function");
                                e(t)
                            }))
                        })), t(w, "reject", (function(t) {
                            return new this((function(e, n) {
                                if ("function" != typeof e || "function" != typeof n) throw TypeError("Not a function");
                                n(t)
                            }))
                        })), t(w, "all", (function(t) {
                            var e = this;
                            return "[object Array]" != o.call(t) ? e.reject(TypeError("Not an array")) : 0 === t.length ? e.resolve([]) : new e((function(n, r) {
                                if ("function" != typeof n || "function" != typeof r) throw TypeError("Not a function");
                                var o = t.length,
                                    l = Array(o),
                                    c = 0;
                                y(e, t, (function(t, e) {
                                    l[t] = e, ++c === o && n(l)
                                }), r)
                            }))
                        })), t(w, "race", (function(t) {
                            var e = this;
                            return "[object Array]" != o.call(t) ? e.reject(TypeError("Not an array")) : new e((function(n, r) {
                                if ("function" != typeof n || "function" != typeof r) throw TypeError("Not a function");
                                y(e, t, (function(t, e) {
                                    n(e)
                                }), r)
                            }))
                        })), w
                    }, (r = _)[e = "Promise"] = r[e] || o(), t.exports && (t.exports = r[e])
                })),
                w = new WeakMap;

            function M(t, e, n) {
                var r = w.get(t.element) || {};
                e in r || (r[e] = []), r[e].push(n), w.set(t.element, r)
            }

            function S(t, e) {
                return (w.get(t.element) || {})[e] || []
            }

            function T(t, e, n) {
                var r = w.get(t.element) || {};
                if (!r[e]) return !0;
                if (!n) return r[e] = [], w.set(t.element, r), !0;
                var o = r[e].indexOf(n);
                return -1 !== o && r[e].splice(o, 1), w.set(t.element, r), r[e] && 0 === r[e].length
            }

            function E(t, e) {
                var n = w.get(t);
                w.set(e, n), w.delete(t)
            }
            var A = ["autopause", "autoplay", "background", "byline", "color", "controls", "dnt", "height", "id", "keyboard", "loop", "maxheight", "maxwidth", "muted", "playsinline", "portrait", "responsive", "speed", "texttrack", "title", "transparent", "url", "width"];

            function C(element) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return A.reduce((function(t, param) {
                    var e = element.getAttribute("data-vimeo-".concat(param));
                    return (e || "" === e) && (t[param] = "" === e ? 1 : e), t
                }), t)
            }

            function L(t, element) {
                var html = t.html;
                if (!element) throw new TypeError("An element must be provided");
                if (null !== element.getAttribute("data-vimeo-initialized")) return element.querySelector("iframe");
                var div = document.createElement("div");
                return div.innerHTML = html, element.appendChild(div.firstChild), element.setAttribute("data-vimeo-initialized", "true"), element.querySelector("iframe")
            }

            function k(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    element = arguments.length > 2 ? arguments[2] : void 0;
                return new Promise((function(n, r) {
                    if (!f(t)) throw new TypeError("".concat(t, " is not a vimeo.com url."));
                    var o = "https://vimeo.com/api/oembed.json?url=".concat(encodeURIComponent(t));
                    for (var param in e) e.hasOwnProperty(param) && (o += "&".concat(param, "=").concat(encodeURIComponent(e[param])));
                    var l = "XDomainRequest" in window ? new XDomainRequest : new XMLHttpRequest;
                    l.open("GET", o, !0), l.onload = function() {
                        if (404 !== l.status)
                            if (403 !== l.status) try {
                                var e = JSON.parse(l.responseText);
                                if (403 === e.domain_status_code) return L(e, element), void r(new Error("".concat(t, " is not embeddable.")));
                                n(e)
                            } catch (t) {
                                r(t)
                            } else r(new Error("".concat(t, " is not embeddable.")));
                            else r(new Error("".concat(t, " was not found.")))
                    }, l.onerror = function() {
                        var t = l.status ? " (".concat(l.status, ")") : "";
                        r(new Error("There was an error fetching the embed code from Vimeo".concat(t, ".")))
                    }, l.send()
                }))
            }

            function R(data) {
                if ("string" == typeof data) try {
                    data = JSON.parse(data)
                } catch (t) {
                    return console.warn(t), {}
                }
                return data
            }

            function P(t, e, n) {
                if (t.element.contentWindow && t.element.contentWindow.postMessage) {
                    var r = {
                        method: e
                    };
                    void 0 !== n && (r.value = n);
                    var o = parseFloat(navigator.userAgent.toLowerCase().replace(/^.*msie (\d+).*$/, "$1"));
                    o >= 8 && o < 10 && (r = JSON.stringify(r)), t.element.contentWindow.postMessage(r, t.origin)
                }
            }

            function D(t, data) {
                var param, e = [];
                if ((data = R(data)).event) {
                    if ("error" === data.event) S(t, data.data.method).forEach((function(e) {
                        var n = new Error(data.data.message);
                        n.name = data.data.name, e.reject(n), T(t, data.data.method, e)
                    }));
                    e = S(t, "event:".concat(data.event)), param = data.data
                } else if (data.method) {
                    var n = function(t, e) {
                        var n = S(t, e);
                        if (n.length < 1) return !1;
                        var r = n.shift();
                        return T(t, e, r), r
                    }(t, data.method);
                    n && (e.push(n), param = data.value)
                }
                e.forEach((function(e) {
                    try {
                        if ("function" == typeof e) return void e.call(t, param);
                        e.resolve(param)
                    } catch (t) {}
                }))
            }
            var O = new WeakMap,
                I = new WeakMap,
                N = {},
                F = function() {
                    function t(element) {
                        var e = this,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        if (r(this, t), window.jQuery && element instanceof jQuery && (element.length > 1 && window.console && console.warn && console.warn("A jQuery object with multiple elements was passed, using the first element."), element = element[0]), "undefined" != typeof document && "string" == typeof element && (element = document.getElementById(element)), !h(element)) throw new TypeError("You must pass either a valid element or a valid id.");
                        if ("IFRAME" !== element.nodeName) {
                            var iframe = element.querySelector("iframe");
                            iframe && (element = iframe)
                        }
                        if ("IFRAME" === element.nodeName && !f(element.getAttribute("src") || "")) throw new Error("The player element passed isnt a Vimeo embed.");
                        if (O.has(element)) return O.get(element);
                        this._window = element.ownerDocument.defaultView, this.element = element, this.origin = "*";
                        var o = new x((function(t, r) {
                            if (e._onMessage = function(n) {
                                    if (f(n.origin) && e.element.contentWindow === n.source) {
                                        "*" === e.origin && (e.origin = n.origin);
                                        var data = R(n.data);
                                        if (data && "error" === data.event && data.data && "ready" === data.data.method) {
                                            var o = new Error(data.data.message);
                                            return o.name = data.data.name, void r(o)
                                        }
                                        var l = data && "ready" === data.event,
                                            c = data && "ping" === data.method;
                                        if (l || c) return e.element.setAttribute("data-ready", "true"), void t();
                                        D(e, data)
                                    }
                                }, e._window.addEventListener("message", e._onMessage), "IFRAME" !== e.element.nodeName) {
                                var o = C(element, n);
                                k(m(o), o, element).then((function(data) {
                                    var iframe = L(data, element);
                                    return e.element = iframe, e._originalElement = element, E(element, iframe), O.set(e.element, e), data
                                })).catch(r)
                            }
                        }));
                        if (I.set(this, o), O.set(this.element, this), "IFRAME" === this.element.nodeName && P(this, "ping"), N.isEnabled) {
                            var l = function() {
                                return N.exit()
                            };
                            this.fullscreenchangeHandler = function() {
                                N.isFullscreen ? M(e, "event:exitFullscreen", l) : T(e, "event:exitFullscreen", l), e.ready().then((function() {
                                    P(e, "fullscreenchange", N.isFullscreen)
                                }))
                            }, N.on("fullscreenchange", this.fullscreenchangeHandler)
                        }
                        return this
                    }
                    var e, n, l;
                    return e = t, n = [{
                        key: "callMethod",
                        value: function(t) {
                            var e = this,
                                n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            return new x((function(r, o) {
                                return e.ready().then((function() {
                                    M(e, t, {
                                        resolve: r,
                                        reject: o
                                    }), P(e, t, n)
                                })).catch(o)
                            }))
                        }
                    }, {
                        key: "get",
                        value: function(t) {
                            var e = this;
                            return new x((function(n, r) {
                                return t = c(t, "get"), e.ready().then((function() {
                                    M(e, t, {
                                        resolve: n,
                                        reject: r
                                    }), P(e, t)
                                })).catch(r)
                            }))
                        }
                    }, {
                        key: "set",
                        value: function(t, e) {
                            var n = this;
                            return new x((function(r, o) {
                                if (t = c(t, "set"), null == e) throw new TypeError("There must be a value to set.");
                                return n.ready().then((function() {
                                    M(n, t, {
                                        resolve: r,
                                        reject: o
                                    }), P(n, t, e)
                                })).catch(o)
                            }))
                        }
                    }, {
                        key: "on",
                        value: function(t, e) {
                            if (!t) throw new TypeError("You must pass an event name.");
                            if (!e) throw new TypeError("You must pass a callback function.");
                            if ("function" != typeof e) throw new TypeError("The callback must be a function.");
                            0 === S(this, "event:".concat(t)).length && this.callMethod("addEventListener", t).catch((function() {})), M(this, "event:".concat(t), e)
                        }
                    }, {
                        key: "off",
                        value: function(t, e) {
                            if (!t) throw new TypeError("You must pass an event name.");
                            if (e && "function" != typeof e) throw new TypeError("The callback must be a function.");
                            T(this, "event:".concat(t), e) && this.callMethod("removeEventListener", t).catch((function(t) {}))
                        }
                    }, {
                        key: "loadVideo",
                        value: function(t) {
                            return this.callMethod("loadVideo", t)
                        }
                    }, {
                        key: "ready",
                        value: function() {
                            var t = I.get(this) || new x((function(t, e) {
                                e(new Error("Unknown player. Probably unloaded."))
                            }));
                            return x.resolve(t)
                        }
                    }, {
                        key: "addCuePoint",
                        value: function(time) {
                            var data = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            return this.callMethod("addCuePoint", {
                                time: time,
                                data: data
                            })
                        }
                    }, {
                        key: "removeCuePoint",
                        value: function(t) {
                            return this.callMethod("removeCuePoint", t)
                        }
                    }, {
                        key: "enableTextTrack",
                        value: function(t, e) {
                            if (!t) throw new TypeError("You must pass a language.");
                            return this.callMethod("enableTextTrack", {
                                language: t,
                                kind: e
                            })
                        }
                    }, {
                        key: "disableTextTrack",
                        value: function() {
                            return this.callMethod("disableTextTrack")
                        }
                    }, {
                        key: "pause",
                        value: function() {
                            return this.callMethod("pause")
                        }
                    }, {
                        key: "play",
                        value: function() {
                            return this.callMethod("play")
                        }
                    }, {
                        key: "requestFullscreen",
                        value: function() {
                            return N.isEnabled ? N.request(this.element) : this.callMethod("requestFullscreen")
                        }
                    }, {
                        key: "exitFullscreen",
                        value: function() {
                            return N.isEnabled ? N.exit() : this.callMethod("exitFullscreen")
                        }
                    }, {
                        key: "getFullscreen",
                        value: function() {
                            return N.isEnabled ? x.resolve(N.isFullscreen) : this.get("fullscreen")
                        }
                    }, {
                        key: "requestPictureInPicture",
                        value: function() {
                            return this.callMethod("requestPictureInPicture")
                        }
                    }, {
                        key: "exitPictureInPicture",
                        value: function() {
                            return this.callMethod("exitPictureInPicture")
                        }
                    }, {
                        key: "getPictureInPicture",
                        value: function() {
                            return this.get("pictureInPicture")
                        }
                    }, {
                        key: "unload",
                        value: function() {
                            return this.callMethod("unload")
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            var t = this;
                            return new x((function(e) {
                                if (I.delete(t), O.delete(t.element), t._originalElement && (O.delete(t._originalElement), t._originalElement.removeAttribute("data-vimeo-initialized")), t.element && "IFRAME" === t.element.nodeName && t.element.parentNode && (t.element.parentNode.parentNode && t._originalElement && t._originalElement !== t.element.parentNode ? t.element.parentNode.parentNode.removeChild(t.element.parentNode) : t.element.parentNode.removeChild(t.element)), t.element && "DIV" === t.element.nodeName && t.element.parentNode) {
                                    t.element.removeAttribute("data-vimeo-initialized");
                                    var iframe = t.element.querySelector("iframe");
                                    iframe && iframe.parentNode && (iframe.parentNode.parentNode && t._originalElement && t._originalElement !== iframe.parentNode ? iframe.parentNode.parentNode.removeChild(iframe.parentNode) : iframe.parentNode.removeChild(iframe))
                                }
                                t._window.removeEventListener("message", t._onMessage), N.isEnabled && N.off("fullscreenchange", t.fullscreenchangeHandler), e()
                            }))
                        }
                    }, {
                        key: "getAutopause",
                        value: function() {
                            return this.get("autopause")
                        }
                    }, {
                        key: "setAutopause",
                        value: function(t) {
                            return this.set("autopause", t)
                        }
                    }, {
                        key: "getBuffered",
                        value: function() {
                            return this.get("buffered")
                        }
                    }, {
                        key: "getCameraProps",
                        value: function() {
                            return this.get("cameraProps")
                        }
                    }, {
                        key: "setCameraProps",
                        value: function(t) {
                            return this.set("cameraProps", t)
                        }
                    }, {
                        key: "getChapters",
                        value: function() {
                            return this.get("chapters")
                        }
                    }, {
                        key: "getCurrentChapter",
                        value: function() {
                            return this.get("currentChapter")
                        }
                    }, {
                        key: "getColor",
                        value: function() {
                            return this.get("color")
                        }
                    }, {
                        key: "setColor",
                        value: function(t) {
                            return this.set("color", t)
                        }
                    }, {
                        key: "getCuePoints",
                        value: function() {
                            return this.get("cuePoints")
                        }
                    }, {
                        key: "getCurrentTime",
                        value: function() {
                            return this.get("currentTime")
                        }
                    }, {
                        key: "setCurrentTime",
                        value: function(t) {
                            return this.set("currentTime", t)
                        }
                    }, {
                        key: "getDuration",
                        value: function() {
                            return this.get("duration")
                        }
                    }, {
                        key: "getEnded",
                        value: function() {
                            return this.get("ended")
                        }
                    }, {
                        key: "getLoop",
                        value: function() {
                            return this.get("loop")
                        }
                    }, {
                        key: "setLoop",
                        value: function(t) {
                            return this.set("loop", t)
                        }
                    }, {
                        key: "setMuted",
                        value: function(t) {
                            return this.set("muted", t)
                        }
                    }, {
                        key: "getMuted",
                        value: function() {
                            return this.get("muted")
                        }
                    }, {
                        key: "getPaused",
                        value: function() {
                            return this.get("paused")
                        }
                    }, {
                        key: "getPlaybackRate",
                        value: function() {
                            return this.get("playbackRate")
                        }
                    }, {
                        key: "setPlaybackRate",
                        value: function(t) {
                            return this.set("playbackRate", t)
                        }
                    }, {
                        key: "getPlayed",
                        value: function() {
                            return this.get("played")
                        }
                    }, {
                        key: "getQualities",
                        value: function() {
                            return this.get("qualities")
                        }
                    }, {
                        key: "getQuality",
                        value: function() {
                            return this.get("quality")
                        }
                    }, {
                        key: "setQuality",
                        value: function(t) {
                            return this.set("quality", t)
                        }
                    }, {
                        key: "getSeekable",
                        value: function() {
                            return this.get("seekable")
                        }
                    }, {
                        key: "getSeeking",
                        value: function() {
                            return this.get("seeking")
                        }
                    }, {
                        key: "getTextTracks",
                        value: function() {
                            return this.get("textTracks")
                        }
                    }, {
                        key: "getVideoEmbedCode",
                        value: function() {
                            return this.get("videoEmbedCode")
                        }
                    }, {
                        key: "getVideoId",
                        value: function() {
                            return this.get("videoId")
                        }
                    }, {
                        key: "getVideoTitle",
                        value: function() {
                            return this.get("videoTitle")
                        }
                    }, {
                        key: "getVideoWidth",
                        value: function() {
                            return this.get("videoWidth")
                        }
                    }, {
                        key: "getVideoHeight",
                        value: function() {
                            return this.get("videoHeight")
                        }
                    }, {
                        key: "getVideoUrl",
                        value: function() {
                            return this.get("videoUrl")
                        }
                    }, {
                        key: "getVolume",
                        value: function() {
                            return this.get("volume")
                        }
                    }, {
                        key: "setVolume",
                        value: function(t) {
                            return this.set("volume", t)
                        }
                    }], n && o(e.prototype, n), l && o(e, l), t
                }();
            l || (N = function() {
                var t = function() {
                        for (var t, e = [
                                ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
                                ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"],
                                ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"],
                                ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"],
                                ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
                            ], i = 0, n = e.length, r = {}; i < n; i++)
                            if ((t = e[i]) && t[1] in document) {
                                for (i = 0; i < t.length; i++) r[e[0][i]] = t[i];
                                return r
                            }
                        return !1
                    }(),
                    e = {
                        fullscreenchange: t.fullscreenchange,
                        fullscreenerror: t.fullscreenerror
                    },
                    n = {
                        request: function(element) {
                            return new Promise((function(e, r) {
                                var o = function t() {
                                    n.off("fullscreenchange", t), e()
                                };
                                n.on("fullscreenchange", o);
                                var l = (element = element || document.documentElement)[t.requestFullscreen]();
                                l instanceof Promise && l.then(o).catch(r)
                            }))
                        },
                        exit: function() {
                            return new Promise((function(e, r) {
                                if (n.isFullscreen) {
                                    var o = function t() {
                                        n.off("fullscreenchange", t), e()
                                    };
                                    n.on("fullscreenchange", o);
                                    var l = document[t.exitFullscreen]();
                                    l instanceof Promise && l.then(o).catch(r)
                                } else e()
                            }))
                        },
                        on: function(t, n) {
                            var r = e[t];
                            r && document.addEventListener(r, n)
                        },
                        off: function(t, n) {
                            var r = e[t];
                            r && document.removeEventListener(r, n)
                        }
                    };
                return Object.defineProperties(n, {
                    isFullscreen: {
                        get: function() {
                            return Boolean(document[t.fullscreenElement])
                        }
                    },
                    element: {
                        enumerable: !0,
                        get: function() {
                            return document[t.fullscreenElement]
                        }
                    },
                    isEnabled: {
                        enumerable: !0,
                        get: function() {
                            return Boolean(document[t.fullscreenEnabled])
                        }
                    }
                }), n
            }(), function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document,
                    e = [].slice.call(t.querySelectorAll("[data-vimeo-id], [data-vimeo-url]")),
                    n = function(t) {
                        "console" in window && console.error && console.error("There was an error creating an embed: ".concat(t))
                    };
                e.forEach((function(element) {
                    try {
                        if (null !== element.getAttribute("data-vimeo-defer")) return;
                        var t = C(element);
                        k(m(t), t, element).then((function(data) {
                            return L(data, element)
                        })).catch(n)
                    } catch (t) {
                        n(t)
                    }
                }))
            }(), function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document;
                if (!window.VimeoPlayerResizeEmbeds_) {
                    window.VimeoPlayerResizeEmbeds_ = !0;
                    var e = function(e) {
                        if (f(e.origin) && e.data && "spacechange" === e.data.event)
                            for (var n = t.querySelectorAll("iframe"), i = 0; i < n.length; i++)
                                if (n[i].contentWindow === e.source) {
                                    n[i].parentElement.style.paddingBottom = "".concat(e.data.data[0].bottom, "px");
                                    break
                                }
                    };
                    window.addEventListener("message", e)
                }
            }()), e.a = F
        }).call(this, n(51), n(200).setImmediate)
    }, function(t, e, n) {
        "use strict";
        var r = Object.getOwnPropertySymbols,
            o = Object.prototype.hasOwnProperty,
            l = Object.prototype.propertyIsEnumerable;

        function c(t) {
            if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(t)
        }
        t.exports = function() {
            try {
                if (!Object.assign) return !1;
                var t = new String("abc");
                if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1;
                for (var e = {}, i = 0; i < 10; i++) e["_" + String.fromCharCode(i)] = i;
                if ("0123456789" !== Object.getOwnPropertyNames(e).map((function(t) {
                        return e[t]
                    })).join("")) return !1;
                var n = {};
                return "abcdefghijklmnopqrst".split("").forEach((function(t) {
                    n[t] = t
                })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n)).join("")
            } catch (t) {
                return !1
            }
        }() ? Object.assign : function(t, source) {
            for (var e, n, h = c(t), s = 1; s < arguments.length; s++) {
                for (var d in e = Object(arguments[s])) o.call(e, d) && (h[d] = e[d]);
                if (r) {
                    n = r(e);
                    for (var i = 0; i < n.length; i++) l.call(e, n[i]) && (h[n[i]] = e[n[i]])
                }
            }
            return h
        }
    }, function(t, e, n) {
        "use strict";
        (function(t) {
            function n(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }

            function o(t, e, n) {
                return e && r(t.prototype, e), n && r(t, n), t
            }

            function l(t, e, n) {
                return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = n, t
            }

            function c(object, t) {
                var e = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(object);
                    t && (n = n.filter((function(t) {
                        return Object.getOwnPropertyDescriptor(object, t).enumerable
                    }))), e.push.apply(e, n)
                }
                return e
            }

            function h(t) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = null != arguments[i] ? arguments[i] : {};
                    i % 2 ? c(Object(source), !0).forEach((function(e) {
                        l(t, e, source[e])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(source)) : c(Object(source)).forEach((function(e) {
                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(source, e))
                    }))
                }
                return t
            }

            function d(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && m(t, e)
            }

            function f(t) {
                return f = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                }, f(t)
            }

            function m(t, p) {
                return m = Object.setPrototypeOf || function(t, p) {
                    return t.__proto__ = p, t
                }, m(t, p)
            }

            function v(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }

            function y(t, e) {
                return !e || "object" != typeof e && "function" != typeof e ? v(t) : e
            }

            function _(t) {
                var e = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                    } catch (t) {
                        return !1
                    }
                }();
                return function() {
                    var n, r = f(t);
                    if (e) {
                        var o = f(this).constructor;
                        n = Reflect.construct(r, arguments, o)
                    } else n = r.apply(this, arguments);
                    return y(this, n)
                }
            }

            function x(t, e, n) {
                return x = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
                    var base = function(object, t) {
                        for (; !Object.prototype.hasOwnProperty.call(object, t) && null !== (object = f(object)););
                        return object
                    }(t, e);
                    if (base) {
                        var desc = Object.getOwnPropertyDescriptor(base, e);
                        return desc.get ? desc.get.call(n) : desc.value
                    }
                }, x(t, e, n || t)
            }

            function w(t, i) {
                return function(t) {
                    if (Array.isArray(t)) return t
                }(t) || function(t, i) {
                    if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t))) return;
                    var e = [],
                        n = !0,
                        r = !1,
                        o = void 0;
                    try {
                        for (var l, c = t[Symbol.iterator](); !(n = (l = c.next()).done) && (e.push(l.value), !i || e.length !== i); n = !0);
                    } catch (t) {
                        r = !0, o = t
                    } finally {
                        try {
                            n || null == c.return || c.return()
                        } finally {
                            if (r) throw o
                        }
                    }
                    return e
                }(t, i) || S(t, i) || function() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function M(t) {
                return function(t) {
                    if (Array.isArray(t)) return T(t)
                }(t) || function(t) {
                    if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
                }(t) || S(t) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function S(t, e) {
                if (t) {
                    if ("string" == typeof t) return T(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? T(t, e) : void 0
                }
            }

            function T(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
                return n
            }
            var E = {
                    el: document,
                    name: "scroll",
                    offset: [0, 0],
                    repeat: !1,
                    smooth: !1,
                    initPosition: {
                        x: 0,
                        y: 0
                    },
                    direction: "vertical",
                    gestureDirection: "vertical",
                    reloadOnContextChange: !1,
                    lerp: .1,
                    class: "is-inview",
                    scrollbarContainer: !1,
                    scrollbarClass: "c-scrollbar",
                    scrollingClass: "has-scroll-scrolling",
                    draggingClass: "has-scroll-dragging",
                    smoothClass: "has-scroll-smooth",
                    initClass: "has-scroll-init",
                    getSpeed: !1,
                    getDirection: !1,
                    scrollFromAnywhere: !1,
                    multiplier: 1,
                    firefoxMultiplier: 50,
                    touchMultiplier: 2,
                    resetNativeScroll: !0,
                    tablet: {
                        smooth: !1,
                        direction: "vertical",
                        gestureDirection: "vertical",
                        breakpoint: 1024
                    },
                    smartphone: {
                        smooth: !1,
                        direction: "vertical",
                        gestureDirection: "vertical"
                    }
                },
                A = function() {
                    function t() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        n(this, t), Object.assign(this, E, e), this.smartphone = E.smartphone, e.smartphone && Object.assign(this.smartphone, e.smartphone), this.tablet = E.tablet, e.tablet && Object.assign(this.tablet, e.tablet), this.namespace = "locomotive", this.html = document.documentElement, this.windowHeight = window.innerHeight, this.windowWidth = window.innerWidth, this.windowMiddle = {
                            x: this.windowWidth / 2,
                            y: this.windowHeight / 2
                        }, this.els = {}, this.currentElements = {}, this.listeners = {}, this.hasScrollTicking = !1, this.hasCallEventSet = !1, this.checkScroll = this.checkScroll.bind(this), this.checkResize = this.checkResize.bind(this), this.checkEvent = this.checkEvent.bind(this), this.instance = {
                            scroll: {
                                x: 0,
                                y: 0
                            },
                            limit: {
                                x: this.html.offsetWidth,
                                y: this.html.offsetHeight
                            },
                            currentElements: this.currentElements
                        }, this.isMobile ? this.isTablet ? this.context = "tablet" : this.context = "smartphone" : this.context = "desktop", this.isMobile && (this.direction = this[this.context].direction), "horizontal" === this.direction ? this.directionAxis = "x" : this.directionAxis = "y", this.getDirection && (this.instance.direction = null), this.getDirection && (this.instance.speed = 0), this.html.classList.add(this.initClass), window.addEventListener("resize", this.checkResize, !1)
                    }
                    return o(t, [{
                        key: "init",
                        value: function() {
                            this.initEvents()
                        }
                    }, {
                        key: "checkScroll",
                        value: function() {
                            this.dispatchScroll()
                        }
                    }, {
                        key: "checkResize",
                        value: function() {
                            var t = this;
                            this.resizeTick || (this.resizeTick = !0, requestAnimationFrame((function() {
                                t.resize(), t.resizeTick = !1
                            })))
                        }
                    }, {
                        key: "resize",
                        value: function() {}
                    }, {
                        key: "checkContext",
                        value: function() {
                            if (this.reloadOnContextChange) {
                                this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || this.windowWidth < this.tablet.breakpoint, this.isTablet = this.isMobile && this.windowWidth >= this.tablet.breakpoint;
                                var t = this.context;
                                if (this.isMobile ? this.isTablet ? this.context = "tablet" : this.context = "smartphone" : this.context = "desktop", t != this.context)("desktop" == t ? this.smooth : this[t].smooth) != ("desktop" == this.context ? this.smooth : this[this.context].smooth) && window.location.reload()
                            }
                        }
                    }, {
                        key: "initEvents",
                        value: function() {
                            var t = this;
                            this.scrollToEls = this.el.querySelectorAll("[data-".concat(this.name, "-to]")), this.setScrollTo = this.setScrollTo.bind(this), this.scrollToEls.forEach((function(e) {
                                e.addEventListener("click", t.setScrollTo, !1)
                            }))
                        }
                    }, {
                        key: "setScrollTo",
                        value: function(t) {
                            t.preventDefault(), this.scrollTo(t.currentTarget.getAttribute("data-".concat(this.name, "-href")) || t.currentTarget.getAttribute("href"), {
                                offset: t.currentTarget.getAttribute("data-".concat(this.name, "-offset"))
                            })
                        }
                    }, {
                        key: "addElements",
                        value: function() {}
                    }, {
                        key: "detectElements",
                        value: function(t) {
                            var e = this,
                                n = this.instance.scroll.y,
                                r = n + this.windowHeight,
                                o = this.instance.scroll.x,
                                l = o + this.windowWidth;
                            Object.entries(this.els).forEach((function(c) {
                                var h = w(c, 2),
                                    i = h[0],
                                    d = h[1];
                                if (!d || d.inView && !t || ("horizontal" === e.direction ? l >= d.left && o < d.right && e.setInView(d, i) : r >= d.top && n < d.bottom && e.setInView(d, i)), d && d.inView)
                                    if ("horizontal" === e.direction) {
                                        var f = d.right - d.left;
                                        d.progress = (e.instance.scroll.x - (d.left - e.windowWidth)) / (f + e.windowWidth), (l < d.left || o > d.right) && e.setOutOfView(d, i)
                                    } else {
                                        var m = d.bottom - d.top;
                                        d.progress = (e.instance.scroll.y - (d.top - e.windowHeight)) / (m + e.windowHeight), (r < d.top || n > d.bottom) && e.setOutOfView(d, i)
                                    }
                            })), this.hasScrollTicking = !1
                        }
                    }, {
                        key: "setInView",
                        value: function(t, i) {
                            this.els[i].inView = !0, t.el.classList.add(t.class), this.currentElements[i] = t, t.call && this.hasCallEventSet && (this.dispatchCall(t, "enter"), t.repeat || (this.els[i].call = !1))
                        }
                    }, {
                        key: "setOutOfView",
                        value: function(t, i) {
                            var e = this;
                            this.els[i].inView = !1, Object.keys(this.currentElements).forEach((function(t) {
                                t === i && delete e.currentElements[t]
                            })), t.call && this.hasCallEventSet && this.dispatchCall(t, "exit"), t.repeat && t.el.classList.remove(t.class)
                        }
                    }, {
                        key: "dispatchCall",
                        value: function(t, e) {
                            this.callWay = e, this.callValue = t.call.split(",").map((function(t) {
                                return t.trim()
                            })), this.callObj = t, 1 == this.callValue.length && (this.callValue = this.callValue[0]);
                            var n = new Event(this.namespace + "call");
                            this.el.dispatchEvent(n)
                        }
                    }, {
                        key: "dispatchScroll",
                        value: function() {
                            var t = new Event(this.namespace + "scroll");
                            this.el.dispatchEvent(t)
                        }
                    }, {
                        key: "setEvents",
                        value: function(t, e) {
                            this.listeners[t] || (this.listeners[t] = []);
                            var n = this.listeners[t];
                            n.push(e), 1 === n.length && this.el.addEventListener(this.namespace + t, this.checkEvent, !1), "call" === t && (this.hasCallEventSet = !0, this.detectElements(!0))
                        }
                    }, {
                        key: "unsetEvents",
                        value: function(t, e) {
                            if (this.listeners[t]) {
                                var n = this.listeners[t],
                                    r = n.indexOf(e);
                                r < 0 || (n.splice(r, 1), 0 === n.index && this.el.removeEventListener(this.namespace + t, this.checkEvent, !1))
                            }
                        }
                    }, {
                        key: "checkEvent",
                        value: function(t) {
                            var e = this,
                                n = t.type.replace(this.namespace, ""),
                                r = this.listeners[n];
                            r && 0 !== r.length && r.forEach((function(t) {
                                switch (n) {
                                    case "scroll":
                                        return t(e.instance);
                                    case "call":
                                        return t(e.callValue, e.callWay, e.callObj);
                                    default:
                                        return t()
                                }
                            }))
                        }
                    }, {
                        key: "startScroll",
                        value: function() {}
                    }, {
                        key: "stopScroll",
                        value: function() {}
                    }, {
                        key: "setScroll",
                        value: function(t, e) {
                            this.instance.scroll = {
                                x: 0,
                                y: 0
                            }
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            var t = this;
                            window.removeEventListener("resize", this.checkResize, !1), Object.keys(this.listeners).forEach((function(e) {
                                t.el.removeEventListener(t.namespace + e, t.checkEvent, !1)
                            })), this.listeners = {}, this.scrollToEls.forEach((function(e) {
                                e.removeEventListener("click", t.setScrollTo, !1)
                            })), this.html.classList.remove(this.initClass)
                        }
                    }]), t
                }(),
                C = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== t ? t : "undefined" != typeof self ? self : {};

            function L(t, e) {
                return t(e = {
                    exports: {}
                }, e.exports), e.exports
            }
            var k = L((function(t, e) {
                    t.exports = {
                        polyfill: function() {
                            var t = window,
                                e = document;
                            if (!("scrollBehavior" in e.documentElement.style) || !0 === t.__forceSmoothScrollPolyfill__) {
                                var n, r = t.HTMLElement || t.Element,
                                    o = {
                                        scroll: t.scroll || t.scrollTo,
                                        scrollBy: t.scrollBy,
                                        elementScroll: r.prototype.scroll || h,
                                        scrollIntoView: r.prototype.scrollIntoView
                                    },
                                    l = t.performance && t.performance.now ? t.performance.now.bind(t.performance) : Date.now,
                                    c = (n = t.navigator.userAgent, new RegExp(["MSIE ", "Trident/", "Edge/"].join("|")).test(n) ? 1 : 0);
                                t.scroll = t.scrollTo = function() {
                                    void 0 !== arguments[0] && (!0 !== d(arguments[0]) ? x.call(t, e.body, void 0 !== arguments[0].left ? ~~arguments[0].left : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? ~~arguments[0].top : t.scrollY || t.pageYOffset) : o.scroll.call(t, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : t.scrollY || t.pageYOffset))
                                }, t.scrollBy = function() {
                                    void 0 !== arguments[0] && (d(arguments[0]) ? o.scrollBy.call(t, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : 0, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : 0) : x.call(t, e.body, ~~arguments[0].left + (t.scrollX || t.pageXOffset), ~~arguments[0].top + (t.scrollY || t.pageYOffset)))
                                }, r.prototype.scroll = r.prototype.scrollTo = function() {
                                    if (void 0 !== arguments[0])
                                        if (!0 !== d(arguments[0])) {
                                            var t = arguments[0].left,
                                                e = arguments[0].top;
                                            x.call(this, this, void 0 === t ? this.scrollLeft : ~~t, void 0 === e ? this.scrollTop : ~~e)
                                        } else {
                                            if ("number" == typeof arguments[0] && void 0 === arguments[1]) throw new SyntaxError("Value could not be converted");
                                            o.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left : "object" != typeof arguments[0] ? ~~arguments[0] : this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top : void 0 !== arguments[1] ? ~~arguments[1] : this.scrollTop)
                                        }
                                }, r.prototype.scrollBy = function() {
                                    void 0 !== arguments[0] && (!0 !== d(arguments[0]) ? this.scroll({
                                        left: ~~arguments[0].left + this.scrollLeft,
                                        top: ~~arguments[0].top + this.scrollTop,
                                        behavior: arguments[0].behavior
                                    }) : o.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop))
                                }, r.prototype.scrollIntoView = function() {
                                    if (!0 !== d(arguments[0])) {
                                        var n = y(this),
                                            r = n.getBoundingClientRect(),
                                            l = this.getBoundingClientRect();
                                        n !== e.body ? (x.call(this, n, n.scrollLeft + l.left - r.left, n.scrollTop + l.top - r.top), "fixed" !== t.getComputedStyle(n).position && t.scrollBy({
                                            left: r.left,
                                            top: r.top,
                                            behavior: "smooth"
                                        })) : t.scrollBy({
                                            left: l.left,
                                            top: l.top,
                                            behavior: "smooth"
                                        })
                                    } else o.scrollIntoView.call(this, void 0 === arguments[0] || arguments[0])
                                }
                            }

                            function h(t, e) {
                                this.scrollLeft = t, this.scrollTop = e
                            }

                            function d(t) {
                                if (null === t || "object" != typeof t || void 0 === t.behavior || "auto" === t.behavior || "instant" === t.behavior) return !0;
                                if ("object" == typeof t && "smooth" === t.behavior) return !1;
                                throw new TypeError("behavior member of ScrollOptions " + t.behavior + " is not a valid value for enumeration ScrollBehavior.")
                            }

                            function f(t, e) {
                                return "Y" === e ? t.clientHeight + c < t.scrollHeight : "X" === e ? t.clientWidth + c < t.scrollWidth : void 0
                            }

                            function m(e, n) {
                                var r = t.getComputedStyle(e, null)["overflow" + n];
                                return "auto" === r || "scroll" === r
                            }

                            function v(t) {
                                var e = f(t, "Y") && m(t, "Y"),
                                    n = f(t, "X") && m(t, "X");
                                return e || n
                            }

                            function y(t) {
                                for (; t !== e.body && !1 === v(t);) t = t.parentNode || t.host;
                                return t
                            }

                            function _(e) {
                                var n, r, o, c, h = (l() - e.startTime) / 468;
                                c = h = h > 1 ? 1 : h, n = .5 * (1 - Math.cos(Math.PI * c)), r = e.startX + (e.x - e.startX) * n, o = e.startY + (e.y - e.startY) * n, e.method.call(e.scrollable, r, o), r === e.x && o === e.y || t.requestAnimationFrame(_.bind(t, e))
                            }

                            function x(n, r, c) {
                                var d, f, m, v, y = l();
                                n === e.body ? (d = t, f = t.scrollX || t.pageXOffset, m = t.scrollY || t.pageYOffset, v = o.scroll) : (d = n, f = n.scrollLeft, m = n.scrollTop, v = h), _({
                                    scrollable: d,
                                    method: v,
                                    startTime: y,
                                    startX: f,
                                    startY: m,
                                    x: r,
                                    y: c
                                })
                            }
                        }
                    }
                })),
                R = (k.polyfill, function(t) {
                    d(r, t);
                    var e = _(r);

                    function r() {
                        var t, o = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        return n(this, r), (t = e.call(this, o)).resetNativeScroll && (history.scrollRestoration && (history.scrollRestoration = "manual"), window.scrollTo(0, 0)), window.addEventListener("scroll", t.checkScroll, !1), void 0 === window.smoothscrollPolyfill && (window.smoothscrollPolyfill = k, window.smoothscrollPolyfill.polyfill()), t
                    }
                    return o(r, [{
                        key: "init",
                        value: function() {
                            this.instance.scroll.y = window.pageYOffset, this.addElements(), this.detectElements(), x(f(r.prototype), "init", this).call(this)
                        }
                    }, {
                        key: "checkScroll",
                        value: function() {
                            var t = this;
                            x(f(r.prototype), "checkScroll", this).call(this), this.getDirection && this.addDirection(), this.getSpeed && (this.addSpeed(), this.speedTs = Date.now()), this.instance.scroll.y = window.pageYOffset, Object.entries(this.els).length && (this.hasScrollTicking || (requestAnimationFrame((function() {
                                t.detectElements()
                            })), this.hasScrollTicking = !0))
                        }
                    }, {
                        key: "addDirection",
                        value: function() {
                            window.pageYOffset > this.instance.scroll.y ? "down" !== this.instance.direction && (this.instance.direction = "down") : window.pageYOffset < this.instance.scroll.y && "up" !== this.instance.direction && (this.instance.direction = "up")
                        }
                    }, {
                        key: "addSpeed",
                        value: function() {
                            window.pageYOffset != this.instance.scroll.y ? this.instance.speed = (window.pageYOffset - this.instance.scroll.y) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0
                        }
                    }, {
                        key: "resize",
                        value: function() {
                            Object.entries(this.els).length && (this.windowHeight = window.innerHeight, this.updateElements())
                        }
                    }, {
                        key: "addElements",
                        value: function() {
                            var t = this;
                            this.els = {}, this.el.querySelectorAll("[data-" + this.name + "]").forEach((function(e, n) {
                                e.getBoundingClientRect();
                                var r, o, l, c = e.dataset[t.name + "Class"] || t.class,
                                    h = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : n,
                                    d = "string" == typeof e.dataset[t.name + "Offset"] ? e.dataset[t.name + "Offset"].split(",") : t.offset,
                                    f = e.dataset[t.name + "Repeat"],
                                    m = e.dataset[t.name + "Call"],
                                    v = e.dataset[t.name + "Target"],
                                    y = (l = void 0 !== v ? document.querySelector("".concat(v)) : e).getBoundingClientRect();
                                r = y.top + t.instance.scroll.y, o = y.left + t.instance.scroll.x;
                                var _ = r + l.offsetHeight,
                                    x = o + l.offsetWidth;
                                f = "false" != f && (null != f || t.repeat);
                                var w = t.getRelativeOffset(d),
                                    M = {
                                        el: e,
                                        targetEl: l,
                                        id: h,
                                        class: c,
                                        top: r += w[0],
                                        bottom: _ -= w[1],
                                        left: o,
                                        right: x,
                                        offset: d,
                                        progress: 0,
                                        repeat: f,
                                        inView: !1,
                                        call: m
                                    };
                                t.els[h] = M, e.classList.contains(c) && t.setInView(t.els[h], h)
                            }))
                        }
                    }, {
                        key: "updateElements",
                        value: function() {
                            var t = this;
                            Object.entries(this.els).forEach((function(e) {
                                var n = w(e, 2),
                                    i = n[0],
                                    r = n[1],
                                    o = r.targetEl.getBoundingClientRect().top + t.instance.scroll.y,
                                    l = o + r.targetEl.offsetHeight,
                                    c = t.getRelativeOffset(r.offset);
                                t.els[i].top = o + c[0], t.els[i].bottom = l - c[1]
                            })), this.hasScrollTicking = !1
                        }
                    }, {
                        key: "getRelativeOffset",
                        value: function(t) {
                            var e = [0, 0];
                            if (t)
                                for (var i = 0; i < t.length; i++) "string" == typeof t[i] ? t[i].includes("%") ? e[i] = parseInt(t[i].replace("%", "") * this.windowHeight / 100) : e[i] = parseInt(t[i]) : e[i] = t[i];
                            return e
                        }
                    }, {
                        key: "scrollTo",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                                n = parseInt(e.offset) || 0,
                                r = !!e.callback && e.callback;
                            if ("string" == typeof t) {
                                if ("top" === t) t = this.html;
                                else if ("bottom" === t) t = this.html.offsetHeight - window.innerHeight;
                                else if (!(t = document.querySelector(t))) return
                            } else if ("number" == typeof t) t = parseInt(t);
                            else if (!t || !t.tagName) return void console.warn("`target` parameter is not valid");
                            n = "number" != typeof t ? t.getBoundingClientRect().top + n + this.instance.scroll.y : t + n;
                            var o = function() {
                                return parseInt(window.pageYOffset) === parseInt(n)
                            };
                            if (r) {
                                if (o()) return void r();
                                var l = function t() {
                                    o() && (window.removeEventListener("scroll", t), r())
                                };
                                window.addEventListener("scroll", l)
                            }
                            window.scrollTo({
                                top: n,
                                behavior: "smooth"
                            })
                        }
                    }, {
                        key: "update",
                        value: function() {
                            this.addElements(), this.detectElements()
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            x(f(r.prototype), "destroy", this).call(this), window.removeEventListener("scroll", this.checkScroll, !1)
                        }
                    }]), r
                }(A)),
                P = Object.getOwnPropertySymbols,
                D = Object.prototype.hasOwnProperty,
                O = Object.prototype.propertyIsEnumerable;

            function I(t) {
                if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined");
                return Object(t)
            }
            var N = function() {
                try {
                    if (!Object.assign) return !1;
                    var t = new String("abc");
                    if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1;
                    for (var e = {}, i = 0; i < 10; i++) e["_" + String.fromCharCode(i)] = i;
                    if ("0123456789" !== Object.getOwnPropertyNames(e).map((function(t) {
                            return e[t]
                        })).join("")) return !1;
                    var n = {};
                    return "abcdefghijklmnopqrst".split("").forEach((function(t) {
                        n[t] = t
                    })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n)).join("")
                } catch (t) {
                    return !1
                }
            }() ? Object.assign : function(t, source) {
                for (var e, n, r = I(t), s = 1; s < arguments.length; s++) {
                    for (var o in e = Object(arguments[s])) D.call(e, o) && (r[o] = e[o]);
                    if (P) {
                        n = P(e);
                        for (var i = 0; i < n.length; i++) O.call(e, n[i]) && (r[n[i]] = e[n[i]])
                    }
                }
                return r
            };

            function F() {}
            F.prototype = {
                on: function(t, e, n) {
                    var r = this.e || (this.e = {});
                    return (r[t] || (r[t] = [])).push({
                        fn: e,
                        ctx: n
                    }), this
                },
                once: function(t, e, n) {
                    var r = this;

                    function o() {
                        r.off(t, o), e.apply(n, arguments)
                    }
                    return o._ = e, this.on(t, o, n)
                },
                emit: function(t) {
                    for (var data = [].slice.call(arguments, 1), e = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, n = e.length; i < n; i++) e[i].fn.apply(e[i].ctx, data);
                    return this
                },
                off: function(t, e) {
                    var n = this.e || (this.e = {}),
                        r = n[t],
                        o = [];
                    if (r && e)
                        for (var i = 0, l = r.length; i < l; i++) r[i].fn !== e && r[i].fn._ !== e && o.push(r[i]);
                    return o.length ? n[t] = o : delete n[t], this
                }
            };
            var z = F,
                B = L((function(t, e) {
                    (function() {
                        (null !== e ? e : this).Lethargy = function() {
                            function t(t, e, n, r) {
                                this.stability = null != t ? Math.abs(t) : 8, this.sensitivity = null != e ? 1 + Math.abs(e) : 100, this.tolerance = null != n ? 1 + Math.abs(n) : 1.1, this.delay = null != r ? r : 150, this.lastUpDeltas = function() {
                                    var i, t, e;
                                    for (e = [], i = 1, t = 2 * this.stability; 1 <= t ? i <= t : i >= t; 1 <= t ? i++ : i--) e.push(null);
                                    return e
                                }.call(this), this.lastDownDeltas = function() {
                                    var i, t, e;
                                    for (e = [], i = 1, t = 2 * this.stability; 1 <= t ? i <= t : i >= t; 1 <= t ? i++ : i--) e.push(null);
                                    return e
                                }.call(this), this.deltasTimestamp = function() {
                                    var i, t, e;
                                    for (e = [], i = 1, t = 2 * this.stability; 1 <= t ? i <= t : i >= t; 1 <= t ? i++ : i--) e.push(null);
                                    return e
                                }.call(this)
                            }
                            return t.prototype.check = function(t) {
                                var e;
                                return null != (t = t.originalEvent || t).wheelDelta ? e = t.wheelDelta : null != t.deltaY ? e = -40 * t.deltaY : null == t.detail && 0 !== t.detail || (e = -40 * t.detail), this.deltasTimestamp.push(Date.now()), this.deltasTimestamp.shift(), e > 0 ? (this.lastUpDeltas.push(e), this.lastUpDeltas.shift(), this.isInertia(1)) : (this.lastDownDeltas.push(e), this.lastDownDeltas.shift(), this.isInertia(-1))
                            }, t.prototype.isInertia = function(t) {
                                var e, n, r, o, l, c, h;
                                return null === (e = -1 === t ? this.lastDownDeltas : this.lastUpDeltas)[0] ? t : !(this.deltasTimestamp[2 * this.stability - 2] + this.delay > Date.now() && e[0] === e[2 * this.stability - 1]) && (r = e.slice(0, this.stability), n = e.slice(this.stability, 2 * this.stability), h = r.reduce((function(t, s) {
                                    return t + s
                                })), l = n.reduce((function(t, s) {
                                    return t + s
                                })), c = h / r.length, o = l / n.length, Math.abs(c) < Math.abs(o * this.tolerance) && this.sensitivity < Math.abs(o) && t)
                            }, t.prototype.showLastUpDeltas = function() {
                                return this.lastUpDeltas
                            }, t.prototype.showLastDownDeltas = function() {
                                return this.lastDownDeltas
                            }, t
                        }()
                    }).call(C)
                })),
                U = {
                    hasWheelEvent: "onwheel" in document,
                    hasMouseWheelEvent: "onmousewheel" in document,
                    hasTouch: "ontouchstart" in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,
                    hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
                    hasPointer: !!window.navigator.msPointerEnabled,
                    hasKeyDown: "onkeydown" in document,
                    isFirefox: navigator.userAgent.indexOf("Firefox") > -1
                },
                H = Object.prototype.toString,
                j = Object.prototype.hasOwnProperty;

            function V(t, e) {
                return function() {
                    return t.apply(e, arguments)
                }
            }
            var G = B.Lethargy,
                W = "virtualscroll",
                X = Q,
                $ = 37,
                Y = 38,
                Z = 39,
                J = 40,
                K = 32;

            function Q(t) {
                ! function(object) {
                    if (!object) return console.warn("bindAll requires at least one argument.");
                    var t = Array.prototype.slice.call(arguments, 1);
                    if (0 === t.length)
                        for (var e in object) j.call(object, e) && "function" == typeof object[e] && "[object Function]" == H.call(object[e]) && t.push(e);
                    for (var i = 0; i < t.length; i++) {
                        var n = t[i];
                        object[n] = V(object[n], object)
                    }
                }(this, "_onWheel", "_onMouseWheel", "_onTouchStart", "_onTouchMove", "_onKeyDown"), this.el = window, t && t.el && (this.el = t.el, delete t.el), this.options = N({
                    mouseMultiplier: 1,
                    touchMultiplier: 2,
                    firefoxMultiplier: 15,
                    keyStep: 120,
                    preventTouch: !1,
                    unpreventTouchClass: "vs-touchmove-allowed",
                    limitInertia: !1,
                    useKeyboard: !0,
                    useTouch: !0
                }, t), this.options.limitInertia && (this._lethargy = new G), this._emitter = new z, this._event = {
                    y: 0,
                    x: 0,
                    deltaX: 0,
                    deltaY: 0
                }, this.touchStartX = null, this.touchStartY = null, this.bodyTouchAction = null, void 0 !== this.options.passive && (this.listenerOptions = {
                    passive: this.options.passive
                })
            }

            function tt(t, e, n) {
                return (1 - n) * t + n * e
            }

            function et(t) {
                var e = {};
                if (window.getComputedStyle) {
                    var style = getComputedStyle(t),
                        n = style.transform || style.webkitTransform || style.mozTransform,
                        r = n.match(/^matrix3d\((.+)\)$/);
                    return r ? (e.x = r ? parseFloat(r[1].split(", ")[12]) : 0, e.y = r ? parseFloat(r[1].split(", ")[13]) : 0) : (r = n.match(/^matrix\((.+)\)$/), e.x = r ? parseFloat(r[1].split(", ")[4]) : 0, e.y = r ? parseFloat(r[1].split(", ")[5]) : 0), e
                }
            }

            function nt(t) {
                for (var e = []; t && t !== document; t = t.parentNode) e.push(t);
                return e
            }
            Q.prototype._notify = function(t) {
                var e = this._event;
                e.x += e.deltaX, e.y += e.deltaY, this._emitter.emit(W, {
                    x: e.x,
                    y: e.y,
                    deltaX: e.deltaX,
                    deltaY: e.deltaY,
                    originalEvent: t
                })
            }, Q.prototype._onWheel = function(t) {
                var e = this.options;
                if (!this._lethargy || !1 !== this._lethargy.check(t)) {
                    var n = this._event;
                    n.deltaX = t.wheelDeltaX || -1 * t.deltaX, n.deltaY = t.wheelDeltaY || -1 * t.deltaY, U.isFirefox && 1 == t.deltaMode && (n.deltaX *= e.firefoxMultiplier, n.deltaY *= e.firefoxMultiplier), n.deltaX *= e.mouseMultiplier, n.deltaY *= e.mouseMultiplier, this._notify(t)
                }
            }, Q.prototype._onMouseWheel = function(t) {
                if (!this.options.limitInertia || !1 !== this._lethargy.check(t)) {
                    var e = this._event;
                    e.deltaX = t.wheelDeltaX ? t.wheelDeltaX : 0, e.deltaY = t.wheelDeltaY ? t.wheelDeltaY : t.wheelDelta, this._notify(t)
                }
            }, Q.prototype._onTouchStart = function(t) {
                var e = t.targetTouches ? t.targetTouches[0] : t;
                this.touchStartX = e.pageX, this.touchStartY = e.pageY
            }, Q.prototype._onTouchMove = function(t) {
                var e = this.options;
                e.preventTouch && !t.target.classList.contains(e.unpreventTouchClass) && t.preventDefault();
                var n = this._event,
                    r = t.targetTouches ? t.targetTouches[0] : t;
                n.deltaX = (r.pageX - this.touchStartX) * e.touchMultiplier, n.deltaY = (r.pageY - this.touchStartY) * e.touchMultiplier, this.touchStartX = r.pageX, this.touchStartY = r.pageY, this._notify(t)
            }, Q.prototype._onKeyDown = function(t) {
                var e = this._event;
                e.deltaX = e.deltaY = 0;
                var n = window.innerHeight - 40;
                switch (t.keyCode) {
                    case $:
                    case Y:
                        e.deltaY = this.options.keyStep;
                        break;
                    case Z:
                    case J:
                        e.deltaY = -this.options.keyStep;
                        break;
                    case t.shiftKey:
                        e.deltaY = n;
                        break;
                    case K:
                        e.deltaY = -n;
                        break;
                    default:
                        return
                }
                this._notify(t)
            }, Q.prototype._bind = function() {
                U.hasWheelEvent && this.el.addEventListener("wheel", this._onWheel, this.listenerOptions), U.hasMouseWheelEvent && this.el.addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions), U.hasTouch && this.options.useTouch && (this.el.addEventListener("touchstart", this._onTouchStart, this.listenerOptions), this.el.addEventListener("touchmove", this._onTouchMove, this.listenerOptions)), U.hasPointer && U.hasTouchWin && (this.bodyTouchAction = document.body.style.msTouchAction, document.body.style.msTouchAction = "none", this.el.addEventListener("MSPointerDown", this._onTouchStart, !0), this.el.addEventListener("MSPointerMove", this._onTouchMove, !0)), U.hasKeyDown && this.options.useKeyboard && document.addEventListener("keydown", this._onKeyDown)
            }, Q.prototype._unbind = function() {
                U.hasWheelEvent && this.el.removeEventListener("wheel", this._onWheel), U.hasMouseWheelEvent && this.el.removeEventListener("mousewheel", this._onMouseWheel), U.hasTouch && (this.el.removeEventListener("touchstart", this._onTouchStart), this.el.removeEventListener("touchmove", this._onTouchMove)), U.hasPointer && U.hasTouchWin && (document.body.style.msTouchAction = this.bodyTouchAction, this.el.removeEventListener("MSPointerDown", this._onTouchStart, !0), this.el.removeEventListener("MSPointerMove", this._onTouchMove, !0)), U.hasKeyDown && this.options.useKeyboard && document.removeEventListener("keydown", this._onKeyDown)
            }, Q.prototype.on = function(t, e) {
                this._emitter.on(W, t, e);
                var n = this._emitter.e;
                n && n[W] && 1 === n[W].length && this._bind()
            }, Q.prototype.off = function(t, e) {
                this._emitter.off(W, t, e);
                var n = this._emitter.e;
                (!n[W] || n[W].length <= 0) && this._unbind()
            }, Q.prototype.reset = function() {
                var t = this._event;
                t.x = 0, t.y = 0
            }, Q.prototype.destroy = function() {
                this._emitter.off(), this._unbind()
            };
            var it = .1,
                ot = "function" == typeof Float32Array;

            function at(t, e) {
                return 1 - 3 * e + 3 * t
            }

            function st(t, e) {
                return 3 * e - 6 * t
            }

            function lt(t) {
                return 3 * t
            }

            function ct(t, e, n) {
                return ((at(e, n) * t + st(e, n)) * t + lt(e)) * t
            }

            function ut(t, e, n) {
                return 3 * at(e, n) * t * t + 2 * st(e, n) * t + lt(e)
            }

            function ht(t) {
                return t
            }
            var pt = function(t, e, n, r) {
                    if (!(0 <= t && t <= 1 && 0 <= n && n <= 1)) throw new Error("bezier x values must be in [0, 1] range");
                    if (t === e && n === r) return ht;
                    for (var o = ot ? new Float32Array(11) : new Array(11), i = 0; i < 11; ++i) o[i] = ct(i * it, t, n);

                    function l(e) {
                        for (var r = 0, l = 1; 10 !== l && o[l] <= e; ++l) r += it;
                        --l;
                        var c = r + (e - o[l]) / (o[l + 1] - o[l]) * it,
                            h = ut(c, t, n);
                        return h >= .001 ? function(t, e, n, r) {
                            for (var i = 0; i < 4; ++i) {
                                var o = ut(e, n, r);
                                if (0 === o) return e;
                                e -= (ct(e, n, r) - t) / o
                            }
                            return e
                        }(e, c, t, n) : 0 === h ? c : function(t, e, n, r, o) {
                            var l, c, i = 0;
                            do {
                                (l = ct(c = e + (n - e) / 2, r, o) - t) > 0 ? n = c : e = c
                            } while (Math.abs(l) > 1e-7 && ++i < 10);
                            return c
                        }(e, r, r + it, t, n)
                    }
                    return function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : ct(l(t), e, r)
                    }
                },
                ft = 38,
                mt = 40,
                gt = 32,
                vt = 9,
                yt = 33,
                _t = 34,
                xt = 36,
                bt = 35,
                wt = function(t) {
                    d(r, t);
                    var e = _(r);

                    function r() {
                        var t, o = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        return n(this, r), history.scrollRestoration && (history.scrollRestoration = "manual"), window.scrollTo(0, 0), (t = e.call(this, o)).inertia && (t.lerp = .1 * t.inertia), t.isScrolling = !1, t.isDraggingScrollbar = !1, t.isTicking = !1, t.hasScrollTicking = !1, t.parallaxElements = {}, t.stop = !1, t.scrollbarContainer = o.scrollbarContainer, t.checkKey = t.checkKey.bind(v(t)), window.addEventListener("keydown", t.checkKey, !1), t
                    }
                    return o(r, [{
                        key: "init",
                        value: function() {
                            var t = this;
                            this.html.classList.add(this.smoothClass), this.html.setAttribute("data-".concat(this.name, "-direction"), this.direction), this.instance = h({
                                delta: {
                                    x: this.initPosition.x,
                                    y: this.initPosition.y
                                },
                                scroll: {
                                    x: this.initPosition.x,
                                    y: this.initPosition.y
                                }
                            }, this.instance), this.vs = new X({
                                el: this.scrollFromAnywhere ? document : this.el,
                                mouseMultiplier: navigator.platform.indexOf("Win") > -1 ? 1 : .4,
                                firefoxMultiplier: this.firefoxMultiplier,
                                touchMultiplier: this.touchMultiplier,
                                useKeyboard: !1,
                                passive: !0
                            }), this.vs.on((function(e) {
                                t.stop || t.isDraggingScrollbar || requestAnimationFrame((function() {
                                    t.updateDelta(e), t.isScrolling || t.startScrolling()
                                }))
                            })), this.setScrollLimit(), this.initScrollBar(), this.addSections(), this.addElements(), this.checkScroll(!0), this.transformElements(!0, !0), x(f(r.prototype), "init", this).call(this)
                        }
                    }, {
                        key: "setScrollLimit",
                        value: function() {
                            if (this.instance.limit.y = this.el.offsetHeight - this.windowHeight, "horizontal" === this.direction) {
                                for (var t = 0, e = this.el.children, i = 0; i < e.length; i++) t += e[i].offsetWidth;
                                this.instance.limit.x = t - this.windowWidth
                            }
                        }
                    }, {
                        key: "startScrolling",
                        value: function() {
                            this.startScrollTs = Date.now(), this.isScrolling = !0, this.checkScroll(), this.html.classList.add(this.scrollingClass)
                        }
                    }, {
                        key: "stopScrolling",
                        value: function() {
                            cancelAnimationFrame(this.checkScrollRaf), this.scrollToRaf && (cancelAnimationFrame(this.scrollToRaf), this.scrollToRaf = null), this.isScrolling = !1, this.instance.scroll.y = Math.round(this.instance.scroll.y), this.html.classList.remove(this.scrollingClass)
                        }
                    }, {
                        key: "checkKey",
                        value: function(t) {
                            var e = this;
                            if (this.stop) t.keyCode == vt && requestAnimationFrame((function() {
                                e.html.scrollTop = 0, document.body.scrollTop = 0, e.html.scrollLeft = 0, document.body.scrollLeft = 0
                            }));
                            else {
                                switch (t.keyCode) {
                                    case vt:
                                        requestAnimationFrame((function() {
                                            e.html.scrollTop = 0, document.body.scrollTop = 0, e.html.scrollLeft = 0, document.body.scrollLeft = 0, e.scrollTo(document.activeElement, {
                                                offset: -window.innerHeight / 2
                                            })
                                        }));
                                        break;
                                    case ft:
                                        this.instance.delta[this.directionAxis] -= 240;
                                        break;
                                    case mt:
                                        this.instance.delta[this.directionAxis] += 240;
                                        break;
                                    case yt:
                                        this.instance.delta[this.directionAxis] -= window.innerHeight;
                                        break;
                                    case _t:
                                        this.instance.delta[this.directionAxis] += window.innerHeight;
                                        break;
                                    case xt:
                                        this.instance.delta[this.directionAxis] -= this.instance.limit[this.directionAxis];
                                        break;
                                    case bt:
                                        this.instance.delta[this.directionAxis] += this.instance.limit[this.directionAxis];
                                        break;
                                    case gt:
                                        document.activeElement instanceof HTMLInputElement || document.activeElement instanceof HTMLTextAreaElement || (t.shiftKey ? this.instance.delta[this.directionAxis] -= window.innerHeight : this.instance.delta[this.directionAxis] += window.innerHeight);
                                        break;
                                    default:
                                        return
                                }
                                this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0), this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis]), this.stopScrolling(), this.isScrolling = !0, this.checkScroll(), this.html.classList.add(this.scrollingClass)
                            }
                        }
                    }, {
                        key: "checkScroll",
                        value: function() {
                            var t = this,
                                e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                            if (e || this.isScrolling || this.isDraggingScrollbar) {
                                this.hasScrollTicking || (this.checkScrollRaf = requestAnimationFrame((function() {
                                    return t.checkScroll()
                                })), this.hasScrollTicking = !0), this.updateScroll();
                                var n = Math.abs(this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]),
                                    o = Date.now() - this.startScrollTs;
                                if (!this.animatingScroll && o > 100 && (n < .5 && 0 != this.instance.delta[this.directionAxis] || n < .5 && 0 == this.instance.delta[this.directionAxis]) && this.stopScrolling(), Object.entries(this.sections).forEach((function(n) {
                                        var r = w(n, 2),
                                            section = (r[0], r[1]);
                                        section.persistent || t.instance.scroll[t.directionAxis] > section.offset[t.directionAxis] && t.instance.scroll[t.directionAxis] < section.limit[t.directionAxis] ? ("horizontal" === t.direction ? t.transform(section.el, -t.instance.scroll[t.directionAxis], 0) : t.transform(section.el, 0, -t.instance.scroll[t.directionAxis]), section.inView || (section.inView = !0, section.el.style.opacity = 1, section.el.style.pointerEvents = "all", section.el.setAttribute("data-".concat(t.name, "-section-inview"), ""))) : ((section.inView || e) && (section.inView = !1, section.el.style.opacity = 0, section.el.style.pointerEvents = "none", section.el.removeAttribute("data-".concat(t.name, "-section-inview"))), t.transform(section.el, 0, 0))
                                    })), this.getDirection && this.addDirection(), this.getSpeed && (this.addSpeed(), this.speedTs = Date.now()), this.detectElements(), this.transformElements(), this.hasScrollbar) {
                                    var l = this.instance.scroll[this.directionAxis] / this.instance.limit[this.directionAxis] * this.scrollBarLimit[this.directionAxis];
                                    "horizontal" === this.direction ? this.transform(this.scrollbarThumb, l, 0) : this.transform(this.scrollbarThumb, 0, l)
                                }
                                x(f(r.prototype), "checkScroll", this).call(this), this.hasScrollTicking = !1
                            }
                        }
                    }, {
                        key: "resize",
                        value: function() {
                            this.windowHeight = window.innerHeight, this.windowWidth = window.innerWidth, this.checkContext(), this.windowMiddle = {
                                x: this.windowWidth / 2,
                                y: this.windowHeight / 2
                            }, this.update()
                        }
                    }, {
                        key: "updateDelta",
                        value: function(t) {
                            var e, n = this[this.context] && this[this.context].gestureDirection ? this[this.context].gestureDirection : this.gestureDirection;
                            e = "both" === n ? t.deltaX + t.deltaY : "vertical" === n ? t.deltaY : "horizontal" === n ? t.deltaX : t.deltaY, this.instance.delta[this.directionAxis] -= e * this.multiplier, this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0), this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis])
                        }
                    }, {
                        key: "updateScroll",
                        value: function(t) {
                            this.isScrolling || this.isDraggingScrollbar ? this.instance.scroll[this.directionAxis] = tt(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis], this.lerp) : this.instance.scroll[this.directionAxis] > this.instance.limit[this.directionAxis] ? this.setScroll(this.instance.scroll[this.directionAxis], this.instance.limit[this.directionAxis]) : this.instance.scroll.y < 0 ? this.setScroll(this.instance.scroll[this.directionAxis], 0) : this.setScroll(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis])
                        }
                    }, {
                        key: "addDirection",
                        value: function() {
                            this.instance.delta.y > this.instance.scroll.y ? "down" !== this.instance.direction && (this.instance.direction = "down") : this.instance.delta.y < this.instance.scroll.y && "up" !== this.instance.direction && (this.instance.direction = "up"), this.instance.delta.x > this.instance.scroll.x ? "right" !== this.instance.direction && (this.instance.direction = "right") : this.instance.delta.x < this.instance.scroll.x && "left" !== this.instance.direction && (this.instance.direction = "left")
                        }
                    }, {
                        key: "addSpeed",
                        value: function() {
                            this.instance.delta[this.directionAxis] != this.instance.scroll[this.directionAxis] ? this.instance.speed = (this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0
                        }
                    }, {
                        key: "initScrollBar",
                        value: function() {
                            if (this.scrollbar = document.createElement("span"), this.scrollbarThumb = document.createElement("span"), this.scrollbar.classList.add("".concat(this.scrollbarClass)), this.scrollbarThumb.classList.add("".concat(this.scrollbarClass, "_thumb")), this.scrollbar.append(this.scrollbarThumb), this.scrollbarContainer ? this.scrollbarContainer.append(this.scrollbar) : document.body.append(this.scrollbar), this.getScrollBar = this.getScrollBar.bind(this), this.releaseScrollBar = this.releaseScrollBar.bind(this), this.moveScrollBar = this.moveScrollBar.bind(this), this.scrollbarThumb.addEventListener("mousedown", this.getScrollBar), window.addEventListener("mouseup", this.releaseScrollBar), window.addEventListener("mousemove", this.moveScrollBar), this.hasScrollbar = !1, "horizontal" == this.direction) {
                                if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return
                            } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return;
                            this.hasScrollbar = !0, this.scrollbarBCR = this.scrollbar.getBoundingClientRect(), this.scrollbarHeight = this.scrollbarBCR.height, this.scrollbarWidth = this.scrollbarBCR.width, "horizontal" === this.direction ? this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px") : this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px"), this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(), this.scrollBarLimit = {
                                x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                                y: this.scrollbarHeight - this.scrollbarThumbBCR.height
                            }
                        }
                    }, {
                        key: "reinitScrollBar",
                        value: function() {
                            if (this.hasScrollbar = !1, "horizontal" == this.direction) {
                                if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return
                            } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return;
                            this.hasScrollbar = !0, this.scrollbarBCR = this.scrollbar.getBoundingClientRect(), this.scrollbarHeight = this.scrollbarBCR.height, this.scrollbarWidth = this.scrollbarBCR.width, "horizontal" === this.direction ? this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px") : this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px"), this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(), this.scrollBarLimit = {
                                x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                                y: this.scrollbarHeight - this.scrollbarThumbBCR.height
                            }
                        }
                    }, {
                        key: "destroyScrollBar",
                        value: function() {
                            this.scrollbarThumb.removeEventListener("mousedown", this.getScrollBar), window.removeEventListener("mouseup", this.releaseScrollBar), window.removeEventListener("mousemove", this.moveScrollBar), this.scrollbar.remove()
                        }
                    }, {
                        key: "getScrollBar",
                        value: function(t) {
                            this.isDraggingScrollbar = !0, this.checkScroll(), this.html.classList.remove(this.scrollingClass), this.html.classList.add(this.draggingClass)
                        }
                    }, {
                        key: "releaseScrollBar",
                        value: function(t) {
                            this.isDraggingScrollbar = !1, this.html.classList.add(this.scrollingClass), this.html.classList.remove(this.draggingClass)
                        }
                    }, {
                        key: "moveScrollBar",
                        value: function(t) {
                            var e = this;
                            this.isDraggingScrollbar && requestAnimationFrame((function() {
                                var n = 100 * (t.clientX - e.scrollbarBCR.left) / e.scrollbarWidth * e.instance.limit.x / 100,
                                    r = 100 * (t.clientY - e.scrollbarBCR.top) / e.scrollbarHeight * e.instance.limit.y / 100;
                                r > 0 && r < e.instance.limit.y && (e.instance.delta.y = r), n > 0 && n < e.instance.limit.x && (e.instance.delta.x = n)
                            }))
                        }
                    }, {
                        key: "addElements",
                        value: function() {
                            var t = this;
                            this.els = {}, this.parallaxElements = {}, this.el.querySelectorAll("[data-".concat(this.name, "]")).forEach((function(e, n) {
                                var r, o, l, c = nt(e),
                                    section = Object.entries(t.sections).map((function(t) {
                                        var e = w(t, 2);
                                        e[0];
                                        return e[1]
                                    })).find((function(section) {
                                        return c.includes(section.el)
                                    })),
                                    h = e.dataset[t.name + "Class"] || t.class,
                                    d = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : "el" + n,
                                    f = e.dataset[t.name + "Repeat"],
                                    m = e.dataset[t.name + "Call"],
                                    v = e.dataset[t.name + "Position"],
                                    y = e.dataset[t.name + "Delay"],
                                    _ = e.dataset[t.name + "Direction"],
                                    x = "string" == typeof e.dataset[t.name + "Sticky"],
                                    M = !!e.dataset[t.name + "Speed"] && parseFloat(e.dataset[t.name + "Speed"]) / 10,
                                    S = "string" == typeof e.dataset[t.name + "Offset"] ? e.dataset[t.name + "Offset"].split(",") : t.offset,
                                    T = e.dataset[t.name + "Target"],
                                    E = (l = void 0 !== T ? document.querySelector("".concat(T)) : e).getBoundingClientRect();
                                null === section || section.inView ? (r = E.top + t.instance.scroll.y - et(l).y, o = E.left + t.instance.scroll.x - et(l).x) : (r = E.top - et(section.el).y - et(l).y, o = E.left - et(section.el).x - et(l).x);
                                var A = r + l.offsetHeight,
                                    C = o + l.offsetWidth,
                                    L = {
                                        x: (C - o) / 2 + o,
                                        y: (A - r) / 2 + r
                                    };
                                if (x) {
                                    var k = e.getBoundingClientRect(),
                                        R = k.top,
                                        P = k.left,
                                        D = {
                                            x: P - o,
                                            y: R - r
                                        };
                                    r += window.innerHeight, o += window.innerWidth, A = R + l.offsetHeight - e.offsetHeight - D[t.directionAxis], L = {
                                        x: ((C = P + l.offsetWidth - e.offsetWidth - D[t.directionAxis]) - o) / 2 + o,
                                        y: (A - r) / 2 + r
                                    }
                                }
                                f = "false" != f && (null != f || t.repeat);
                                var O = [0, 0];
                                if (S)
                                    if ("horizontal" === t.direction) {
                                        for (var i = 0; i < S.length; i++) "string" == typeof S[i] ? S[i].includes("%") ? O[i] = parseInt(S[i].replace("%", "") * t.windowWidth / 100) : O[i] = parseInt(S[i]) : O[i] = S[i];
                                        o += O[0], C -= O[1]
                                    } else {
                                        for (i = 0; i < S.length; i++) "string" == typeof S[i] ? S[i].includes("%") ? O[i] = parseInt(S[i].replace("%", "") * t.windowHeight / 100) : O[i] = parseInt(S[i]) : O[i] = S[i];
                                        r += O[0], A -= O[1]
                                    }
                                var I = {
                                    el: e,
                                    id: d,
                                    class: h,
                                    section: section,
                                    top: r,
                                    middle: L,
                                    bottom: A,
                                    left: o,
                                    right: C,
                                    offset: S,
                                    progress: 0,
                                    repeat: f,
                                    inView: !1,
                                    call: m,
                                    speed: M,
                                    delay: y,
                                    position: v,
                                    target: l,
                                    direction: _,
                                    sticky: x
                                };
                                t.els[d] = I, e.classList.contains(h) && t.setInView(t.els[d], d), (!1 !== M || x) && (t.parallaxElements[d] = I)
                            }))
                        }
                    }, {
                        key: "addSections",
                        value: function() {
                            var t = this;
                            this.sections = {};
                            var e = this.el.querySelectorAll("[data-".concat(this.name, "-section]"));
                            0 === e.length && (e = [this.el]), e.forEach((function(section, e) {
                                var n = "string" == typeof section.dataset[t.name + "Id"] ? section.dataset[t.name + "Id"] : "section" + e,
                                    r = section.getBoundingClientRect(),
                                    o = {
                                        x: r.left - 1.5 * window.innerWidth - et(section).x,
                                        y: r.top - 1.5 * window.innerHeight - et(section).y
                                    },
                                    l = {
                                        x: o.x + r.width + 2 * window.innerWidth,
                                        y: o.y + r.height + 2 * window.innerHeight
                                    },
                                    c = "string" == typeof section.dataset[t.name + "Persistent"];
                                section.setAttribute("data-scroll-section-id", n);
                                var h = {
                                    el: section,
                                    offset: o,
                                    limit: l,
                                    inView: !1,
                                    persistent: c,
                                    id: n
                                };
                                t.sections[n] = h
                            }))
                        }
                    }, {
                        key: "transform",
                        value: function(element, t, e, n) {
                            var r;
                            if (n) {
                                var o = et(element),
                                    l = tt(o.x, t, n),
                                    c = tt(o.y, e, n);
                                r = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(l, ",").concat(c, ",0,1)")
                            } else r = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(t, ",").concat(e, ",0,1)");
                            element.style.webkitTransform = r, element.style.msTransform = r, element.style.transform = r
                        }
                    }, {
                        key: "transformElements",
                        value: function(t) {
                            var e = this,
                                n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                r = this.instance.scroll.x + this.windowWidth,
                                o = this.instance.scroll.y + this.windowHeight,
                                l = {
                                    x: this.instance.scroll.x + this.windowMiddle.x,
                                    y: this.instance.scroll.y + this.windowMiddle.y
                                };
                            Object.entries(this.parallaxElements).forEach((function(c) {
                                var h = w(c, 2),
                                    d = (h[0], h[1]),
                                    f = !1;
                                if (t && (f = 0), d.inView || n) switch (d.position) {
                                    case "top":
                                        f = e.instance.scroll[e.directionAxis] * -d.speed;
                                        break;
                                    case "elementTop":
                                        f = (o - d.top) * -d.speed;
                                        break;
                                    case "bottom":
                                        f = (e.instance.limit[e.directionAxis] - o + e.windowHeight) * d.speed;
                                        break;
                                    case "left":
                                        f = e.instance.scroll[e.directionAxis] * -d.speed;
                                        break;
                                    case "elementLeft":
                                        f = (r - d.left) * -d.speed;
                                        break;
                                    case "right":
                                        f = (e.instance.limit[e.directionAxis] - r + e.windowHeight) * d.speed;
                                        break;
                                    default:
                                        f = (l[e.directionAxis] - d.middle[e.directionAxis]) * -d.speed
                                }
                                d.sticky && (f = d.inView ? "horizontal" === e.direction ? e.instance.scroll.x - d.left + window.innerWidth : e.instance.scroll.y - d.top + window.innerHeight : "horizontal" === e.direction ? e.instance.scroll.x < d.left - window.innerWidth && e.instance.scroll.x < d.left - window.innerWidth / 2 ? 0 : e.instance.scroll.x > d.right && e.instance.scroll.x > d.right + 100 && d.right - d.left + window.innerWidth : e.instance.scroll.y < d.top - window.innerHeight && e.instance.scroll.y < d.top - window.innerHeight / 2 ? 0 : e.instance.scroll.y > d.bottom && e.instance.scroll.y > d.bottom + 100 && d.bottom - d.top + window.innerHeight), !1 !== f && ("horizontal" === d.direction || "horizontal" === e.direction && "vertical" !== d.direction ? e.transform(d.el, f, 0, !t && d.delay) : e.transform(d.el, 0, f, !t && d.delay))
                            }))
                        }
                    }, {
                        key: "scrollTo",
                        value: function(t) {
                            var e = this,
                                n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                                r = parseInt(n.offset) || 0,
                                o = isNaN(parseInt(n.duration)) ? 1e3 : parseInt(n.duration),
                                l = n.easing || [.25, 0, .35, 1],
                                c = !!n.disableLerp,
                                h = !!n.callback && n.callback;
                            if (l = pt.apply(void 0, M(l)), "string" == typeof t) {
                                if ("top" === t) t = 0;
                                else if ("bottom" === t) t = this.instance.limit.y;
                                else if ("left" === t) t = 0;
                                else if ("right" === t) t = this.instance.limit.x;
                                else if (!(t = document.querySelector(t))) return
                            } else if ("number" == typeof t) t = parseInt(t);
                            else if (!t || !t.tagName) return void console.warn("`target` parameter is not valid");
                            if ("number" != typeof t) {
                                var d = nt(t).includes(this.el);
                                if (!d) return;
                                var f = t.getBoundingClientRect(),
                                    m = f.top,
                                    v = f.left,
                                    y = nt(t),
                                    _ = y.find((function(t) {
                                        return Object.entries(e.sections).map((function(t) {
                                            var e = w(t, 2);
                                            e[0];
                                            return e[1]
                                        })).find((function(section) {
                                            return section.el == t
                                        }))
                                    })),
                                    x = 0;
                                x = _ ? et(_)[this.directionAxis] : -this.instance.scroll[this.directionAxis], r = "horizontal" === this.direction ? v + r - x : m + r - x
                            } else r = t + r;
                            var S = parseFloat(this.instance.delta[this.directionAxis]),
                                T = Math.max(0, Math.min(r, this.instance.limit[this.directionAxis])),
                                E = T - S,
                                A = function(p) {
                                    c ? "horizontal" === e.direction ? e.setScroll(S + E * p, e.instance.delta.y) : e.setScroll(e.instance.delta.x, S + E * p) : e.instance.delta[e.directionAxis] = S + E * p
                                };
                            this.animatingScroll = !0, this.stopScrolling(), this.startScrolling();
                            var C = Date.now(),
                                L = function t() {
                                    var p = (Date.now() - C) / o;
                                    p > 1 ? (A(1), e.animatingScroll = !1, 0 == o && e.update(), h && h()) : (e.scrollToRaf = requestAnimationFrame(t), A(l(p)))
                                };
                            L()
                        }
                    }, {
                        key: "update",
                        value: function() {
                            this.setScrollLimit(), this.addSections(), this.addElements(), this.detectElements(), this.updateScroll(), this.transformElements(!0), this.reinitScrollBar(), this.checkScroll(!0)
                        }
                    }, {
                        key: "startScroll",
                        value: function() {
                            this.stop = !1
                        }
                    }, {
                        key: "stopScroll",
                        value: function() {
                            this.stop = !0
                        }
                    }, {
                        key: "setScroll",
                        value: function(t, e) {
                            this.instance = h(h({}, this.instance), {}, {
                                scroll: {
                                    x: t,
                                    y: e
                                },
                                delta: {
                                    x: t,
                                    y: e
                                },
                                speed: 0
                            })
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            x(f(r.prototype), "destroy", this).call(this), this.stopScrolling(), this.html.classList.remove(this.smoothClass), this.vs.destroy(), this.destroyScrollBar(), window.removeEventListener("keydown", this.checkKey, !1)
                        }
                    }]), r
                }(A),
                Mt = function() {
                    function t() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        n(this, t), this.options = e, Object.assign(this, E, e), this.smartphone = E.smartphone, e.smartphone && Object.assign(this.smartphone, e.smartphone), this.tablet = E.tablet, e.tablet && Object.assign(this.tablet, e.tablet), this.smooth || "horizontal" != this.direction || console.warn(" `smooth:false` & `horizontal` direction are not yet compatible"), this.tablet.smooth || "horizontal" != this.tablet.direction || console.warn(" `smooth:false` & `horizontal` direction are not yet compatible (tablet)"), this.smartphone.smooth || "horizontal" != this.smartphone.direction || console.warn(" `smooth:false` & `horizontal` direction are not yet compatible (smartphone)"), this.init()
                    }
                    return o(t, [{
                        key: "init",
                        value: function() {
                            if (this.options.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || window.innerWidth < this.tablet.breakpoint, this.options.isTablet = this.options.isMobile && window.innerWidth >= this.tablet.breakpoint, this.smooth && !this.options.isMobile || this.tablet.smooth && this.options.isTablet || this.smartphone.smooth && this.options.isMobile && !this.options.isTablet ? this.scroll = new wt(this.options) : this.scroll = new R(this.options), this.scroll.init(), window.location.hash) {
                                var t = window.location.hash.slice(1, window.location.hash.length),
                                    e = document.getElementById(t);
                                e && this.scroll.scrollTo(e)
                            }
                        }
                    }, {
                        key: "update",
                        value: function() {
                            this.scroll.update()
                        }
                    }, {
                        key: "start",
                        value: function() {
                            this.scroll.startScroll()
                        }
                    }, {
                        key: "stop",
                        value: function() {
                            this.scroll.stopScroll()
                        }
                    }, {
                        key: "scrollTo",
                        value: function(t, e) {
                            this.scroll.scrollTo(t, e)
                        }
                    }, {
                        key: "setScroll",
                        value: function(t, e) {
                            this.scroll.setScroll(t, e)
                        }
                    }, {
                        key: "on",
                        value: function(t, e) {
                            this.scroll.setEvents(t, e)
                        }
                    }, {
                        key: "off",
                        value: function(t, e) {
                            this.scroll.unsetEvents(t, e)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.scroll.destroy()
                        }
                    }]), t
                }();
            e.a = Mt
        }).call(this, n(51))
    }, function(t, e, n) {
        "use strict";
        var r = n(7),
            o = (n(48), n(15), n(81), n(1)),
            l = n(3),
            c = window.__NUXT__;

        function h() {
            if (!this._hydrated) return this.$fetch()
        }

        function d() {
            if ((t = this).$vnode && t.$vnode.elm && t.$vnode.elm.dataset && t.$vnode.elm.dataset.fetchKey) {
                var t;
                this._hydrated = !0, this._fetchKey = this.$vnode.elm.dataset.fetchKey;
                var data = c.fetch[this._fetchKey];
                if (data && data._error) this.$fetchState.error = data._error;
                else
                    for (var e in data) o.a.set(this.$data, e, data[e])
            }
        }

        function f() {
            var t = this;
            return this._fetchPromise || (this._fetchPromise = m.call(this).then((function() {
                delete t._fetchPromise
            }))), this._fetchPromise
        }

        function m() {
            return v.apply(this, arguments)
        }

        function v() {
            return (v = Object(r.a)(regeneratorRuntime.mark((function t() {
                var e, n, r, o = this;
                return regeneratorRuntime.wrap((function(t) {
                    for (;;) switch (t.prev = t.next) {
                        case 0:
                            return this.$nuxt.nbFetching++, this.$fetchState.pending = !0, this.$fetchState.error = null, this._hydrated = !1, e = null, n = Date.now(), t.prev = 6, t.next = 9, this.$options.fetch.call(this);
                        case 9:
                            t.next = 15;
                            break;
                        case 11:
                            t.prev = 11, t.t0 = t.catch(6), e = Object(l.p)(t.t0);
                        case 15:
                            if (!((r = this._fetchDelay - (Date.now() - n)) > 0)) {
                                t.next = 19;
                                break
                            }
                            return t.next = 19, new Promise((function(t) {
                                return setTimeout(t, r)
                            }));
                        case 19:
                            this.$fetchState.error = e, this.$fetchState.pending = !1, this.$fetchState.timestamp = Date.now(), this.$nextTick((function() {
                                return o.$nuxt.nbFetching--
                            }));
                        case 23:
                        case "end":
                            return t.stop()
                    }
                }), t, this, [
                    [6, 11]
                ])
            })))).apply(this, arguments)
        }
        e.a = {
            beforeCreate: function() {
                Object(l.l)(this) && (this._fetchDelay = "number" == typeof this.$options.fetchDelay ? this.$options.fetchDelay : 200, o.a.util.defineReactive(this, "$fetchState", {
                    pending: !1,
                    error: null,
                    timestamp: Date.now()
                }), this.$fetch = f.bind(this), Object(l.a)(this, "created", d), Object(l.a)(this, "beforeMount", h))
            }
        }
    }, , , function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
            return f
        }));
        var r = n(2),
            o = {
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
                fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}"
            },
            l = n(96),
            c = n(68);
        class h extends c.b {
            constructor(t, e) {
                super(), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1
            }
            render(t, e, n) {
                const r = t.getContext(),
                    o = t.state;
                let l, c;
                o.buffers.color.setMask(!1), o.buffers.depth.setMask(!1), o.buffers.color.setLocked(!0), o.buffers.depth.setLocked(!0), this.inverse ? (l = 0, c = 1) : (l = 1, c = 0), o.buffers.stencil.setTest(!0), o.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), o.buffers.stencil.setFunc(r.ALWAYS, l, 4294967295), o.buffers.stencil.setClear(c), o.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), o.buffers.color.setLocked(!1), o.buffers.depth.setLocked(!1), o.buffers.stencil.setLocked(!1), o.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), o.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), o.buffers.stencil.setLocked(!0)
            }
        }
        class d extends c.b {
            constructor() {
                super(), this.needsSwap = !1
            }
            render(t) {
                t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
            }
        }
        class f {
            constructor(t, e) {
                if (this.renderer = t, void 0 === e) {
                    const n = {
                            minFilter: r.h,
                            magFilter: r.h,
                            format: r.o
                        },
                        o = t.getSize(new r.v);
                    this._pixelRatio = t.getPixelRatio(), this._width = o.width, this._height = o.height, (e = new r.z(this._width * this._pixelRatio, this._height * this._pixelRatio, n)).texture.name = "EffectComposer.rt1"
                } else this._pixelRatio = 1, this._width = e.width, this._height = e.height;
                this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === o && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === l.a && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new l.a(o), this.clock = new r.c
            }
            swapBuffers() {
                const t = this.readBuffer;
                this.readBuffer = this.writeBuffer, this.writeBuffer = t
            }
            addPass(t) {
                this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            insertPass(t, e) {
                this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            removePass(t) {
                const e = this.passes.indexOf(t); - 1 !== e && this.passes.splice(e, 1)
            }
            isLastEnabledPass(t) {
                for (let i = t + 1; i < this.passes.length; i++)
                    if (this.passes[i].enabled) return !1;
                return !0
            }
            render(t) {
                void 0 === t && (t = this.clock.getDelta());
                const e = this.renderer.getRenderTarget();
                let n = !1;
                for (let i = 0, e = this.passes.length; i < e; i++) {
                    const e = this.passes[i];
                    if (!1 !== e.enabled) {
                        if (e.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i), e.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), e.needsSwap) {
                            if (n) {
                                const e = this.renderer.getContext(),
                                    n = this.renderer.state.buffers.stencil;
                                n.setFunc(e.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), n.setFunc(e.EQUAL, 1, 4294967295)
                            }
                            this.swapBuffers()
                        }
                        void 0 !== h && (e instanceof h ? n = !0 : e instanceof d && (n = !1))
                    }
                }
                this.renderer.setRenderTarget(e)
            }
            reset(t) {
                if (void 0 === t) {
                    const e = this.renderer.getSize(new r.v);
                    this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                }
                this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
            }
            setSize(t, e) {
                this._width = t, this._height = e;
                const n = this._width * this._pixelRatio,
                    r = this._height * this._pixelRatio;
                this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r);
                for (let i = 0; i < this.passes.length; i++) this.passes[i].setSize(n, r)
            }
            setPixelRatio(t) {
                this._pixelRatio = t, this.setSize(this._width, this._height)
            }
        }
        new r.k(-1, 1, 1, -1, 0, 1);
        const m = new r.b;
        m.setAttribute("position", new r.f([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), m.setAttribute("uv", new r.f([0, 2, 0, 0, 2, 0], 2))
    }, , , , , , function(t, e, n) {
        (function(t) {
            t.installComponents = function(component, t) {
                var n = "function" == typeof component.exports ? component.exports.extendOptions : component.options;
                for (var i in "function" == typeof component.exports && (n.components = component.exports.options.components), n.components = n.components || {}, t) n.components[i] = n.components[i] || t[i];
                n.functional && function(component, t) {
                    if (component.exports[e]) return;
                    component.exports[e] = !0;
                    var n = component.exports.render;
                    component.exports.render = function(e, r) {
                        return n(e, Object.assign({}, r, {
                            _c: function(e, a, b) {
                                return r._c(t[e] || e, a, b)
                            }
                        }))
                    }
                }(component, n.components)
            };
            var e = "_functionalComponents"
        }).call(this, n(51))
    }, function(t, e, n) {
        "use strict";
        n.r(e),
            function(t) {
                n(42), n(55), n(19), n(56), n(57);
                var e = n(25),
                    r = n(7),
                    o = (n(136), n(280), n(287), n(288), n(48), n(20), n(15), n(22), n(36), n(23), n(50), n(58), n(45), n(43), n(27), n(32), n(81), n(1)),
                    l = n(248),
                    c = n(93),
                    h = n(3),
                    d = n(62),
                    f = n(262),
                    m = n(121);

                function v(t, e) {
                    var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!n) {
                        if (Array.isArray(t) || (n = function(t, e) {
                                if (!t) return;
                                if ("string" == typeof t) return y(t, e);
                                var n = Object.prototype.toString.call(t).slice(8, -1);
                                "Object" === n && t.constructor && (n = t.constructor.name);
                                if ("Map" === n || "Set" === n) return Array.from(t);
                                if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return y(t, e)
                            }(t)) || e && t && "number" == typeof t.length) {
                            n && (t = n);
                            var i = 0,
                                r = function() {};
                            return {
                                s: r,
                                n: function() {
                                    return i >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[i++]
                                    }
                                },
                                e: function(t) {
                                    throw t
                                },
                                f: r
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var o, l = !0,
                        c = !1;
                    return {
                        s: function() {
                            n = n.call(t)
                        },
                        n: function() {
                            var t = n.next();
                            return l = t.done, t
                        },
                        e: function(t) {
                            c = !0, o = t
                        },
                        f: function() {
                            try {
                                l || null == n.return || n.return()
                            } finally {
                                if (c) throw o
                            }
                        }
                    }
                }

                function y(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
                    return n
                }
                o.a.__nuxt__fetch__mixin__ || (o.a.mixin(f.a), o.a.__nuxt__fetch__mixin__ = !0), o.a.component(m.a.name, m.a), o.a.component("NLink", m.a), t.fetch || (t.fetch = l.a);
                var _, x, w = [],
                    M = window.__NUXT__ || {},
                    S = M.config || {};
                S._app && (n.p = Object(h.v)(S._app.cdnURL, S._app.assetsPath)), Object.assign(o.a.config, {
                    silent: !0,
                    performance: !1
                });
                var T = o.a.config.errorHandler || console.error;

                function E(t, e, n) {
                    for (var r = function(component) {
                            var t = function(component, t) {
                                if (!component || !component.options || !component.options[t]) return {};
                                var option = component.options[t];
                                if ("function" == typeof option) {
                                    for (var e = arguments.length, n = new Array(e > 2 ? e - 2 : 0), r = 2; r < e; r++) n[r - 2] = arguments[r];
                                    return option.apply(void 0, n)
                                }
                                return option
                            }(component, "transition", e, n) || {};
                            return "string" == typeof t ? {
                                name: t
                            } : t
                        }, o = n ? Object(h.g)(n) : [], l = Math.max(t.length, o.length), c = [], d = function(i) {
                            var e = Object.assign({}, r(t[i])),
                                n = Object.assign({}, r(o[i]));
                            Object.keys(e).filter((function(t) {
                                return void 0 !== e[t] && !t.toLowerCase().includes("leave")
                            })).forEach((function(t) {
                                n[t] = e[t]
                            })), c.push(n)
                        }, i = 0; i < l; i++) d(i);
                    return c
                }

                function A(t, e, n) {
                    return C.apply(this, arguments)
                }

                function C() {
                    return (C = Object(r.a)(regeneratorRuntime.mark((function t(e, n, r) {
                        var o, l, c, d, f = this;
                        return regeneratorRuntime.wrap((function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    if (this._routeChanged = Boolean(_.nuxt.err) || n.name !== e.name, this._paramChanged = !this._routeChanged && n.path !== e.path, this._queryChanged = !this._paramChanged && n.fullPath !== e.fullPath, this._diffQuery = this._queryChanged ? Object(h.i)(e.query, n.query) : [], t.prev = 4, !this._queryChanged) {
                                        t.next = 10;
                                        break
                                    }
                                    return t.next = 8, Object(h.r)(e, (function(t, e) {
                                        return {
                                            Component: t,
                                            instance: e
                                        }
                                    }));
                                case 8:
                                    o = t.sent, o.some((function(t) {
                                        var r = t.Component,
                                            o = t.instance,
                                            l = r.options.watchQuery;
                                        return !0 === l || (Array.isArray(l) ? l.some((function(t) {
                                            return f._diffQuery[t]
                                        })) : "function" == typeof l && l.apply(o, [e.query, n.query]))
                                    }));
                                case 10:
                                    r(), t.next = 24;
                                    break;
                                case 13:
                                    if (t.prev = 13, t.t0 = t.catch(4), l = t.t0 || {}, c = l.statusCode || l.status || l.response && l.response.status || 500, d = l.message || "", !/^Loading( CSS)? chunk (\d)+ failed\./.test(d)) {
                                        t.next = 21;
                                        break
                                    }
                                    return window.location.reload(!0), t.abrupt("return");
                                case 21:
                                    this.error({
                                        statusCode: c,
                                        message: d
                                    }), this.$nuxt.$emit("routeChanged", e, n, l), r();
                                case 24:
                                case "end":
                                    return t.stop()
                            }
                        }), t, this, [
                            [4, 13]
                        ])
                    })))).apply(this, arguments)
                }

                function L(t, e) {
                    return M.serverRendered && e && Object(h.b)(t, e), t._Ctor = t, t
                }

                function k(t) {
                    return Object(h.d)(t, function() {
                        var t = Object(r.a)(regeneratorRuntime.mark((function t(e, n, r, o, l) {
                            var c;
                            return regeneratorRuntime.wrap((function(t) {
                                for (;;) switch (t.prev = t.next) {
                                    case 0:
                                        if ("function" != typeof e || e.options) {
                                            t.next = 4;
                                            break
                                        }
                                        return t.next = 3, e();
                                    case 3:
                                        e = t.sent;
                                    case 4:
                                        return c = L(Object(h.s)(e), M.data ? M.data[l] : null), r.components[o] = c, t.abrupt("return", c);
                                    case 7:
                                    case "end":
                                        return t.stop()
                                }
                            }), t)
                        })));
                        return function(e, n, r, o, l) {
                            return t.apply(this, arguments)
                        }
                    }())
                }

                function R(t, e, n) {
                    var r = this,
                        o = ["nuxti18n"],
                        l = !1;
                    if (void 0 !== n && (o = [], (n = Object(h.s)(n)).options.middleware && (o = o.concat(n.options.middleware)), t.forEach((function(t) {
                            t.options.middleware && (o = o.concat(t.options.middleware))
                        }))), o = o.map((function(t) {
                            return "function" == typeof t ? t : ("function" != typeof c.a[t] && (l = !0, r.error({
                                statusCode: 500,
                                message: "Unknown middleware " + t
                            })), c.a[t])
                        })), !l) return Object(h.o)(o, e)
                }

                function P(t, e, n) {
                    return D.apply(this, arguments)
                }

                function D() {
                    return D = Object(r.a)(regeneratorRuntime.mark((function t(e, n, o) {
                        var l, c, f, m, y, x, M, S, T, A, C, L, k, P, D, O = this;
                        return regeneratorRuntime.wrap((function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    if (!1 !== this._routeChanged || !1 !== this._paramChanged || !1 !== this._queryChanged) {
                                        t.next = 2;
                                        break
                                    }
                                    return t.abrupt("return", o());
                                case 2:
                                    return !1, e === n ? (w = [], !0) : (l = [], w = Object(h.g)(n, l).map((function(t, i) {
                                        return Object(h.c)(n.matched[l[i]].path)(n.params)
                                    }))), c = !1, f = function(path) {
                                        c || (c = !0, o(path))
                                    }, t.next = 8, Object(h.t)(_, {
                                        route: e,
                                        from: n,
                                        next: f.bind(this)
                                    });
                                case 8:
                                    if (this._dateLastError = _.nuxt.dateErr, this._hadError = Boolean(_.nuxt.err), m = [], (y = Object(h.g)(e, m)).length) {
                                        t.next = 27;
                                        break
                                    }
                                    return t.next = 15, R.call(this, y, _.context);
                                case 15:
                                    if (!c) {
                                        t.next = 17;
                                        break
                                    }
                                    return t.abrupt("return");
                                case 17:
                                    return x = (d.a.options || d.a).layout, t.next = 20, this.loadLayout("function" == typeof x ? x.call(d.a, _.context) : x);
                                case 20:
                                    return M = t.sent, t.next = 23, R.call(this, y, _.context, M);
                                case 23:
                                    if (!c) {
                                        t.next = 25;
                                        break
                                    }
                                    return t.abrupt("return");
                                case 25:
                                    return _.context.error({
                                        statusCode: 404,
                                        message: "This page could not be found"
                                    }), t.abrupt("return", o());
                                case 27:
                                    return y.forEach((function(t) {
                                        t._Ctor && t._Ctor.options && (t.options.asyncData = t._Ctor.options.asyncData, t.options.fetch = t._Ctor.options.fetch)
                                    })), this.setTransitions(E(y, e, n)), t.prev = 29, t.next = 32, R.call(this, y, _.context);
                                case 32:
                                    if (!c) {
                                        t.next = 34;
                                        break
                                    }
                                    return t.abrupt("return");
                                case 34:
                                    if (!_.context._errored) {
                                        t.next = 36;
                                        break
                                    }
                                    return t.abrupt("return", o());
                                case 36:
                                    return "function" == typeof(S = y[0].options.layout) && (S = S(_.context)), t.next = 40, this.loadLayout(S);
                                case 40:
                                    return S = t.sent, t.next = 43, R.call(this, y, _.context, S);
                                case 43:
                                    if (!c) {
                                        t.next = 45;
                                        break
                                    }
                                    return t.abrupt("return");
                                case 45:
                                    if (!_.context._errored) {
                                        t.next = 47;
                                        break
                                    }
                                    return t.abrupt("return", o());
                                case 47:
                                    T = !0, t.prev = 48, A = v(y), t.prev = 50, A.s();
                                case 52:
                                    if ((C = A.n()).done) {
                                        t.next = 63;
                                        break
                                    }
                                    if ("function" == typeof(L = C.value).options.validate) {
                                        t.next = 56;
                                        break
                                    }
                                    return t.abrupt("continue", 61);
                                case 56:
                                    return t.next = 58, L.options.validate(_.context);
                                case 58:
                                    if (T = t.sent) {
                                        t.next = 61;
                                        break
                                    }
                                    return t.abrupt("break", 63);
                                case 61:
                                    t.next = 52;
                                    break;
                                case 63:
                                    t.next = 68;
                                    break;
                                case 65:
                                    t.prev = 65, t.t0 = t.catch(50), A.e(t.t0);
                                case 68:
                                    return t.prev = 68, A.f(), t.finish(68);
                                case 71:
                                    t.next = 77;
                                    break;
                                case 73:
                                    return t.prev = 73, t.t1 = t.catch(48), this.error({
                                        statusCode: t.t1.statusCode || "500",
                                        message: t.t1.message
                                    }), t.abrupt("return", o());
                                case 77:
                                    if (T) {
                                        t.next = 80;
                                        break
                                    }
                                    return this.error({
                                        statusCode: 404,
                                        message: "This page could not be found"
                                    }), t.abrupt("return", o());
                                case 80:
                                    return t.next = 82, Promise.all(y.map(function() {
                                        var t = Object(r.a)(regeneratorRuntime.mark((function t(r, i) {
                                            var o, l, c, d, f, v, y, p;
                                            return regeneratorRuntime.wrap((function(t) {
                                                for (;;) switch (t.prev = t.next) {
                                                    case 0:
                                                        if (r._path = Object(h.c)(e.matched[m[i]].path)(e.params), r._dataRefresh = !1, o = r._path !== w[i], O._routeChanged && o ? r._dataRefresh = !0 : O._paramChanged && o ? (l = r.options.watchParam, r._dataRefresh = !1 !== l) : O._queryChanged && (!0 === (c = r.options.watchQuery) ? r._dataRefresh = !0 : Array.isArray(c) ? r._dataRefresh = c.some((function(t) {
                                                                return O._diffQuery[t]
                                                            })) : "function" == typeof c && (k || (k = Object(h.h)(e)), r._dataRefresh = c.apply(k[i], [e.query, n.query]))), O._hadError || !O._isMounted || r._dataRefresh) {
                                                            t.next = 6;
                                                            break
                                                        }
                                                        return t.abrupt("return");
                                                    case 6:
                                                        return d = [], f = r.options.asyncData && "function" == typeof r.options.asyncData, v = Boolean(r.options.fetch) && r.options.fetch.length, f && ((y = Object(h.q)(r.options.asyncData, _.context)).then((function(t) {
                                                            Object(h.b)(r, t)
                                                        })), d.push(y)), O.$loading.manual = !1 === r.options.loading, v && ((p = r.options.fetch(_.context)) && (p instanceof Promise || "function" == typeof p.then) || (p = Promise.resolve(p)), p.then((function(t) {})), d.push(p)), t.abrupt("return", Promise.all(d));
                                                    case 13:
                                                    case "end":
                                                        return t.stop()
                                                }
                                            }), t)
                                        })));
                                        return function(e, n) {
                                            return t.apply(this, arguments)
                                        }
                                    }()));
                                case 82:
                                    c || o(), t.next = 99;
                                    break;
                                case 85:
                                    if (t.prev = 85, t.t2 = t.catch(29), "ERR_REDIRECT" !== (P = t.t2 || {}).message) {
                                        t.next = 90;
                                        break
                                    }
                                    return t.abrupt("return", this.$nuxt.$emit("routeChanged", e, n, P));
                                case 90:
                                    return w = [], Object(h.k)(P), "function" == typeof(D = (d.a.options || d.a).layout) && (D = D(_.context)), t.next = 96, this.loadLayout(D);
                                case 96:
                                    this.error(P), this.$nuxt.$emit("routeChanged", e, n, P), o();
                                case 99:
                                case "end":
                                    return t.stop()
                            }
                        }), t, this, [
                            [29, 85],
                            [48, 73],
                            [50, 65, 68, 71]
                        ])
                    }))), D.apply(this, arguments)
                }

                function O(t, n) {
                    Object(h.d)(t, (function(t, n, r, l) {
                        return "object" !== Object(e.a)(t) || t.options || ((t = o.a.extend(t))._Ctor = t, r.components[l] = t), t
                    }))
                }

                function I(t) {
                    var e = Boolean(this.$options.nuxt.err);
                    this._hadError && this._dateLastError === this.$options.nuxt.dateErr && (e = !1);
                    var n = e ? (d.a.options || d.a).layout : t.matched[0].components.default.options.layout;
                    "function" == typeof n && (n = n(_.context)), this.setLayout(n)
                }

                function N(t) {
                    t._hadError && t._dateLastError === t.$options.nuxt.dateErr && t.error()
                }

                function F(t, e) {
                    var n = this;
                    if (!1 !== this._routeChanged || !1 !== this._paramChanged || !1 !== this._queryChanged) {
                        var r = Object(h.h)(t),
                            l = Object(h.g)(t),
                            c = !1;
                        o.a.nextTick((function() {
                            r.forEach((function(t, i) {
                                if (t && !t._isDestroyed && t.constructor._dataRefresh && l[i] === t.constructor && !0 !== t.$vnode.data.keepAlive && "function" == typeof t.constructor.options.data) {
                                    var e = t.constructor.options.data.call(t);
                                    for (var n in e) o.a.set(t.$data, n, e[n]);
                                    c = !0
                                }
                            })), c && window.$nuxt.$nextTick((function() {
                                window.$nuxt.$emit("triggerScroll")
                            })), N(n)
                        }))
                    }
                }

                function z(t) {
                    window.onNuxtReadyCbs.forEach((function(e) {
                        "function" == typeof e && e(t)
                    })), "function" == typeof window._onNuxtLoaded && window._onNuxtLoaded(t), x.afterEach((function(e, n) {
                        o.a.nextTick((function() {
                            return t.$nuxt.$emit("routeChanged", e, n)
                        }))
                    }))
                }

                function B() {
                    return (B = Object(r.a)(regeneratorRuntime.mark((function t(e) {
                        var n, r, l, c;
                        return regeneratorRuntime.wrap((function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return _ = e.app, x = e.router, e.store, n = new o.a(_), r = function() {
                                        n.$mount("#__nuxt"), x.afterEach(O), x.afterEach(I.bind(n)), x.afterEach(F.bind(n)), o.a.nextTick((function() {
                                            z(n)
                                        }))
                                    }, t.next = 7, Promise.all(k(_.context.route));
                                case 7:
                                    if (l = t.sent, n.setTransitions = n.$options.nuxt.setTransitions.bind(n), l.length && (n.setTransitions(E(l, x.currentRoute)), w = x.currentRoute.matched.map((function(t) {
                                            return Object(h.c)(t.path)(x.currentRoute.params)
                                        }))), n.$loading = {}, M.error && n.error(M.error), x.beforeEach(A.bind(n)), x.beforeEach(P.bind(n)), !M.serverRendered || !Object(h.n)(M.routePath, n.context.route.path)) {
                                        t.next = 16;
                                        break
                                    }
                                    return t.abrupt("return", r());
                                case 16:
                                    return c = function() {
                                        O(x.currentRoute, x.currentRoute), I.call(n, x.currentRoute), N(n), r()
                                    }, t.next = 19, new Promise((function(t) {
                                        return setTimeout(t, 0)
                                    }));
                                case 19:
                                    P.call(n, x.currentRoute, x.currentRoute, (function(path) {
                                        if (path) {
                                            var t = x.afterEach((function(e, n) {
                                                t(), c()
                                            }));
                                            x.push(path, void 0, (function(t) {
                                                t && T(t)
                                            }))
                                        } else c()
                                    }));
                                case 20:
                                case "end":
                                    return t.stop()
                            }
                        }), t)
                    })))).apply(this, arguments)
                }
                Object(d.b)(null, M.config).then((function(t) {
                    return B.apply(this, arguments)
                })).catch(T)
            }.call(this, n(51))
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, n) {
        var content = n(311);
        content.__esModule && (content = content.default), "string" == typeof content && (content = [
            [t.i, content, ""]
        ]), content.locals && (t.exports = content.locals);
        (0, n(54).default)("517a8dd7", content, !0, {
            sourceMap: !1
        })
    }, function(t, e, n) {
        var r = n(53)(!1);
        r.push([t.i, 'code[class*=language-],pre[class*=language-]{color:#000;background:none;text-shadow:0 1px #fff;font-family:Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#9a6e3a;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}', ""]), t.exports = r
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, n) {
        "use strict";
        var r = n(9),
            o = n(350),
            l = n(354),
            c = n(355),
            h = n(363),
            d = n(377),
            f = n(390),
            m = n(229),
            v = n(392),
            y = {
                default: n(394),
                zero: n(395),
                commonmark: n(396)
            },
            _ = /^(vbscript|javascript|file|data):/,
            x = /^data:image\/(gif|png|jpeg|webp);/;

        function w(t) {
            var e = t.trim().toLowerCase();
            return !_.test(e) || !!x.test(e)
        }
        var M = ["http:", "https:", "mailto:"];

        function S(t) {
            var e = m.parse(t, !0);
            if (e.hostname && (!e.protocol || M.indexOf(e.protocol) >= 0)) try {
                e.hostname = v.toASCII(e.hostname)
            } catch (t) {}
            return m.encode(m.format(e))
        }

        function T(t) {
            var e = m.parse(t, !0);
            if (e.hostname && (!e.protocol || M.indexOf(e.protocol) >= 0)) try {
                e.hostname = v.toUnicode(e.hostname)
            } catch (t) {}
            return m.decode(m.format(e))
        }

        function E(t, e) {
            if (!(this instanceof E)) return new E(t, e);
            e || r.isString(t) || (e = t || {}, t = "default"), this.inline = new d, this.block = new h, this.core = new c, this.renderer = new l, this.linkify = new f, this.validateLink = w, this.normalizeLink = S, this.normalizeLinkText = T, this.utils = r, this.helpers = r.assign({}, o), this.options = {}, this.configure(t), e && this.set(e)
        }
        E.prototype.set = function(t) {
            return r.assign(this.options, t), this
        }, E.prototype.configure = function(t) {
            var e, n = this;
            if (r.isString(t) && !(t = y[e = t])) throw new Error('Wrong `markdown-it` preset "' + e + '", check name');
            if (!t) throw new Error("Wrong `markdown-it` preset, can't be empty");
            return t.options && n.set(t.options), t.components && Object.keys(t.components).forEach((function(e) {
                t.components[e].rules && n[e].ruler.enableOnly(t.components[e].rules), t.components[e].rules2 && n[e].ruler2.enableOnly(t.components[e].rules2)
            })), this
        }, E.prototype.enable = function(t, e) {
            var n = [];
            Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach((function(e) {
                n = n.concat(this[e].ruler.enable(t, !0))
            }), this), n = n.concat(this.inline.ruler2.enable(t, !0));
            var r = t.filter((function(t) {
                return n.indexOf(t) < 0
            }));
            if (r.length && !e) throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
            return this
        }, E.prototype.disable = function(t, e) {
            var n = [];
            Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach((function(e) {
                n = n.concat(this[e].ruler.disable(t, !0))
            }), this), n = n.concat(this.inline.ruler2.disable(t, !0));
            var r = t.filter((function(t) {
                return n.indexOf(t) < 0
            }));
            if (r.length && !e) throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
            return this
        }, E.prototype.use = function(t) {
            var e = [this].concat(Array.prototype.slice.call(arguments, 1));
            return t.apply(t, e), this
        }, E.prototype.parse = function(t, e) {
            if ("string" != typeof t) throw new Error("Input data should be a String");
            var n = new this.core.State(t, this, e);
            return this.core.process(n), n.tokens
        }, E.prototype.render = function(t, e) {
            return e = e || {}, this.renderer.render(this.parse(t, e), this.options, e)
        }, E.prototype.parseInline = function(t, e) {
            var n = new this.core.State(t, this, e);
            return n.inlineMode = !0, this.core.process(n), n.tokens
        }, E.prototype.renderInline = function(t, e) {
            return e = e || {}, this.renderer.render(this.parseInline(t, e), this.options, e)
        }, t.exports = E
    }, function(t) {
        t.exports = JSON.parse('{"Aacute":"","aacute":"","Abreve":"","abreve":"","ac":"","acd":"","acE":"","Acirc":"","acirc":"","acute":"","Acy":"","acy":"","AElig":"","aelig":"","af":"","Afr":"","afr":"","Agrave":"","agrave":"","alefsym":"","aleph":"","Alpha":"","alpha":"","Amacr":"","amacr":"","amalg":"","amp":"&","AMP":"&","andand":"","And":"","and":"","andd":"","andslope":"","andv":"","ang":"","ange":"","angle":"","angmsdaa":"","angmsdab":"","angmsdac":"","angmsdad":"","angmsdae":"","angmsdaf":"","angmsdag":"","angmsdah":"","angmsd":"","angrt":"","angrtvb":"","angrtvbd":"","angsph":"","angst":"","angzarr":"","Aogon":"","aogon":"","Aopf":"","aopf":"","apacir":"","ap":"","apE":"","ape":"","apid":"","apos":"\'","ApplyFunction":"","approx":"","approxeq":"","Aring":"","aring":"","Ascr":"","ascr":"","Assign":"","ast":"*","asymp":"","asympeq":"","Atilde":"","atilde":"","Auml":"","auml":"","awconint":"","awint":"","backcong":"","backepsilon":"","backprime":"","backsim":"","backsimeq":"","Backslash":"","Barv":"","barvee":"","barwed":"","Barwed":"","barwedge":"","bbrk":"","bbrktbrk":"","bcong":"","Bcy":"","bcy":"","bdquo":"","becaus":"","because":"","Because":"","bemptyv":"","bepsi":"","bernou":"","Bernoullis":"","Beta":"","beta":"","beth":"","between":"","Bfr":"","bfr":"","bigcap":"","bigcirc":"","bigcup":"","bigodot":"","bigoplus":"","bigotimes":"","bigsqcup":"","bigstar":"","bigtriangledown":"","bigtriangleup":"","biguplus":"","bigvee":"","bigwedge":"","bkarow":"","blacklozenge":"","blacksquare":"","blacktriangle":"","blacktriangledown":"","blacktriangleleft":"","blacktriangleright":"","blank":"","blk12":"","blk14":"","blk34":"","block":"","bne":"=","bnequiv":"","bNot":"","bnot":"","Bopf":"","bopf":"","bot":"","bottom":"","bowtie":"","boxbox":"","boxdl":"","boxdL":"","boxDl":"","boxDL":"","boxdr":"","boxdR":"","boxDr":"","boxDR":"","boxh":"","boxH":"","boxhd":"","boxHd":"","boxhD":"","boxHD":"","boxhu":"","boxHu":"","boxhU":"","boxHU":"","boxminus":"","boxplus":"","boxtimes":"","boxul":"","boxuL":"","boxUl":"","boxUL":"","boxur":"","boxuR":"","boxUr":"","boxUR":"","boxv":"","boxV":"","boxvh":"","boxvH":"","boxVh":"","boxVH":"","boxvl":"","boxvL":"","boxVl":"","boxVL":"","boxvr":"","boxvR":"","boxVr":"","boxVR":"","bprime":"","breve":"","Breve":"","brvbar":"","bscr":"","Bscr":"","bsemi":"","bsim":"","bsime":"","bsolb":"","bsol":"\\\\","bsolhsub":"","bull":"","bullet":"","bump":"","bumpE":"","bumpe":"","Bumpeq":"","bumpeq":"","Cacute":"","cacute":"","capand":"","capbrcup":"","capcap":"","cap":"","Cap":"","capcup":"","capdot":"","CapitalDifferentialD":"","caps":"","caret":"","caron":"","Cayleys":"","ccaps":"","Ccaron":"","ccaron":"","Ccedil":"","ccedil":"","Ccirc":"","ccirc":"","Cconint":"","ccups":"","ccupssm":"","Cdot":"","cdot":"","cedil":"","Cedilla":"","cemptyv":"","cent":"","centerdot":"","CenterDot":"","cfr":"","Cfr":"","CHcy":"","chcy":"","check":"","checkmark":"","Chi":"","chi":"","circ":"","circeq":"","circlearrowleft":"","circlearrowright":"","circledast":"","circledcirc":"","circleddash":"","CircleDot":"","circledR":"","circledS":"","CircleMinus":"","CirclePlus":"","CircleTimes":"","cir":"","cirE":"","cire":"","cirfnint":"","cirmid":"","cirscir":"","ClockwiseContourIntegral":"","CloseCurlyDoubleQuote":"","CloseCurlyQuote":"","clubs":"","clubsuit":"","colon":":","Colon":"","Colone":"","colone":"","coloneq":"","comma":",","commat":"@","comp":"","compfn":"","complement":"","complexes":"","cong":"","congdot":"","Congruent":"","conint":"","Conint":"","ContourIntegral":"","copf":"","Copf":"","coprod":"","Coproduct":"","copy":"","COPY":"","copysr":"","CounterClockwiseContourIntegral":"","crarr":"","cross":"","Cross":"","Cscr":"","cscr":"","csub":"","csube":"","csup":"","csupe":"","ctdot":"","cudarrl":"","cudarrr":"","cuepr":"","cuesc":"","cularr":"","cularrp":"","cupbrcap":"","cupcap":"","CupCap":"","cup":"","Cup":"","cupcup":"","cupdot":"","cupor":"","cups":"","curarr":"","curarrm":"","curlyeqprec":"","curlyeqsucc":"","curlyvee":"","curlywedge":"","curren":"","curvearrowleft":"","curvearrowright":"","cuvee":"","cuwed":"","cwconint":"","cwint":"","cylcty":"","dagger":"","Dagger":"","daleth":"","darr":"","Darr":"","dArr":"","dash":"","Dashv":"","dashv":"","dbkarow":"","dblac":"","Dcaron":"","dcaron":"","Dcy":"","dcy":"","ddagger":"","ddarr":"","DD":"","dd":"","DDotrahd":"","ddotseq":"","deg":"","Del":"","Delta":"","delta":"","demptyv":"","dfisht":"","Dfr":"","dfr":"","dHar":"","dharl":"","dharr":"","DiacriticalAcute":"","DiacriticalDot":"","DiacriticalDoubleAcute":"","DiacriticalGrave":"`","DiacriticalTilde":"","diam":"","diamond":"","Diamond":"","diamondsuit":"","diams":"","die":"","DifferentialD":"","digamma":"","disin":"","div":"","divide":"","divideontimes":"","divonx":"","DJcy":"","djcy":"","dlcorn":"","dlcrop":"","dollar":"$","Dopf":"","dopf":"","Dot":"","dot":"","DotDot":"","doteq":"","doteqdot":"","DotEqual":"","dotminus":"","dotplus":"","dotsquare":"","doublebarwedge":"","DoubleContourIntegral":"","DoubleDot":"","DoubleDownArrow":"","DoubleLeftArrow":"","DoubleLeftRightArrow":"","DoubleLeftTee":"","DoubleLongLeftArrow":"","DoubleLongLeftRightArrow":"","DoubleLongRightArrow":"","DoubleRightArrow":"","DoubleRightTee":"","DoubleUpArrow":"","DoubleUpDownArrow":"","DoubleVerticalBar":"","DownArrowBar":"","downarrow":"","DownArrow":"","Downarrow":"","DownArrowUpArrow":"","DownBreve":"","downdownarrows":"","downharpoonleft":"","downharpoonright":"","DownLeftRightVector":"","DownLeftTeeVector":"","DownLeftVectorBar":"","DownLeftVector":"","DownRightTeeVector":"","DownRightVectorBar":"","DownRightVector":"","DownTeeArrow":"","DownTee":"","drbkarow":"","drcorn":"","drcrop":"","Dscr":"","dscr":"","DScy":"","dscy":"","dsol":"","Dstrok":"","dstrok":"","dtdot":"","dtri":"","dtrif":"","duarr":"","duhar":"","dwangle":"","DZcy":"","dzcy":"","dzigrarr":"","Eacute":"","eacute":"","easter":"","Ecaron":"","ecaron":"","Ecirc":"","ecirc":"","ecir":"","ecolon":"","Ecy":"","ecy":"","eDDot":"","Edot":"","edot":"","eDot":"","ee":"","efDot":"","Efr":"","efr":"","eg":"","Egrave":"","egrave":"","egs":"","egsdot":"","el":"","Element":"","elinters":"","ell":"","els":"","elsdot":"","Emacr":"","emacr":"","empty":"","emptyset":"","EmptySmallSquare":"","emptyv":"","EmptyVerySmallSquare":"","emsp13":"","emsp14":"","emsp":"","ENG":"","eng":"","ensp":"","Eogon":"","eogon":"","Eopf":"","eopf":"","epar":"","eparsl":"","eplus":"","epsi":"","Epsilon":"","epsilon":"","epsiv":"","eqcirc":"","eqcolon":"","eqsim":"","eqslantgtr":"","eqslantless":"","Equal":"","equals":"=","EqualTilde":"","equest":"","Equilibrium":"","equiv":"","equivDD":"","eqvparsl":"","erarr":"","erDot":"","escr":"","Escr":"","esdot":"","Esim":"","esim":"","Eta":"","eta":"","ETH":"","eth":"","Euml":"","euml":"","euro":"","excl":"!","exist":"","Exists":"","expectation":"","exponentiale":"","ExponentialE":"","fallingdotseq":"","Fcy":"","fcy":"","female":"","ffilig":"","fflig":"","ffllig":"","Ffr":"","ffr":"","filig":"","FilledSmallSquare":"","FilledVerySmallSquare":"","fjlig":"fj","flat":"","fllig":"","fltns":"","fnof":"","Fopf":"","fopf":"","forall":"","ForAll":"","fork":"","forkv":"","Fouriertrf":"","fpartint":"","frac12":"","frac13":"","frac14":"","frac15":"","frac16":"","frac18":"","frac23":"","frac25":"","frac34":"","frac35":"","frac38":"","frac45":"","frac56":"","frac58":"","frac78":"","frasl":"","frown":"","fscr":"","Fscr":"","gacute":"","Gamma":"","gamma":"","Gammad":"","gammad":"","gap":"","Gbreve":"","gbreve":"","Gcedil":"","Gcirc":"","gcirc":"","Gcy":"","gcy":"","Gdot":"","gdot":"","ge":"","gE":"","gEl":"","gel":"","geq":"","geqq":"","geqslant":"","gescc":"","ges":"","gesdot":"","gesdoto":"","gesdotol":"","gesl":"","gesles":"","Gfr":"","gfr":"","gg":"","Gg":"","ggg":"","gimel":"","GJcy":"","gjcy":"","gla":"","gl":"","glE":"","glj":"","gnap":"","gnapprox":"","gne":"","gnE":"","gneq":"","gneqq":"","gnsim":"","Gopf":"","gopf":"","grave":"`","GreaterEqual":"","GreaterEqualLess":"","GreaterFullEqual":"","GreaterGreater":"","GreaterLess":"","GreaterSlantEqual":"","GreaterTilde":"","Gscr":"","gscr":"","gsim":"","gsime":"","gsiml":"","gtcc":"","gtcir":"","gt":">","GT":">","Gt":"","gtdot":"","gtlPar":"","gtquest":"","gtrapprox":"","gtrarr":"","gtrdot":"","gtreqless":"","gtreqqless":"","gtrless":"","gtrsim":"","gvertneqq":"","gvnE":"","Hacek":"","hairsp":"","half":"","hamilt":"","HARDcy":"","hardcy":"","harrcir":"","harr":"","hArr":"","harrw":"","Hat":"^","hbar":"","Hcirc":"","hcirc":"","hearts":"","heartsuit":"","hellip":"","hercon":"","hfr":"","Hfr":"","HilbertSpace":"","hksearow":"","hkswarow":"","hoarr":"","homtht":"","hookleftarrow":"","hookrightarrow":"","hopf":"","Hopf":"","horbar":"","HorizontalLine":"","hscr":"","Hscr":"","hslash":"","Hstrok":"","hstrok":"","HumpDownHump":"","HumpEqual":"","hybull":"","hyphen":"","Iacute":"","iacute":"","ic":"","Icirc":"","icirc":"","Icy":"","icy":"","Idot":"","IEcy":"","iecy":"","iexcl":"","iff":"","ifr":"","Ifr":"","Igrave":"","igrave":"","ii":"","iiiint":"","iiint":"","iinfin":"","iiota":"","IJlig":"","ijlig":"","Imacr":"","imacr":"","image":"","ImaginaryI":"","imagline":"","imagpart":"","imath":"","Im":"","imof":"","imped":"","Implies":"","incare":"","in":"","infin":"","infintie":"","inodot":"","intcal":"","int":"","Int":"","integers":"","Integral":"","intercal":"","Intersection":"","intlarhk":"","intprod":"","InvisibleComma":"","InvisibleTimes":"","IOcy":"","iocy":"","Iogon":"","iogon":"","Iopf":"","iopf":"","Iota":"","iota":"","iprod":"","iquest":"","iscr":"","Iscr":"","isin":"","isindot":"","isinE":"","isins":"","isinsv":"","isinv":"","it":"","Itilde":"","itilde":"","Iukcy":"","iukcy":"","Iuml":"","iuml":"","Jcirc":"","jcirc":"","Jcy":"","jcy":"","Jfr":"","jfr":"","jmath":"","Jopf":"","jopf":"","Jscr":"","jscr":"","Jsercy":"","jsercy":"","Jukcy":"","jukcy":"","Kappa":"","kappa":"","kappav":"","Kcedil":"","kcedil":"","Kcy":"","kcy":"","Kfr":"","kfr":"","kgreen":"","KHcy":"","khcy":"","KJcy":"","kjcy":"","Kopf":"","kopf":"","Kscr":"","kscr":"","lAarr":"","Lacute":"","lacute":"","laemptyv":"","lagran":"","Lambda":"","lambda":"","lang":"","Lang":"","langd":"","langle":"","lap":"","Laplacetrf":"","laquo":"","larrb":"","larrbfs":"","larr":"","Larr":"","lArr":"","larrfs":"","larrhk":"","larrlp":"","larrpl":"","larrsim":"","larrtl":"","latail":"","lAtail":"","lat":"","late":"","lates":"","lbarr":"","lBarr":"","lbbrk":"","lbrace":"{","lbrack":"[","lbrke":"","lbrksld":"","lbrkslu":"","Lcaron":"","lcaron":"","Lcedil":"","lcedil":"","lceil":"","lcub":"{","Lcy":"","lcy":"","ldca":"","ldquo":"","ldquor":"","ldrdhar":"","ldrushar":"","ldsh":"","le":"","lE":"","LeftAngleBracket":"","LeftArrowBar":"","leftarrow":"","LeftArrow":"","Leftarrow":"","LeftArrowRightArrow":"","leftarrowtail":"","LeftCeiling":"","LeftDoubleBracket":"","LeftDownTeeVector":"","LeftDownVectorBar":"","LeftDownVector":"","LeftFloor":"","leftharpoondown":"","leftharpoonup":"","leftleftarrows":"","leftrightarrow":"","LeftRightArrow":"","Leftrightarrow":"","leftrightarrows":"","leftrightharpoons":"","leftrightsquigarrow":"","LeftRightVector":"","LeftTeeArrow":"","LeftTee":"","LeftTeeVector":"","leftthreetimes":"","LeftTriangleBar":"","LeftTriangle":"","LeftTriangleEqual":"","LeftUpDownVector":"","LeftUpTeeVector":"","LeftUpVectorBar":"","LeftUpVector":"","LeftVectorBar":"","LeftVector":"","lEg":"","leg":"","leq":"","leqq":"","leqslant":"","lescc":"","les":"","lesdot":"","lesdoto":"","lesdotor":"","lesg":"","lesges":"","lessapprox":"","lessdot":"","lesseqgtr":"","lesseqqgtr":"","LessEqualGreater":"","LessFullEqual":"","LessGreater":"","lessgtr":"","LessLess":"","lesssim":"","LessSlantEqual":"","LessTilde":"","lfisht":"","lfloor":"","Lfr":"","lfr":"","lg":"","lgE":"","lHar":"","lhard":"","lharu":"","lharul":"","lhblk":"","LJcy":"","ljcy":"","llarr":"","ll":"","Ll":"","llcorner":"","Lleftarrow":"","llhard":"","lltri":"","Lmidot":"","lmidot":"","lmoustache":"","lmoust":"","lnap":"","lnapprox":"","lne":"","lnE":"","lneq":"","lneqq":"","lnsim":"","loang":"","loarr":"","lobrk":"","longleftarrow":"","LongLeftArrow":"","Longleftarrow":"","longleftrightarrow":"","LongLeftRightArrow":"","Longleftrightarrow":"","longmapsto":"","longrightarrow":"","LongRightArrow":"","Longrightarrow":"","looparrowleft":"","looparrowright":"","lopar":"","Lopf":"","lopf":"","loplus":"","lotimes":"","lowast":"","lowbar":"_","LowerLeftArrow":"","LowerRightArrow":"","loz":"","lozenge":"","lozf":"","lpar":"(","lparlt":"","lrarr":"","lrcorner":"","lrhar":"","lrhard":"","lrm":"","lrtri":"","lsaquo":"","lscr":"","Lscr":"","lsh":"","Lsh":"","lsim":"","lsime":"","lsimg":"","lsqb":"[","lsquo":"","lsquor":"","Lstrok":"","lstrok":"","ltcc":"","ltcir":"","lt":"<","LT":"<","Lt":"","ltdot":"","lthree":"","ltimes":"","ltlarr":"","ltquest":"","ltri":"","ltrie":"","ltrif":"","ltrPar":"","lurdshar":"","luruhar":"","lvertneqq":"","lvnE":"","macr":"","male":"","malt":"","maltese":"","Map":"","map":"","mapsto":"","mapstodown":"","mapstoleft":"","mapstoup":"","marker":"","mcomma":"","Mcy":"","mcy":"","mdash":"","mDDot":"","measuredangle":"","MediumSpace":"","Mellintrf":"","Mfr":"","mfr":"","mho":"","micro":"","midast":"*","midcir":"","mid":"","middot":"","minusb":"","minus":"","minusd":"","minusdu":"","MinusPlus":"","mlcp":"","mldr":"","mnplus":"","models":"","Mopf":"","mopf":"","mp":"","mscr":"","Mscr":"","mstpos":"","Mu":"","mu":"","multimap":"","mumap":"","nabla":"","Nacute":"","nacute":"","nang":"","nap":"","napE":"","napid":"","napos":"","napprox":"","natural":"","naturals":"","natur":"","nbsp":"","nbump":"","nbumpe":"","ncap":"","Ncaron":"","ncaron":"","Ncedil":"","ncedil":"","ncong":"","ncongdot":"","ncup":"","Ncy":"","ncy":"","ndash":"","nearhk":"","nearr":"","neArr":"","nearrow":"","ne":"","nedot":"","NegativeMediumSpace":"","NegativeThickSpace":"","NegativeThinSpace":"","NegativeVeryThinSpace":"","nequiv":"","nesear":"","nesim":"","NestedGreaterGreater":"","NestedLessLess":"","NewLine":"\\n","nexist":"","nexists":"","Nfr":"","nfr":"","ngE":"","nge":"","ngeq":"","ngeqq":"","ngeqslant":"","nges":"","nGg":"","ngsim":"","nGt":"","ngt":"","ngtr":"","nGtv":"","nharr":"","nhArr":"","nhpar":"","ni":"","nis":"","nisd":"","niv":"","NJcy":"","njcy":"","nlarr":"","nlArr":"","nldr":"","nlE":"","nle":"","nleftarrow":"","nLeftarrow":"","nleftrightarrow":"","nLeftrightarrow":"","nleq":"","nleqq":"","nleqslant":"","nles":"","nless":"","nLl":"","nlsim":"","nLt":"","nlt":"","nltri":"","nltrie":"","nLtv":"","nmid":"","NoBreak":"","NonBreakingSpace":"","nopf":"","Nopf":"","Not":"","not":"","NotCongruent":"","NotCupCap":"","NotDoubleVerticalBar":"","NotElement":"","NotEqual":"","NotEqualTilde":"","NotExists":"","NotGreater":"","NotGreaterEqual":"","NotGreaterFullEqual":"","NotGreaterGreater":"","NotGreaterLess":"","NotGreaterSlantEqual":"","NotGreaterTilde":"","NotHumpDownHump":"","NotHumpEqual":"","notin":"","notindot":"","notinE":"","notinva":"","notinvb":"","notinvc":"","NotLeftTriangleBar":"","NotLeftTriangle":"","NotLeftTriangleEqual":"","NotLess":"","NotLessEqual":"","NotLessGreater":"","NotLessLess":"","NotLessSlantEqual":"","NotLessTilde":"","NotNestedGreaterGreater":"","NotNestedLessLess":"","notni":"","notniva":"","notnivb":"","notnivc":"","NotPrecedes":"","NotPrecedesEqual":"","NotPrecedesSlantEqual":"","NotReverseElement":"","NotRightTriangleBar":"","NotRightTriangle":"","NotRightTriangleEqual":"","NotSquareSubset":"","NotSquareSubsetEqual":"","NotSquareSuperset":"","NotSquareSupersetEqual":"","NotSubset":"","NotSubsetEqual":"","NotSucceeds":"","NotSucceedsEqual":"","NotSucceedsSlantEqual":"","NotSucceedsTilde":"","NotSuperset":"","NotSupersetEqual":"","NotTilde":"","NotTildeEqual":"","NotTildeFullEqual":"","NotTildeTilde":"","NotVerticalBar":"","nparallel":"","npar":"","nparsl":"","npart":"","npolint":"","npr":"","nprcue":"","nprec":"","npreceq":"","npre":"","nrarrc":"","nrarr":"","nrArr":"","nrarrw":"","nrightarrow":"","nRightarrow":"","nrtri":"","nrtrie":"","nsc":"","nsccue":"","nsce":"","Nscr":"","nscr":"","nshortmid":"","nshortparallel":"","nsim":"","nsime":"","nsimeq":"","nsmid":"","nspar":"","nsqsube":"","nsqsupe":"","nsub":"","nsubE":"","nsube":"","nsubset":"","nsubseteq":"","nsubseteqq":"","nsucc":"","nsucceq":"","nsup":"","nsupE":"","nsupe":"","nsupset":"","nsupseteq":"","nsupseteqq":"","ntgl":"","Ntilde":"","ntilde":"","ntlg":"","ntriangleleft":"","ntrianglelefteq":"","ntriangleright":"","ntrianglerighteq":"","Nu":"","nu":"","num":"#","numero":"","numsp":"","nvap":"","nvdash":"","nvDash":"","nVdash":"","nVDash":"","nvge":"","nvgt":">","nvHarr":"","nvinfin":"","nvlArr":"","nvle":"","nvlt":"<","nvltrie":"","nvrArr":"","nvrtrie":"","nvsim":"","nwarhk":"","nwarr":"","nwArr":"","nwarrow":"","nwnear":"","Oacute":"","oacute":"","oast":"","Ocirc":"","ocirc":"","ocir":"","Ocy":"","ocy":"","odash":"","Odblac":"","odblac":"","odiv":"","odot":"","odsold":"","OElig":"","oelig":"","ofcir":"","Ofr":"","ofr":"","ogon":"","Ograve":"","ograve":"","ogt":"","ohbar":"","ohm":"","oint":"","olarr":"","olcir":"","olcross":"","oline":"","olt":"","Omacr":"","omacr":"","Omega":"","omega":"","Omicron":"","omicron":"","omid":"","ominus":"","Oopf":"","oopf":"","opar":"","OpenCurlyDoubleQuote":"","OpenCurlyQuote":"","operp":"","oplus":"","orarr":"","Or":"","or":"","ord":"","order":"","orderof":"","ordf":"","ordm":"","origof":"","oror":"","orslope":"","orv":"","oS":"","Oscr":"","oscr":"","Oslash":"","oslash":"","osol":"","Otilde":"","otilde":"","otimesas":"","Otimes":"","otimes":"","Ouml":"","ouml":"","ovbar":"","OverBar":"","OverBrace":"","OverBracket":"","OverParenthesis":"","para":"","parallel":"","par":"","parsim":"","parsl":"","part":"","PartialD":"","Pcy":"","pcy":"","percnt":"%","period":".","permil":"","perp":"","pertenk":"","Pfr":"","pfr":"","Phi":"","phi":"","phiv":"","phmmat":"","phone":"","Pi":"","pi":"","pitchfork":"","piv":"","planck":"","planckh":"","plankv":"","plusacir":"","plusb":"","pluscir":"","plus":"+","plusdo":"","plusdu":"","pluse":"","PlusMinus":"","plusmn":"","plussim":"","plustwo":"","pm":"","Poincareplane":"","pointint":"","popf":"","Popf":"","pound":"","prap":"","Pr":"","pr":"","prcue":"","precapprox":"","prec":"","preccurlyeq":"","Precedes":"","PrecedesEqual":"","PrecedesSlantEqual":"","PrecedesTilde":"","preceq":"","precnapprox":"","precneqq":"","precnsim":"","pre":"","prE":"","precsim":"","prime":"","Prime":"","primes":"","prnap":"","prnE":"","prnsim":"","prod":"","Product":"","profalar":"","profline":"","profsurf":"","prop":"","Proportional":"","Proportion":"","propto":"","prsim":"","prurel":"","Pscr":"","pscr":"","Psi":"","psi":"","puncsp":"","Qfr":"","qfr":"","qint":"","qopf":"","Qopf":"","qprime":"","Qscr":"","qscr":"","quaternions":"","quatint":"","quest":"?","questeq":"","quot":"\\"","QUOT":"\\"","rAarr":"","race":"","Racute":"","racute":"","radic":"","raemptyv":"","rang":"","Rang":"","rangd":"","range":"","rangle":"","raquo":"","rarrap":"","rarrb":"","rarrbfs":"","rarrc":"","rarr":"","Rarr":"","rArr":"","rarrfs":"","rarrhk":"","rarrlp":"","rarrpl":"","rarrsim":"","Rarrtl":"","rarrtl":"","rarrw":"","ratail":"","rAtail":"","ratio":"","rationals":"","rbarr":"","rBarr":"","RBarr":"","rbbrk":"","rbrace":"}","rbrack":"]","rbrke":"","rbrksld":"","rbrkslu":"","Rcaron":"","rcaron":"","Rcedil":"","rcedil":"","rceil":"","rcub":"}","Rcy":"","rcy":"","rdca":"","rdldhar":"","rdquo":"","rdquor":"","rdsh":"","real":"","realine":"","realpart":"","reals":"","Re":"","rect":"","reg":"","REG":"","ReverseElement":"","ReverseEquilibrium":"","ReverseUpEquilibrium":"","rfisht":"","rfloor":"","rfr":"","Rfr":"","rHar":"","rhard":"","rharu":"","rharul":"","Rho":"","rho":"","rhov":"","RightAngleBracket":"","RightArrowBar":"","rightarrow":"","RightArrow":"","Rightarrow":"","RightArrowLeftArrow":"","rightarrowtail":"","RightCeiling":"","RightDoubleBracket":"","RightDownTeeVector":"","RightDownVectorBar":"","RightDownVector":"","RightFloor":"","rightharpoondown":"","rightharpoonup":"","rightleftarrows":"","rightleftharpoons":"","rightrightarrows":"","rightsquigarrow":"","RightTeeArrow":"","RightTee":"","RightTeeVector":"","rightthreetimes":"","RightTriangleBar":"","RightTriangle":"","RightTriangleEqual":"","RightUpDownVector":"","RightUpTeeVector":"","RightUpVectorBar":"","RightUpVector":"","RightVectorBar":"","RightVector":"","ring":"","risingdotseq":"","rlarr":"","rlhar":"","rlm":"","rmoustache":"","rmoust":"","rnmid":"","roang":"","roarr":"","robrk":"","ropar":"","ropf":"","Ropf":"","roplus":"","rotimes":"","RoundImplies":"","rpar":")","rpargt":"","rppolint":"","rrarr":"","Rrightarrow":"","rsaquo":"","rscr":"","Rscr":"","rsh":"","Rsh":"","rsqb":"]","rsquo":"","rsquor":"","rthree":"","rtimes":"","rtri":"","rtrie":"","rtrif":"","rtriltri":"","RuleDelayed":"","ruluhar":"","rx":"","Sacute":"","sacute":"","sbquo":"","scap":"","Scaron":"","scaron":"","Sc":"","sc":"","sccue":"","sce":"","scE":"","Scedil":"","scedil":"","Scirc":"","scirc":"","scnap":"","scnE":"","scnsim":"","scpolint":"","scsim":"","Scy":"","scy":"","sdotb":"","sdot":"","sdote":"","searhk":"","searr":"","seArr":"","searrow":"","sect":"","semi":";","seswar":"","setminus":"","setmn":"","sext":"","Sfr":"","sfr":"","sfrown":"","sharp":"","SHCHcy":"","shchcy":"","SHcy":"","shcy":"","ShortDownArrow":"","ShortLeftArrow":"","shortmid":"","shortparallel":"","ShortRightArrow":"","ShortUpArrow":"","shy":"","Sigma":"","sigma":"","sigmaf":"","sigmav":"","sim":"","simdot":"","sime":"","simeq":"","simg":"","simgE":"","siml":"","simlE":"","simne":"","simplus":"","simrarr":"","slarr":"","SmallCircle":"","smallsetminus":"","smashp":"","smeparsl":"","smid":"","smile":"","smt":"","smte":"","smtes":"","SOFTcy":"","softcy":"","solbar":"","solb":"","sol":"/","Sopf":"","sopf":"","spades":"","spadesuit":"","spar":"","sqcap":"","sqcaps":"","sqcup":"","sqcups":"","Sqrt":"","sqsub":"","sqsube":"","sqsubset":"","sqsubseteq":"","sqsup":"","sqsupe":"","sqsupset":"","sqsupseteq":"","square":"","Square":"","SquareIntersection":"","SquareSubset":"","SquareSubsetEqual":"","SquareSuperset":"","SquareSupersetEqual":"","SquareUnion":"","squarf":"","squ":"","squf":"","srarr":"","Sscr":"","sscr":"","ssetmn":"","ssmile":"","sstarf":"","Star":"","star":"","starf":"","straightepsilon":"","straightphi":"","strns":"","sub":"","Sub":"","subdot":"","subE":"","sube":"","subedot":"","submult":"","subnE":"","subne":"","subplus":"","subrarr":"","subset":"","Subset":"","subseteq":"","subseteqq":"","SubsetEqual":"","subsetneq":"","subsetneqq":"","subsim":"","subsub":"","subsup":"","succapprox":"","succ":"","succcurlyeq":"","Succeeds":"","SucceedsEqual":"","SucceedsSlantEqual":"","SucceedsTilde":"","succeq":"","succnapprox":"","succneqq":"","succnsim":"","succsim":"","SuchThat":"","sum":"","Sum":"","sung":"","sup1":"","sup2":"","sup3":"","sup":"","Sup":"","supdot":"","supdsub":"","supE":"","supe":"","supedot":"","Superset":"","SupersetEqual":"","suphsol":"","suphsub":"","suplarr":"","supmult":"","supnE":"","supne":"","supplus":"","supset":"","Supset":"","supseteq":"","supseteqq":"","supsetneq":"","supsetneqq":"","supsim":"","supsub":"","supsup":"","swarhk":"","swarr":"","swArr":"","swarrow":"","swnwar":"","szlig":"","Tab":"\\t","target":"","Tau":"","tau":"","tbrk":"","Tcaron":"","tcaron":"","Tcedil":"","tcedil":"","Tcy":"","tcy":"","tdot":"","telrec":"","Tfr":"","tfr":"","there4":"","therefore":"","Therefore":"","Theta":"","theta":"","thetasym":"","thetav":"","thickapprox":"","thicksim":"","ThickSpace":"","ThinSpace":"","thinsp":"","thkap":"","thksim":"","THORN":"","thorn":"","tilde":"","Tilde":"","TildeEqual":"","TildeFullEqual":"","TildeTilde":"","timesbar":"","timesb":"","times":"","timesd":"","tint":"","toea":"","topbot":"","topcir":"","top":"","Topf":"","topf":"","topfork":"","tosa":"","tprime":"","trade":"","TRADE":"","triangle":"","triangledown":"","triangleleft":"","trianglelefteq":"","triangleq":"","triangleright":"","trianglerighteq":"","tridot":"","trie":"","triminus":"","TripleDot":"","triplus":"","trisb":"","tritime":"","trpezium":"","Tscr":"","tscr":"","TScy":"","tscy":"","TSHcy":"","tshcy":"","Tstrok":"","tstrok":"","twixt":"","twoheadleftarrow":"","twoheadrightarrow":"","Uacute":"","uacute":"","uarr":"","Uarr":"","uArr":"","Uarrocir":"","Ubrcy":"","ubrcy":"","Ubreve":"","ubreve":"","Ucirc":"","ucirc":"","Ucy":"","ucy":"","udarr":"","Udblac":"","udblac":"","udhar":"","ufisht":"","Ufr":"","ufr":"","Ugrave":"","ugrave":"","uHar":"","uharl":"","uharr":"","uhblk":"","ulcorn":"","ulcorner":"","ulcrop":"","ultri":"","Umacr":"","umacr":"","uml":"","UnderBar":"_","UnderBrace":"","UnderBracket":"","UnderParenthesis":"","Union":"","UnionPlus":"","Uogon":"","uogon":"","Uopf":"","uopf":"","UpArrowBar":"","uparrow":"","UpArrow":"","Uparrow":"","UpArrowDownArrow":"","updownarrow":"","UpDownArrow":"","Updownarrow":"","UpEquilibrium":"","upharpoonleft":"","upharpoonright":"","uplus":"","UpperLeftArrow":"","UpperRightArrow":"","upsi":"","Upsi":"","upsih":"","Upsilon":"","upsilon":"","UpTeeArrow":"","UpTee":"","upuparrows":"","urcorn":"","urcorner":"","urcrop":"","Uring":"","uring":"","urtri":"","Uscr":"","uscr":"","utdot":"","Utilde":"","utilde":"","utri":"","utrif":"","uuarr":"","Uuml":"","uuml":"","uwangle":"","vangrt":"","varepsilon":"","varkappa":"","varnothing":"","varphi":"","varpi":"","varpropto":"","varr":"","vArr":"","varrho":"","varsigma":"","varsubsetneq":"","varsubsetneqq":"","varsupsetneq":"","varsupsetneqq":"","vartheta":"","vartriangleleft":"","vartriangleright":"","vBar":"","Vbar":"","vBarv":"","Vcy":"","vcy":"","vdash":"","vDash":"","Vdash":"","VDash":"","Vdashl":"","veebar":"","vee":"","Vee":"","veeeq":"","vellip":"","verbar":"|","Verbar":"","vert":"|","Vert":"","VerticalBar":"","VerticalLine":"|","VerticalSeparator":"","VerticalTilde":"","VeryThinSpace":"","Vfr":"","vfr":"","vltri":"","vnsub":"","vnsup":"","Vopf":"","vopf":"","vprop":"","vrtri":"","Vscr":"","vscr":"","vsubnE":"","vsubne":"","vsupnE":"","vsupne":"","Vvdash":"","vzigzag":"","Wcirc":"","wcirc":"","wedbar":"","wedge":"","Wedge":"","wedgeq":"","weierp":"","Wfr":"","wfr":"","Wopf":"","wopf":"","wp":"","wr":"","wreath":"","Wscr":"","wscr":"","xcap":"","xcirc":"","xcup":"","xdtri":"","Xfr":"","xfr":"","xharr":"","xhArr":"","Xi":"","xi":"","xlarr":"","xlArr":"","xmap":"","xnis":"","xodot":"","Xopf":"","xopf":"","xoplus":"","xotime":"","xrarr":"","xrArr":"","Xscr":"","xscr":"","xsqcup":"","xuplus":"","xutri":"","xvee":"","xwedge":"","Yacute":"","yacute":"","YAcy":"","yacy":"","Ycirc":"","ycirc":"","Ycy":"","ycy":"","yen":"","Yfr":"","yfr":"","YIcy":"","yicy":"","Yopf":"","yopf":"","Yscr":"","yscr":"","YUcy":"","yucy":"","yuml":"","Yuml":"","Zacute":"","zacute":"","Zcaron":"","zcaron":"","Zcy":"","zcy":"","Zdot":"","zdot":"","zeetrf":"","ZeroWidthSpace":"","Zeta":"","zeta":"","zfr":"","Zfr":"","ZHcy":"","zhcy":"","zigrarr":"","zopf":"","Zopf":"","Zscr":"","zscr":"","zwj":"","zwnj":""}')
    }, function(t, e, n) {
        "use strict";
        var r = {};

        function o(t, e, n) {
            var i, l, code, c, h, d = "";
            for ("string" != typeof e && (n = e, e = o.defaultChars), void 0 === n && (n = !0), h = function(t) {
                    var i, e, n = r[t];
                    if (n) return n;
                    for (n = r[t] = [], i = 0; i < 128; i++) e = String.fromCharCode(i), /^[0-9a-z]$/i.test(e) ? n.push(e) : n.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
                    for (i = 0; i < t.length; i++) n[t.charCodeAt(i)] = t[i];
                    return n
                }(e), i = 0, l = t.length; i < l; i++)
                if (code = t.charCodeAt(i), n && 37 === code && i + 2 < l && /^[0-9a-f]{2}$/i.test(t.slice(i + 1, i + 3))) d += t.slice(i, i + 3), i += 2;
                else if (code < 128) d += h[code];
            else if (code >= 55296 && code <= 57343) {
                if (code >= 55296 && code <= 56319 && i + 1 < l && (c = t.charCodeAt(i + 1)) >= 56320 && c <= 57343) {
                    d += encodeURIComponent(t[i] + t[i + 1]), i++;
                    continue
                }
                d += "%EF%BF%BD"
            } else d += encodeURIComponent(t[i]);
            return d
        }
        o.defaultChars = ";/?:@&=+$,-_.!~*'()#", o.componentChars = "-_.!~*'()", t.exports = o
    }, function(t, e, n) {
        "use strict";
        var r = {};

        function o(t, e) {
            var n;
            return "string" != typeof e && (e = o.defaultChars), n = function(t) {
                var i, e, n = r[t];
                if (n) return n;
                for (n = r[t] = [], i = 0; i < 128; i++) e = String.fromCharCode(i), n.push(e);
                for (i = 0; i < t.length; i++) n[e = t.charCodeAt(i)] = "%" + ("0" + e.toString(16).toUpperCase()).slice(-2);
                return n
            }(e), t.replace(/(%[a-f0-9]{2})+/gi, (function(t) {
                var i, e, r, o, l, c, h, d = "";
                for (i = 0, e = t.length; i < e; i += 3)(r = parseInt(t.slice(i + 1, i + 3), 16)) < 128 ? d += n[r] : 192 == (224 & r) && i + 3 < e && 128 == (192 & (o = parseInt(t.slice(i + 4, i + 6), 16))) ? (d += (h = r << 6 & 1984 | 63 & o) < 128 ? "" : String.fromCharCode(h), i += 3) : 224 == (240 & r) && i + 6 < e && (o = parseInt(t.slice(i + 4, i + 6), 16), l = parseInt(t.slice(i + 7, i + 9), 16), 128 == (192 & o) && 128 == (192 & l)) ? (d += (h = r << 12 & 61440 | o << 6 & 4032 | 63 & l) < 2048 || h >= 55296 && h <= 57343 ? "" : String.fromCharCode(h), i += 6) : 240 == (248 & r) && i + 9 < e && (o = parseInt(t.slice(i + 4, i + 6), 16), l = parseInt(t.slice(i + 7, i + 9), 16), c = parseInt(t.slice(i + 10, i + 12), 16), 128 == (192 & o) && 128 == (192 & l) && 128 == (192 & c)) ? ((h = r << 18 & 1835008 | o << 12 & 258048 | l << 6 & 4032 | 63 & c) < 65536 || h > 1114111 ? d += "" : (h -= 65536, d += String.fromCharCode(55296 + (h >> 10), 56320 + (1023 & h))), i += 9) : d += "";
                return d
            }))
        }
        o.defaultChars = ";/?:@&=+$,#", o.componentChars = "", t.exports = o
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t) {
            var e = "";
            return e += t.protocol || "", e += t.slashes ? "//" : "", e += t.auth ? t.auth + "@" : "", t.hostname && -1 !== t.hostname.indexOf(":") ? e += "[" + t.hostname + "]" : e += t.hostname || "", e += t.port ? ":" + t.port : "", e += t.pathname || "", e += t.search || "", e += t.hash || ""
        }
    }, function(t, e, n) {
        "use strict";

        function r() {
            this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null
        }
        var o = /^([a-z0-9.+-]+:)/i,
            l = /:[0-9]*$/,
            c = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
            h = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]),
            d = ["'"].concat(h),
            f = ["%", "/", "?", ";", "#"].concat(d),
            m = ["/", "?", "#"],
            v = /^[+a-z0-9A-Z_-]{0,63}$/,
            y = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
            _ = {
                javascript: !0,
                "javascript:": !0
            },
            x = {
                http: !0,
                https: !0,
                ftp: !0,
                gopher: !0,
                file: !0,
                "http:": !0,
                "https:": !0,
                "ftp:": !0,
                "gopher:": !0,
                "file:": !0
            };
        r.prototype.parse = function(t, e) {
            var i, n, r, l, h, d = t;
            if (d = d.trim(), !e && 1 === t.split("#").length) {
                var w = c.exec(d);
                if (w) return this.pathname = w[1], w[2] && (this.search = w[2]), this
            }
            var M = o.exec(d);
            if (M && (r = (M = M[0]).toLowerCase(), this.protocol = M, d = d.substr(M.length)), (e || M || d.match(/^\/\/[^@\/]+@[^@\/]+/)) && (!(h = "//" === d.substr(0, 2)) || M && _[M] || (d = d.substr(2), this.slashes = !0)), !_[M] && (h || M && !x[M])) {
                var S, T, E = -1;
                for (i = 0; i < m.length; i++) - 1 !== (l = d.indexOf(m[i])) && (-1 === E || l < E) && (E = l);
                for (-1 !== (T = -1 === E ? d.lastIndexOf("@") : d.lastIndexOf("@", E)) && (S = d.slice(0, T), d = d.slice(T + 1), this.auth = S), E = -1, i = 0; i < f.length; i++) - 1 !== (l = d.indexOf(f[i])) && (-1 === E || l < E) && (E = l); - 1 === E && (E = d.length), ":" === d[E - 1] && E--;
                var A = d.slice(0, E);
                d = d.slice(E), this.parseHost(A), this.hostname = this.hostname || "";
                var C = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
                if (!C) {
                    var L = this.hostname.split(/\./);
                    for (i = 0, n = L.length; i < n; i++) {
                        var k = L[i];
                        if (k && !k.match(v)) {
                            for (var R = "", P = 0, D = k.length; P < D; P++) k.charCodeAt(P) > 127 ? R += "x" : R += k[P];
                            if (!R.match(v)) {
                                var O = L.slice(0, i),
                                    I = L.slice(i + 1),
                                    N = k.match(y);
                                N && (O.push(N[1]), I.unshift(N[2])), I.length && (d = I.join(".") + d), this.hostname = O.join(".");
                                break
                            }
                        }
                    }
                }
                this.hostname.length > 255 && (this.hostname = ""), C && (this.hostname = this.hostname.substr(1, this.hostname.length - 2))
            }
            var F = d.indexOf("#"); - 1 !== F && (this.hash = d.substr(F), d = d.slice(0, F));
            var z = d.indexOf("?");
            return -1 !== z && (this.search = d.substr(z), d = d.slice(0, z)), d && (this.pathname = d), x[r] && this.hostname && !this.pathname && (this.pathname = ""), this
        }, r.prototype.parseHost = function(t) {
            var e = l.exec(t);
            e && (":" !== (e = e[0]) && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t)
        }, t.exports = function(t, e) {
            if (t && t instanceof r) return t;
            var u = new r;
            return u.parse(t, e), u
        }
    }, function(t, e, n) {
        "use strict";
        e.Any = n(230), e.Cc = n(231), e.Cf = n(349), e.P = n(151), e.Z = n(232)
    }, function(t, e) {
        t.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/
    }, function(t, e, n) {
        "use strict";
        e.parseLinkLabel = n(351), e.parseLinkDestination = n(352), e.parseLinkTitle = n(353)
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t, e, n) {
            var r, o, marker, l, c = -1,
                h = t.posMax,
                d = t.pos;
            for (t.pos = e + 1, r = 1; t.pos < h;) {
                if (93 === (marker = t.src.charCodeAt(t.pos)) && 0 === --r) {
                    o = !0;
                    break
                }
                if (l = t.pos, t.md.inline.skipToken(t), 91 === marker)
                    if (l === t.pos - 1) r++;
                    else if (n) return t.pos = d, -1
            }
            return o && (c = t.pos), t.pos = d, c
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).isSpace,
            o = n(9).unescapeAll;
        t.exports = function(t, e, n) {
            var code, l, c = e,
                h = {
                    ok: !1,
                    pos: 0,
                    lines: 0,
                    str: ""
                };
            if (60 === t.charCodeAt(e)) {
                for (e++; e < n;) {
                    if (10 === (code = t.charCodeAt(e)) || r(code)) return h;
                    if (62 === code) return h.pos = e + 1, h.str = o(t.slice(c + 1, e)), h.ok = !0, h;
                    92 === code && e + 1 < n ? e += 2 : e++
                }
                return h
            }
            for (l = 0; e < n && 32 !== (code = t.charCodeAt(e)) && !(code < 32 || 127 === code);)
                if (92 === code && e + 1 < n) e += 2;
                else {
                    if (40 === code && l++, 41 === code) {
                        if (0 === l) break;
                        l--
                    }
                    e++
                }
            return c === e || 0 !== l || (h.str = o(t.slice(c, e)), h.lines = 0, h.pos = e, h.ok = !0), h
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).unescapeAll;
        t.exports = function(t, e, n) {
            var code, marker, o = 0,
                l = e,
                c = {
                    ok: !1,
                    pos: 0,
                    lines: 0,
                    str: ""
                };
            if (e >= n) return c;
            if (34 !== (marker = t.charCodeAt(e)) && 39 !== marker && 40 !== marker) return c;
            for (e++, 40 === marker && (marker = 41); e < n;) {
                if ((code = t.charCodeAt(e)) === marker) return c.pos = e + 1, c.lines = o, c.str = r(t.slice(l + 1, e)), c.ok = !0, c;
                10 === code ? o++ : 92 === code && e + 1 < n && (e++, 10 === t.charCodeAt(e) && o++), e++
            }
            return c
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).assign,
            o = n(9).unescapeAll,
            l = n(9).escapeHtml,
            c = {};

        function h() {
            this.rules = r({}, c)
        }
        c.code_inline = function(t, e, n, r, o) {
            var c = t[e];
            return "<code" + o.renderAttrs(c) + ">" + l(t[e].content) + "</code>"
        }, c.code_block = function(t, e, n, r, o) {
            var c = t[e];
            return "<pre" + o.renderAttrs(c) + "><code>" + l(t[e].content) + "</code></pre>\n"
        }, c.fence = function(t, e, n, r, c) {
            var h, i, d, f, m = t[e],
                v = m.info ? o(m.info).trim() : "",
                y = "";
            return v && (y = v.split(/\s+/g)[0]), 0 === (h = n.highlight && n.highlight(m.content, y) || l(m.content)).indexOf("<pre") ? h + "\n" : v ? (i = m.attrIndex("class"), d = m.attrs ? m.attrs.slice() : [], i < 0 ? d.push(["class", n.langPrefix + y]) : d[i][1] += " " + n.langPrefix + y, f = {
                attrs: d
            }, "<pre><code" + c.renderAttrs(f) + ">" + h + "</code></pre>\n") : "<pre><code" + c.renderAttrs(m) + ">" + h + "</code></pre>\n"
        }, c.image = function(t, e, n, r, o) {
            var l = t[e];
            return l.attrs[l.attrIndex("alt")][1] = o.renderInlineAsText(l.children, n, r), o.renderToken(t, e, n)
        }, c.hardbreak = function(t, e, n) {
            return n.xhtmlOut ? "<br />\n" : "<br>\n"
        }, c.softbreak = function(t, e, n) {
            return n.breaks ? n.xhtmlOut ? "<br />\n" : "<br>\n" : "\n"
        }, c.text = function(t, e) {
            return l(t[e].content)
        }, c.html_block = function(t, e) {
            return t[e].content
        }, c.html_inline = function(t, e) {
            return t[e].content
        }, h.prototype.renderAttrs = function(t) {
            var i, e, n;
            if (!t.attrs) return "";
            for (n = "", i = 0, e = t.attrs.length; i < e; i++) n += " " + l(t.attrs[i][0]) + '="' + l(t.attrs[i][1]) + '"';
            return n
        }, h.prototype.renderToken = function(t, e, n) {
            var r, o = "",
                l = !1,
                c = t[e];
            return c.hidden ? "" : (c.block && -1 !== c.nesting && e && t[e - 1].hidden && (o += "\n"), o += (-1 === c.nesting ? "</" : "<") + c.tag, o += this.renderAttrs(c), 0 === c.nesting && n.xhtmlOut && (o += " /"), c.block && (l = !0, 1 === c.nesting && e + 1 < t.length && ("inline" === (r = t[e + 1]).type || r.hidden || -1 === r.nesting && r.tag === c.tag) && (l = !1)), o += l ? ">\n" : ">")
        }, h.prototype.renderInline = function(t, e, n) {
            for (var r, o = "", l = this.rules, i = 0, c = t.length; i < c; i++) void 0 !== l[r = t[i].type] ? o += l[r](t, i, e, n, this) : o += this.renderToken(t, i, e);
            return o
        }, h.prototype.renderInlineAsText = function(t, e, n) {
            for (var r = "", i = 0, o = t.length; i < o; i++) "text" === t[i].type ? r += t[i].content : "image" === t[i].type && (r += this.renderInlineAsText(t[i].children, e, n));
            return r
        }, h.prototype.render = function(t, e, n) {
            var i, r, o, l = "",
                c = this.rules;
            for (i = 0, r = t.length; i < r; i++) "inline" === (o = t[i].type) ? l += this.renderInline(t[i].children, e, n) : void 0 !== c[o] ? l += c[t[i].type](t, i, e, n, this) : l += this.renderToken(t, i, e, n);
            return l
        }, t.exports = h
    }, function(t, e, n) {
        "use strict";
        var r = n(152),
            o = [
                ["normalize", n(356)],
                ["block", n(357)],
                ["inline", n(358)],
                ["linkify", n(359)],
                ["replacements", n(360)],
                ["smartquotes", n(361)]
            ];

        function l() {
            this.ruler = new r;
            for (var i = 0; i < o.length; i++) this.ruler.push(o[i][0], o[i][1])
        }
        l.prototype.process = function(t) {
            var i, e, n;
            for (i = 0, e = (n = this.ruler.getRules("")).length; i < e; i++) n[i](t)
        }, l.prototype.State = n(362), t.exports = l
    }, function(t, e, n) {
        "use strict";
        var r = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g,
            o = /\u0000/g;
        t.exports = function(t) {
            var e;
            e = (e = t.src.replace(r, "\n")).replace(o, ""), t.src = e
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t) {
            var e;
            t.inlineMode ? ((e = new t.Token("inline", "", 0)).content = t.src, e.map = [0, 1], e.children = [], t.tokens.push(e)) : t.md.block.parse(t.src, t.md, t.env, t.tokens)
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t) {
            var e, i, n, r = t.tokens;
            for (i = 0, n = r.length; i < n; i++) "inline" === (e = r[i]).type && t.md.inline.parse(e.content, t.md, t.env, e.children)
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).arrayReplaceAt;

        function o(t) {
            return /^<\/a\s*>/i.test(t)
        }
        t.exports = function(t) {
            var i, e, n, l, c, h, d, f, text, m, v, y, _, x, w, M, S, T, E = t.tokens;
            if (t.md.options.linkify)
                for (e = 0, n = E.length; e < n; e++)
                    if ("inline" === E[e].type && t.md.linkify.pretest(E[e].content))
                        for (_ = 0, i = (l = E[e].children).length - 1; i >= 0; i--)
                            if ("link_close" !== (h = l[i]).type) {
                                if ("html_inline" === h.type && (T = h.content, /^<a[>\s]/i.test(T) && _ > 0 && _--, o(h.content) && _++), !(_ > 0) && "text" === h.type && t.md.linkify.test(h.content)) {
                                    for (text = h.content, S = t.md.linkify.match(text), d = [], y = h.level, v = 0, f = 0; f < S.length; f++) x = S[f].url, w = t.md.normalizeLink(x), t.md.validateLink(w) && (M = S[f].text, M = S[f].schema ? "mailto:" !== S[f].schema || /^mailto:/i.test(M) ? t.md.normalizeLinkText(M) : t.md.normalizeLinkText("mailto:" + M).replace(/^mailto:/, "") : t.md.normalizeLinkText("http://" + M).replace(/^http:\/\//, ""), (m = S[f].index) > v && ((c = new t.Token("text", "", 0)).content = text.slice(v, m), c.level = y, d.push(c)), (c = new t.Token("link_open", "a", 1)).attrs = [
                                        ["href", w]
                                    ], c.level = y++, c.markup = "linkify", c.info = "auto", d.push(c), (c = new t.Token("text", "", 0)).content = M, c.level = y, d.push(c), (c = new t.Token("link_close", "a", -1)).level = --y, c.markup = "linkify", c.info = "auto", d.push(c), v = S[f].lastIndex);
                                    v < text.length && ((c = new t.Token("text", "", 0)).content = text.slice(v), c.level = y, d.push(c)), E[e].children = l = r(l, i, d)
                                }
                            } else
                                for (i--; l[i].level !== h.level && "link_open" !== l[i].type;) i--
        }
    }, function(t, e, n) {
        "use strict";
        var r = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/,
            o = /\((c|tm|r|p)\)/i,
            l = /\((c|tm|r|p)\)/gi,
            c = {
                c: "",
                r: "",
                p: "",
                tm: ""
            };

        function h(t, e) {
            return c[e.toLowerCase()]
        }

        function d(t) {
            var i, e, n = 0;
            for (i = t.length - 1; i >= 0; i--) "text" !== (e = t[i]).type || n || (e.content = e.content.replace(l, h)), "link_open" === e.type && "auto" === e.info && n--, "link_close" === e.type && "auto" === e.info && n++
        }

        function f(t) {
            var i, e, n = 0;
            for (i = t.length - 1; i >= 0; i--) "text" !== (e = t[i]).type || n || r.test(e.content) && (e.content = e.content.replace(/\+-/g, "").replace(/\.{2,}/g, "").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---([^-]|$)/gm, "$1$2").replace(/(^|\s)--(\s|$)/gm, "$1$2").replace(/(^|[^-\s])--([^-\s]|$)/gm, "$1$2")), "link_open" === e.type && "auto" === e.info && n--, "link_close" === e.type && "auto" === e.info && n++
        }
        t.exports = function(t) {
            var e;
            if (t.md.options.typographer)
                for (e = t.tokens.length - 1; e >= 0; e--) "inline" === t.tokens[e].type && (o.test(t.tokens[e].content) && d(t.tokens[e].children), r.test(t.tokens[e].content) && f(t.tokens[e].children))
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).isWhiteSpace,
            o = n(9).isPunctChar,
            l = n(9).isMdAsciiPunct,
            c = /['"]/,
            h = /['"]/g;

        function d(t, e, n) {
            return t.substr(0, e) + n + t.substr(e + 1)
        }

        function f(t, e) {
            var i, n, text, c, f, m, v, y, _, x, w, M, S, T, E, A, C, L, k, R, P;
            for (k = [], i = 0; i < t.length; i++) {
                for (n = t[i], v = t[i].level, C = k.length - 1; C >= 0 && !(k[C].level <= v); C--);
                if (k.length = C + 1, "text" === n.type) {
                    f = 0, m = (text = n.content).length;
                    t: for (; f < m && (h.lastIndex = f, c = h.exec(text));) {
                        if (E = A = !0, f = c.index + 1, L = "'" === c[0], _ = 32, c.index - 1 >= 0) _ = text.charCodeAt(c.index - 1);
                        else
                            for (C = i - 1; C >= 0 && ("softbreak" !== t[C].type && "hardbreak" !== t[C].type); C--)
                                if ("text" === t[C].type) {
                                    _ = t[C].content.charCodeAt(t[C].content.length - 1);
                                    break
                                } if (x = 32, f < m) x = text.charCodeAt(f);
                        else
                            for (C = i + 1; C < t.length && ("softbreak" !== t[C].type && "hardbreak" !== t[C].type); C++)
                                if ("text" === t[C].type) {
                                    x = t[C].content.charCodeAt(0);
                                    break
                                } if (w = l(_) || o(String.fromCharCode(_)), M = l(x) || o(String.fromCharCode(x)), S = r(_), (T = r(x)) ? E = !1 : M && (S || w || (E = !1)), S ? A = !1 : w && (T || M || (A = !1)), 34 === x && '"' === c[0] && _ >= 48 && _ <= 57 && (A = E = !1), E && A && (E = !1, A = M), E || A) {
                            if (A)
                                for (C = k.length - 1; C >= 0 && (y = k[C], !(k[C].level < v)); C--)
                                    if (y.single === L && k[C].level === v) {
                                        y = k[C], L ? (R = e.md.options.quotes[2], P = e.md.options.quotes[3]) : (R = e.md.options.quotes[0], P = e.md.options.quotes[1]), n.content = d(n.content, c.index, P), t[y.token].content = d(t[y.token].content, y.pos, R), f += P.length - 1, y.token === i && (f += R.length - 1), m = (text = n.content).length, k.length = C;
                                        continue t
                                    }
                            E ? k.push({
                                token: i,
                                pos: c.index,
                                single: L,
                                level: v
                            }) : A && L && (n.content = d(n.content, c.index, ""))
                        } else L && (n.content = d(n.content, c.index, ""))
                    }
                }
            }
        }
        t.exports = function(t) {
            var e;
            if (t.md.options.typographer)
                for (e = t.tokens.length - 1; e >= 0; e--) "inline" === t.tokens[e].type && c.test(t.tokens[e].content) && f(t.tokens[e].children, t)
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(153);

        function o(t, e, n) {
            this.src = t, this.env = n, this.tokens = [], this.inlineMode = !1, this.md = e
        }
        o.prototype.Token = r, t.exports = o
    }, function(t, e, n) {
        "use strict";
        var r = n(152),
            o = [
                ["table", n(364), ["paragraph", "reference"]],
                ["code", n(365)],
                ["fence", n(366), ["paragraph", "reference", "blockquote", "list"]],
                ["blockquote", n(367), ["paragraph", "reference", "blockquote", "list"]],
                ["hr", n(368), ["paragraph", "reference", "blockquote", "list"]],
                ["list", n(369), ["paragraph", "reference", "blockquote"]],
                ["reference", n(370)],
                ["heading", n(371), ["paragraph", "reference", "blockquote"]],
                ["lheading", n(372)],
                ["html_block", n(373), ["paragraph", "reference", "blockquote"]],
                ["paragraph", n(375)]
            ];

        function l() {
            this.ruler = new r;
            for (var i = 0; i < o.length; i++) this.ruler.push(o[i][0], o[i][1], {
                alt: (o[i][2] || []).slice()
            })
        }
        l.prototype.tokenize = function(t, e, n) {
            for (var i, r = this.ruler.getRules(""), o = r.length, line = e, l = !1, c = t.md.options.maxNesting; line < n && (t.line = line = t.skipEmptyLines(line), !(line >= n)) && !(t.sCount[line] < t.blkIndent);) {
                if (t.level >= c) {
                    t.line = n;
                    break
                }
                for (i = 0; i < o && !r[i](t, line, n, !1); i++);
                t.tight = !l, t.isEmpty(t.line - 1) && (l = !0), (line = t.line) < n && t.isEmpty(line) && (l = !0, line++, t.line = line)
            }
        }, l.prototype.parse = function(t, e, n, r) {
            var o;
            t && (o = new this.State(t, e, n, r), this.tokenize(o, o.line, o.lineMax))
        }, l.prototype.State = n(376), t.exports = l
    }, function(t, e, n) {
        "use strict";
        var r = n(9).isSpace;

        function o(t, line) {
            var e = t.bMarks[line] + t.blkIndent,
                n = t.eMarks[line];
            return t.src.substr(e, n - e)
        }

        function l(t) {
            var e, n = [],
                r = 0,
                o = t.length,
                l = 0,
                c = 0,
                h = !1,
                d = 0;
            for (e = t.charCodeAt(r); r < o;) 96 === e ? h ? (h = !1, d = r) : l % 2 == 0 && (h = !0, d = r) : 124 !== e || l % 2 != 0 || h || (n.push(t.substring(c, r)), c = r + 1), 92 === e ? l++ : l = 0, ++r === o && h && (h = !1, r = d + 1), e = t.charCodeAt(r);
            return n.push(t.substring(c)), n
        }
        t.exports = function(t, e, n, c) {
            var h, d, f, i, m, v, y, _, x, w, M, S;
            if (e + 2 > n) return !1;
            if (m = e + 1, t.sCount[m] < t.blkIndent) return !1;
            if (t.sCount[m] - t.blkIndent >= 4) return !1;
            if ((f = t.bMarks[m] + t.tShift[m]) >= t.eMarks[m]) return !1;
            if (124 !== (h = t.src.charCodeAt(f++)) && 45 !== h && 58 !== h) return !1;
            for (; f < t.eMarks[m];) {
                if (124 !== (h = t.src.charCodeAt(f)) && 45 !== h && 58 !== h && !r(h)) return !1;
                f++
            }
            for (v = (d = o(t, e + 1)).split("|"), x = [], i = 0; i < v.length; i++) {
                if (!(w = v[i].trim())) {
                    if (0 === i || i === v.length - 1) continue;
                    return !1
                }
                if (!/^:?-+:?$/.test(w)) return !1;
                58 === w.charCodeAt(w.length - 1) ? x.push(58 === w.charCodeAt(0) ? "center" : "right") : 58 === w.charCodeAt(0) ? x.push("left") : x.push("")
            }
            if (-1 === (d = o(t, e).trim()).indexOf("|")) return !1;
            if (t.sCount[e] - t.blkIndent >= 4) return !1;
            if ((y = (v = l(d.replace(/^\||\|$/g, ""))).length) > x.length) return !1;
            if (c) return !0;
            for ((_ = t.push("table_open", "table", 1)).map = M = [e, 0], (_ = t.push("thead_open", "thead", 1)).map = [e, e + 1], (_ = t.push("tr_open", "tr", 1)).map = [e, e + 1], i = 0; i < v.length; i++)(_ = t.push("th_open", "th", 1)).map = [e, e + 1], x[i] && (_.attrs = [
                ["style", "text-align:" + x[i]]
            ]), (_ = t.push("inline", "", 0)).content = v[i].trim(), _.map = [e, e + 1], _.children = [], _ = t.push("th_close", "th", -1);
            for (_ = t.push("tr_close", "tr", -1), _ = t.push("thead_close", "thead", -1), (_ = t.push("tbody_open", "tbody", 1)).map = S = [e + 2, 0], m = e + 2; m < n && !(t.sCount[m] < t.blkIndent) && -1 !== (d = o(t, m).trim()).indexOf("|") && !(t.sCount[m] - t.blkIndent >= 4); m++) {
                for (v = l(d.replace(/^\||\|$/g, "")), _ = t.push("tr_open", "tr", 1), i = 0; i < y; i++) _ = t.push("td_open", "td", 1), x[i] && (_.attrs = [
                    ["style", "text-align:" + x[i]]
                ]), (_ = t.push("inline", "", 0)).content = v[i] ? v[i].trim() : "", _.children = [], _ = t.push("td_close", "td", -1);
                _ = t.push("tr_close", "tr", -1)
            }
            return _ = t.push("tbody_close", "tbody", -1), _ = t.push("table_close", "table", -1), M[1] = S[1] = m, t.line = m, !0
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t, e, n) {
            var r, o, l;
            if (t.sCount[e] - t.blkIndent < 4) return !1;
            for (o = r = e + 1; r < n;)
                if (t.isEmpty(r)) r++;
                else {
                    if (!(t.sCount[r] - t.blkIndent >= 4)) break;
                    o = ++r
                }
            return t.line = o, (l = t.push("code_block", "code", 0)).content = t.getLines(e, o, 4 + t.blkIndent, !0), l.map = [e, t.line], !0
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t, e, n, r) {
            var marker, o, l, c, h, d, f, m = !1,
                v = t.bMarks[e] + t.tShift[e],
                y = t.eMarks[e];
            if (t.sCount[e] - t.blkIndent >= 4) return !1;
            if (v + 3 > y) return !1;
            if (126 !== (marker = t.src.charCodeAt(v)) && 96 !== marker) return !1;
            if (h = v, (o = (v = t.skipChars(v, marker)) - h) < 3) return !1;
            if (f = t.src.slice(h, v), (l = t.src.slice(v, y)).indexOf(String.fromCharCode(marker)) >= 0) return !1;
            if (r) return !0;
            for (c = e; !(++c >= n) && !((v = h = t.bMarks[c] + t.tShift[c]) < (y = t.eMarks[c]) && t.sCount[c] < t.blkIndent);)
                if (t.src.charCodeAt(v) === marker && !(t.sCount[c] - t.blkIndent >= 4 || (v = t.skipChars(v, marker)) - h < o || (v = t.skipSpaces(v)) < y)) {
                    m = !0;
                    break
                }
            return o = t.sCount[e], t.line = c + (m ? 1 : 0), (d = t.push("fence", "code", 0)).info = l, d.content = t.getLines(e + 1, c, o, !0), d.markup = f, d.map = [e, t.line], !0
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).isSpace;
        t.exports = function(t, e, n, o) {
            var l, c, i, h, d, f, m, v, y, _, x, w, M, S, T, E, A, C, L, k, R = t.lineMax,
                P = t.bMarks[e] + t.tShift[e],
                D = t.eMarks[e];
            if (t.sCount[e] - t.blkIndent >= 4) return !1;
            if (62 !== t.src.charCodeAt(P++)) return !1;
            if (o) return !0;
            for (h = y = t.sCount[e] + P - (t.bMarks[e] + t.tShift[e]), 32 === t.src.charCodeAt(P) ? (P++, h++, y++, l = !1, E = !0) : 9 === t.src.charCodeAt(P) ? (E = !0, (t.bsCount[e] + y) % 4 == 3 ? (P++, h++, y++, l = !1) : l = !0) : E = !1, _ = [t.bMarks[e]], t.bMarks[e] = P; P < D && (c = t.src.charCodeAt(P), r(c));) 9 === c ? y += 4 - (y + t.bsCount[e] + (l ? 1 : 0)) % 4 : y++, P++;
            for (x = [t.bsCount[e]], t.bsCount[e] = t.sCount[e] + 1 + (E ? 1 : 0), f = P >= D, S = [t.sCount[e]], t.sCount[e] = y - h, T = [t.tShift[e]], t.tShift[e] = P - t.bMarks[e], C = t.md.block.ruler.getRules("blockquote"), M = t.parentType, t.parentType = "blockquote", k = !1, v = e + 1; v < n && (t.sCount[v] < t.blkIndent && (k = !0), !((P = t.bMarks[v] + t.tShift[v]) >= (D = t.eMarks[v]))); v++)
                if (62 !== t.src.charCodeAt(P++) || k) {
                    if (f) break;
                    for (A = !1, i = 0, d = C.length; i < d; i++)
                        if (C[i](t, v, n, !0)) {
                            A = !0;
                            break
                        }
                    if (A) {
                        t.lineMax = v, 0 !== t.blkIndent && (_.push(t.bMarks[v]), x.push(t.bsCount[v]), T.push(t.tShift[v]), S.push(t.sCount[v]), t.sCount[v] -= t.blkIndent);
                        break
                    }
                    _.push(t.bMarks[v]), x.push(t.bsCount[v]), T.push(t.tShift[v]), S.push(t.sCount[v]), t.sCount[v] = -1
                } else {
                    for (h = y = t.sCount[v] + P - (t.bMarks[v] + t.tShift[v]), 32 === t.src.charCodeAt(P) ? (P++, h++, y++, l = !1, E = !0) : 9 === t.src.charCodeAt(P) ? (E = !0, (t.bsCount[v] + y) % 4 == 3 ? (P++, h++, y++, l = !1) : l = !0) : E = !1, _.push(t.bMarks[v]), t.bMarks[v] = P; P < D && (c = t.src.charCodeAt(P), r(c));) 9 === c ? y += 4 - (y + t.bsCount[v] + (l ? 1 : 0)) % 4 : y++, P++;
                    f = P >= D, x.push(t.bsCount[v]), t.bsCount[v] = t.sCount[v] + 1 + (E ? 1 : 0), S.push(t.sCount[v]), t.sCount[v] = y - h, T.push(t.tShift[v]), t.tShift[v] = P - t.bMarks[v]
                }
            for (w = t.blkIndent, t.blkIndent = 0, (L = t.push("blockquote_open", "blockquote", 1)).markup = ">", L.map = m = [e, 0], t.md.block.tokenize(t, e, v), (L = t.push("blockquote_close", "blockquote", -1)).markup = ">", t.lineMax = R, t.parentType = M, m[1] = t.line, i = 0; i < T.length; i++) t.bMarks[i + e] = _[i], t.tShift[i + e] = T[i], t.sCount[i + e] = S[i], t.bsCount[i + e] = x[i];
            return t.blkIndent = w, !0
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).isSpace;
        t.exports = function(t, e, n, o) {
            var marker, l, c, h, d = t.bMarks[e] + t.tShift[e],
                f = t.eMarks[e];
            if (t.sCount[e] - t.blkIndent >= 4) return !1;
            if (42 !== (marker = t.src.charCodeAt(d++)) && 45 !== marker && 95 !== marker) return !1;
            for (l = 1; d < f;) {
                if ((c = t.src.charCodeAt(d++)) !== marker && !r(c)) return !1;
                c === marker && l++
            }
            return !(l < 3) && (o || (t.line = e + 1, (h = t.push("hr", "hr", 0)).map = [e, t.line], h.markup = Array(l + 1).join(String.fromCharCode(marker))), !0)
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).isSpace;

        function o(t, e) {
            var marker, n, o, l;
            return n = t.bMarks[e] + t.tShift[e], o = t.eMarks[e], 42 !== (marker = t.src.charCodeAt(n++)) && 45 !== marker && 43 !== marker || n < o && (l = t.src.charCodeAt(n), !r(l)) ? -1 : n
        }

        function l(t, e) {
            var n, o = t.bMarks[e] + t.tShift[e],
                l = o,
                c = t.eMarks[e];
            if (l + 1 >= c) return -1;
            if ((n = t.src.charCodeAt(l++)) < 48 || n > 57) return -1;
            for (;;) {
                if (l >= c) return -1;
                if (!((n = t.src.charCodeAt(l++)) >= 48 && n <= 57)) {
                    if (41 === n || 46 === n) break;
                    return -1
                }
                if (l - o >= 10) return -1
            }
            return l < c && (n = t.src.charCodeAt(l), !r(n)) ? -1 : l
        }
        t.exports = function(t, e, n, r) {
            var c, h, i, d, f, m, v, y, _, x, w, M, S, T, E, A, C, L, k, R, P, D, O, I, N, F, z, B, U = !1,
                H = !0;
            if (t.sCount[e] - t.blkIndent >= 4) return !1;
            if (r && "paragraph" === t.parentType && t.tShift[e] >= t.blkIndent && (U = !0), (O = l(t, e)) >= 0) {
                if (v = !0, N = t.bMarks[e] + t.tShift[e], S = Number(t.src.substr(N, O - N - 1)), U && 1 !== S) return !1
            } else {
                if (!((O = o(t, e)) >= 0)) return !1;
                v = !1
            }
            if (U && t.skipSpaces(O) >= t.eMarks[e]) return !1;
            if (M = t.src.charCodeAt(O - 1), r) return !0;
            for (w = t.tokens.length, v ? (B = t.push("ordered_list_open", "ol", 1), 1 !== S && (B.attrs = [
                    ["start", S]
                ])) : B = t.push("bullet_list_open", "ul", 1), B.map = x = [e, 0], B.markup = String.fromCharCode(M), E = e, I = !1, z = t.md.block.ruler.getRules("list"), k = t.parentType, t.parentType = "list"; E < n;) {
                for (D = O, T = t.eMarks[E], m = A = t.sCount[E] + O - (t.bMarks[e] + t.tShift[e]); D < T;) {
                    if (9 === (c = t.src.charCodeAt(D))) A += 4 - (A + t.bsCount[E]) % 4;
                    else {
                        if (32 !== c) break;
                        A++
                    }
                    D++
                }
                if ((f = (h = D) >= T ? 1 : A - m) > 4 && (f = 1), d = m + f, (B = t.push("list_item_open", "li", 1)).markup = String.fromCharCode(M), B.map = y = [e, 0], C = t.blkIndent, P = t.tight, R = t.tShift[e], L = t.sCount[e], t.blkIndent = d, t.tight = !0, t.tShift[e] = h - t.bMarks[e], t.sCount[e] = A, h >= T && t.isEmpty(e + 1) ? t.line = Math.min(t.line + 2, n) : t.md.block.tokenize(t, e, n, !0), t.tight && !I || (H = !1), I = t.line - e > 1 && t.isEmpty(t.line - 1), t.blkIndent = C, t.tShift[e] = R, t.sCount[e] = L, t.tight = P, (B = t.push("list_item_close", "li", -1)).markup = String.fromCharCode(M), E = e = t.line, y[1] = E, h = t.bMarks[e], E >= n) break;
                if (t.sCount[E] < t.blkIndent) break;
                for (F = !1, i = 0, _ = z.length; i < _; i++)
                    if (z[i](t, E, n, !0)) {
                        F = !0;
                        break
                    }
                if (F) break;
                if (v) {
                    if ((O = l(t, E)) < 0) break
                } else if ((O = o(t, E)) < 0) break;
                if (M !== t.src.charCodeAt(O - 1)) break
            }
            return (B = v ? t.push("ordered_list_close", "ol", -1) : t.push("bullet_list_close", "ul", -1)).markup = String.fromCharCode(M), x[1] = E, t.line = E, t.parentType = k, H && function(t, e) {
                var i, n, r = t.level + 2;
                for (i = e + 2, n = t.tokens.length - 2; i < n; i++) t.tokens[i].level === r && "paragraph_open" === t.tokens[i].type && (t.tokens[i + 2].hidden = !0, t.tokens[i].hidden = !0, i += 2)
            }(t, w), !0
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).normalizeReference,
            o = n(9).isSpace;
        t.exports = function(t, e, n, l) {
            var c, h, d, f, m, i, v, label, y, _, x, w, M, S, T, title, E = 0,
                A = t.bMarks[e] + t.tShift[e],
                C = t.eMarks[e],
                L = e + 1;
            if (t.sCount[e] - t.blkIndent >= 4) return !1;
            if (91 !== t.src.charCodeAt(A)) return !1;
            for (; ++A < C;)
                if (93 === t.src.charCodeAt(A) && 92 !== t.src.charCodeAt(A - 1)) {
                    if (A + 1 === C) return !1;
                    if (58 !== t.src.charCodeAt(A + 1)) return !1;
                    break
                }
            for (f = t.lineMax, T = t.md.block.ruler.getRules("reference"), _ = t.parentType, t.parentType = "reference"; L < f && !t.isEmpty(L); L++)
                if (!(t.sCount[L] - t.blkIndent > 3 || t.sCount[L] < 0)) {
                    for (S = !1, i = 0, v = T.length; i < v; i++)
                        if (T[i](t, L, f, !0)) {
                            S = !0;
                            break
                        }
                    if (S) break
                }
            for (C = (M = t.getLines(e, L, t.blkIndent, !1).trim()).length, A = 1; A < C; A++) {
                if (91 === (c = M.charCodeAt(A))) return !1;
                if (93 === c) {
                    y = A;
                    break
                }(10 === c || 92 === c && ++A < C && 10 === M.charCodeAt(A)) && E++
            }
            if (y < 0 || 58 !== M.charCodeAt(y + 1)) return !1;
            for (A = y + 2; A < C; A++)
                if (10 === (c = M.charCodeAt(A))) E++;
                else if (!o(c)) break;
            if (!(x = t.md.helpers.parseLinkDestination(M, A, C)).ok) return !1;
            if (m = t.md.normalizeLink(x.str), !t.md.validateLink(m)) return !1;
            for (h = A = x.pos, d = E += x.lines, w = A; A < C; A++)
                if (10 === (c = M.charCodeAt(A))) E++;
                else if (!o(c)) break;
            for (x = t.md.helpers.parseLinkTitle(M, A, C), A < C && w !== A && x.ok ? (title = x.str, A = x.pos, E += x.lines) : (title = "", A = h, E = d); A < C && (c = M.charCodeAt(A), o(c));) A++;
            if (A < C && 10 !== M.charCodeAt(A) && title)
                for (title = "", A = h, E = d; A < C && (c = M.charCodeAt(A), o(c));) A++;
            return !(A < C && 10 !== M.charCodeAt(A)) && (!!(label = r(M.slice(1, y))) && (l || (void 0 === t.env.references && (t.env.references = {}), void 0 === t.env.references[label] && (t.env.references[label] = {
                title: title,
                href: m
            }), t.parentType = _, t.line = e + E + 1), !0))
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).isSpace;
        t.exports = function(t, e, n, o) {
            var l, c, h, d, f = t.bMarks[e] + t.tShift[e],
                m = t.eMarks[e];
            if (t.sCount[e] - t.blkIndent >= 4) return !1;
            if (35 !== (l = t.src.charCodeAt(f)) || f >= m) return !1;
            for (c = 1, l = t.src.charCodeAt(++f); 35 === l && f < m && c <= 6;) c++, l = t.src.charCodeAt(++f);
            return !(c > 6 || f < m && !r(l)) && (o || (m = t.skipSpacesBack(m, f), (h = t.skipCharsBack(m, 35, f)) > f && r(t.src.charCodeAt(h - 1)) && (m = h), t.line = e + 1, (d = t.push("heading_open", "h" + String(c), 1)).markup = "########".slice(0, c), d.map = [e, t.line], (d = t.push("inline", "", 0)).content = t.src.slice(f, m).trim(), d.map = [e, t.line], d.children = [], (d = t.push("heading_close", "h" + String(c), -1)).markup = "########".slice(0, c)), !0)
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t, e, n) {
            var content, r, i, o, l, c, h, d, marker, f, m = e + 1,
                v = t.md.block.ruler.getRules("paragraph");
            if (t.sCount[e] - t.blkIndent >= 4) return !1;
            for (f = t.parentType, t.parentType = "paragraph"; m < n && !t.isEmpty(m); m++)
                if (!(t.sCount[m] - t.blkIndent > 3)) {
                    if (t.sCount[m] >= t.blkIndent && (c = t.bMarks[m] + t.tShift[m]) < (h = t.eMarks[m]) && (45 === (marker = t.src.charCodeAt(c)) || 61 === marker) && (c = t.skipChars(c, marker), (c = t.skipSpaces(c)) >= h)) {
                        d = 61 === marker ? 1 : 2;
                        break
                    }
                    if (!(t.sCount[m] < 0)) {
                        for (r = !1, i = 0, o = v.length; i < o; i++)
                            if (v[i](t, m, n, !0)) {
                                r = !0;
                                break
                            }
                        if (r) break
                    }
                }
            return !!d && (content = t.getLines(e, m, t.blkIndent, !1).trim(), t.line = m + 1, (l = t.push("heading_open", "h" + String(d), 1)).markup = String.fromCharCode(marker), l.map = [e, t.line], (l = t.push("inline", "", 0)).content = content, l.map = [e, t.line - 1], l.children = [], (l = t.push("heading_close", "h" + String(d), -1)).markup = String.fromCharCode(marker), t.parentType = f, !0)
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(374),
            o = n(233).HTML_OPEN_CLOSE_TAG_RE,
            l = [
                [/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, !0],
                [/^<!--/, /-->/, !0],
                [/^<\?/, /\?>/, !0],
                [/^<![A-Z]/, />/, !0],
                [/^<!\[CDATA\[/, /\]\]>/, !0],
                [new RegExp("^</?(" + r.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
                [new RegExp(o.source + "\\s*$"), /^$/, !1]
            ];
        t.exports = function(t, e, n, r) {
            var i, o, c, h, d = t.bMarks[e] + t.tShift[e],
                f = t.eMarks[e];
            if (t.sCount[e] - t.blkIndent >= 4) return !1;
            if (!t.md.options.html) return !1;
            if (60 !== t.src.charCodeAt(d)) return !1;
            for (h = t.src.slice(d, f), i = 0; i < l.length && !l[i][0].test(h); i++);
            if (i === l.length) return !1;
            if (r) return l[i][2];
            if (o = e + 1, !l[i][1].test(h))
                for (; o < n && !(t.sCount[o] < t.blkIndent); o++)
                    if (d = t.bMarks[o] + t.tShift[o], f = t.eMarks[o], h = t.src.slice(d, f), l[i][1].test(h)) {
                        0 !== h.length && o++;
                        break
                    }
            return t.line = o, (c = t.push("html_block", "", 0)).map = [e, o], c.content = t.getLines(e, o, t.blkIndent, !0), !0
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "meta", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "section", "source", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"]
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t, e) {
            var content, n, i, r, o, l, c = e + 1,
                h = t.md.block.ruler.getRules("paragraph"),
                d = t.lineMax;
            for (l = t.parentType, t.parentType = "paragraph"; c < d && !t.isEmpty(c); c++)
                if (!(t.sCount[c] - t.blkIndent > 3 || t.sCount[c] < 0)) {
                    for (n = !1, i = 0, r = h.length; i < r; i++)
                        if (h[i](t, c, d, !0)) {
                            n = !0;
                            break
                        }
                    if (n) break
                }
            return content = t.getLines(e, c, t.blkIndent, !1).trim(), t.line = c, (o = t.push("paragraph_open", "p", 1)).map = [e, t.line], (o = t.push("inline", "", 0)).content = content, o.map = [e, t.line], o.children = [], o = t.push("paragraph_close", "p", -1), t.parentType = l, !0
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(153),
            o = n(9).isSpace;

        function l(t, e, n, r) {
            var l, s, c, h, d, f, m, v;
            for (this.src = t, this.md = e, this.env = n, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.parentType = "root", this.level = 0, this.result = "", v = !1, c = h = f = m = 0, d = (s = this.src).length; h < d; h++) {
                if (l = s.charCodeAt(h), !v) {
                    if (o(l)) {
                        f++, 9 === l ? m += 4 - m % 4 : m++;
                        continue
                    }
                    v = !0
                }
                10 !== l && h !== d - 1 || (10 !== l && h++, this.bMarks.push(c), this.eMarks.push(h), this.tShift.push(f), this.sCount.push(m), this.bsCount.push(0), v = !1, f = 0, m = 0, c = h + 1)
            }
            this.bMarks.push(s.length), this.eMarks.push(s.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1
        }
        l.prototype.push = function(t, e, n) {
            var o = new r(t, e, n);
            return o.block = !0, n < 0 && this.level--, o.level = this.level, n > 0 && this.level++, this.tokens.push(o), o
        }, l.prototype.isEmpty = function(line) {
            return this.bMarks[line] + this.tShift[line] >= this.eMarks[line]
        }, l.prototype.skipEmptyLines = function(t) {
            for (var e = this.lineMax; t < e && !(this.bMarks[t] + this.tShift[t] < this.eMarks[t]); t++);
            return t
        }, l.prototype.skipSpaces = function(t) {
            for (var e, n = this.src.length; t < n && (e = this.src.charCodeAt(t), o(e)); t++);
            return t
        }, l.prototype.skipSpacesBack = function(t, e) {
            if (t <= e) return t;
            for (; t > e;)
                if (!o(this.src.charCodeAt(--t))) return t + 1;
            return t
        }, l.prototype.skipChars = function(t, code) {
            for (var e = this.src.length; t < e && this.src.charCodeAt(t) === code; t++);
            return t
        }, l.prototype.skipCharsBack = function(t, code, e) {
            if (t <= e) return t;
            for (; t > e;)
                if (code !== this.src.charCodeAt(--t)) return t + 1;
            return t
        }, l.prototype.getLines = function(t, e, n, r) {
            var i, l, c, h, d, f, m, line = t;
            if (t >= e) return "";
            for (f = new Array(e - t), i = 0; line < e; line++, i++) {
                for (l = 0, m = h = this.bMarks[line], d = line + 1 < e || r ? this.eMarks[line] + 1 : this.eMarks[line]; h < d && l < n;) {
                    if (c = this.src.charCodeAt(h), o(c)) 9 === c ? l += 4 - (l + this.bsCount[line]) % 4 : l++;
                    else {
                        if (!(h - m < this.tShift[line])) break;
                        l++
                    }
                    h++
                }
                f[i] = l > n ? new Array(l - n + 1).join(" ") + this.src.slice(h, d) : this.src.slice(h, d)
            }
            return f.join("")
        }, l.prototype.Token = r, t.exports = l
    }, function(t, e, n) {
        "use strict";
        var r = n(152),
            o = [
                ["text", n(378)],
                ["newline", n(379)],
                ["escape", n(380)],
                ["backticks", n(381)],
                ["strikethrough", n(234).tokenize],
                ["emphasis", n(235).tokenize],
                ["link", n(382)],
                ["image", n(383)],
                ["autolink", n(384)],
                ["html_inline", n(385)],
                ["entity", n(386)]
            ],
            l = [
                ["balance_pairs", n(387)],
                ["strikethrough", n(234).postProcess],
                ["emphasis", n(235).postProcess],
                ["text_collapse", n(388)]
            ];

        function c() {
            var i;
            for (this.ruler = new r, i = 0; i < o.length; i++) this.ruler.push(o[i][0], o[i][1]);
            for (this.ruler2 = new r, i = 0; i < l.length; i++) this.ruler2.push(l[i][0], l[i][1])
        }
        c.prototype.skipToken = function(t) {
            var e, i, n = t.pos,
                r = this.ruler.getRules(""),
                o = r.length,
                l = t.md.options.maxNesting,
                c = t.cache;
            if (void 0 === c[n]) {
                if (t.level < l)
                    for (i = 0; i < o && (t.level++, e = r[i](t, !0), t.level--, !e); i++);
                else t.pos = t.posMax;
                e || t.pos++, c[n] = t.pos
            } else t.pos = c[n]
        }, c.prototype.tokenize = function(t) {
            for (var e, i, n = this.ruler.getRules(""), r = n.length, o = t.posMax, l = t.md.options.maxNesting; t.pos < o;) {
                if (t.level < l)
                    for (i = 0; i < r && !(e = n[i](t, !1)); i++);
                if (e) {
                    if (t.pos >= o) break
                } else t.pending += t.src[t.pos++]
            }
            t.pending && t.pushPending()
        }, c.prototype.parse = function(t, e, n, r) {
            var i, o, l, c = new this.State(t, e, n, r);
            for (this.tokenize(c), l = (o = this.ruler2.getRules("")).length, i = 0; i < l; i++) o[i](c)
        }, c.prototype.State = n(389), t.exports = c
    }, function(t, e, n) {
        "use strict";

        function r(t) {
            switch (t) {
                case 10:
                case 33:
                case 35:
                case 36:
                case 37:
                case 38:
                case 42:
                case 43:
                case 45:
                case 58:
                case 60:
                case 61:
                case 62:
                case 64:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 123:
                case 125:
                case 126:
                    return !0;
                default:
                    return !1
            }
        }
        t.exports = function(t, e) {
            for (var n = t.pos; n < t.posMax && !r(t.src.charCodeAt(n));) n++;
            return n !== t.pos && (e || (t.pending += t.src.slice(t.pos, n)), t.pos = n, !0)
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).isSpace;
        t.exports = function(t, e) {
            var n, o, l = t.pos;
            if (10 !== t.src.charCodeAt(l)) return !1;
            for (n = t.pending.length - 1, o = t.posMax, e || (n >= 0 && 32 === t.pending.charCodeAt(n) ? n >= 1 && 32 === t.pending.charCodeAt(n - 1) ? (t.pending = t.pending.replace(/ +$/, ""), t.push("hardbreak", "br", 0)) : (t.pending = t.pending.slice(0, -1), t.push("softbreak", "br", 0)) : t.push("softbreak", "br", 0)), l++; l < o && r(t.src.charCodeAt(l));) l++;
            return t.pos = l, !0
        }
    }, function(t, e, n) {
        "use strict";
        for (var r = n(9).isSpace, o = [], i = 0; i < 256; i++) o.push(0);
        "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach((function(t) {
            o[t.charCodeAt(0)] = 1
        })), t.exports = function(t, e) {
            var n, l = t.pos,
                c = t.posMax;
            if (92 !== t.src.charCodeAt(l)) return !1;
            if (++l < c) {
                if ((n = t.src.charCodeAt(l)) < 256 && 0 !== o[n]) return e || (t.pending += t.src[l]), t.pos += 2, !0;
                if (10 === n) {
                    for (e || t.push("hardbreak", "br", 0), l++; l < c && (n = t.src.charCodeAt(l), r(n));) l++;
                    return t.pos = l, !0
                }
            }
            return e || (t.pending += "\\"), t.pos++, !0
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t, e) {
            var n, r, marker, o, l, c, h = t.pos;
            if (96 !== t.src.charCodeAt(h)) return !1;
            for (n = h, h++, r = t.posMax; h < r && 96 === t.src.charCodeAt(h);) h++;
            for (marker = t.src.slice(n, h), o = l = h; - 1 !== (o = t.src.indexOf("`", l));) {
                for (l = o + 1; l < r && 96 === t.src.charCodeAt(l);) l++;
                if (l - o === marker.length) return e || ((c = t.push("code_inline", "code", 0)).markup = marker, c.content = t.src.slice(h, o).replace(/[ \n]+/g, " ").trim()), t.pos = l, !0
            }
            return e || (t.pending += marker), t.pos += marker.length, !0
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).normalizeReference,
            o = n(9).isSpace;
        t.exports = function(t, e) {
            var n, code, label, l, c, h, d, f, title, m = "",
                v = t.pos,
                y = t.posMax,
                _ = t.pos,
                x = !0;
            if (91 !== t.src.charCodeAt(t.pos)) return !1;
            if (c = t.pos + 1, (l = t.md.helpers.parseLinkLabel(t, t.pos, !0)) < 0) return !1;
            if ((h = l + 1) < y && 40 === t.src.charCodeAt(h)) {
                for (x = !1, h++; h < y && (code = t.src.charCodeAt(h), o(code) || 10 === code); h++);
                if (h >= y) return !1;
                for (_ = h, (d = t.md.helpers.parseLinkDestination(t.src, h, t.posMax)).ok && (m = t.md.normalizeLink(d.str), t.md.validateLink(m) ? h = d.pos : m = ""), _ = h; h < y && (code = t.src.charCodeAt(h), o(code) || 10 === code); h++);
                if (d = t.md.helpers.parseLinkTitle(t.src, h, t.posMax), h < y && _ !== h && d.ok)
                    for (title = d.str, h = d.pos; h < y && (code = t.src.charCodeAt(h), o(code) || 10 === code); h++);
                else title = "";
                (h >= y || 41 !== t.src.charCodeAt(h)) && (x = !0), h++
            }
            if (x) {
                if (void 0 === t.env.references) return !1;
                if (h < y && 91 === t.src.charCodeAt(h) ? (_ = h + 1, (h = t.md.helpers.parseLinkLabel(t, h)) >= 0 ? label = t.src.slice(_, h++) : h = l + 1) : h = l + 1, label || (label = t.src.slice(c, l)), !(f = t.env.references[r(label)])) return t.pos = v, !1;
                m = f.href, title = f.title
            }
            return e || (t.pos = c, t.posMax = l, t.push("link_open", "a", 1).attrs = n = [
                ["href", m]
            ], title && n.push(["title", title]), t.md.inline.tokenize(t), t.push("link_close", "a", -1)), t.pos = h, t.posMax = y, !0
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(9).normalizeReference,
            o = n(9).isSpace;
        t.exports = function(t, e) {
            var n, code, content, label, l, c, h, d, f, title, m, v, y, _ = "",
                x = t.pos,
                w = t.posMax;
            if (33 !== t.src.charCodeAt(t.pos)) return !1;
            if (91 !== t.src.charCodeAt(t.pos + 1)) return !1;
            if (c = t.pos + 2, (l = t.md.helpers.parseLinkLabel(t, t.pos + 1, !1)) < 0) return !1;
            if ((h = l + 1) < w && 40 === t.src.charCodeAt(h)) {
                for (h++; h < w && (code = t.src.charCodeAt(h), o(code) || 10 === code); h++);
                if (h >= w) return !1;
                for (y = h, (f = t.md.helpers.parseLinkDestination(t.src, h, t.posMax)).ok && (_ = t.md.normalizeLink(f.str), t.md.validateLink(_) ? h = f.pos : _ = ""), y = h; h < w && (code = t.src.charCodeAt(h), o(code) || 10 === code); h++);
                if (f = t.md.helpers.parseLinkTitle(t.src, h, t.posMax), h < w && y !== h && f.ok)
                    for (title = f.str, h = f.pos; h < w && (code = t.src.charCodeAt(h), o(code) || 10 === code); h++);
                else title = "";
                if (h >= w || 41 !== t.src.charCodeAt(h)) return t.pos = x, !1;
                h++
            } else {
                if (void 0 === t.env.references) return !1;
                if (h < w && 91 === t.src.charCodeAt(h) ? (y = h + 1, (h = t.md.helpers.parseLinkLabel(t, h)) >= 0 ? label = t.src.slice(y, h++) : h = l + 1) : h = l + 1, label || (label = t.src.slice(c, l)), !(d = t.env.references[r(label)])) return t.pos = x, !1;
                _ = d.href, title = d.title
            }
            return e || (content = t.src.slice(c, l), t.md.inline.parse(content, t.md, t.env, v = []), (m = t.push("image", "img", 0)).attrs = n = [
                ["src", _],
                ["alt", ""]
            ], m.children = v, m.content = content, title && n.push(["title", title])), t.pos = h, t.posMax = w, !0
        }
    }, function(t, e, n) {
        "use strict";
        var r = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/,
            o = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;
        t.exports = function(t, e) {
            var n, l, c, h, d, f, m = t.pos;
            return 60 === t.src.charCodeAt(m) && (!((n = t.src.slice(m)).indexOf(">") < 0) && (o.test(n) ? (h = (l = n.match(o))[0].slice(1, -1), d = t.md.normalizeLink(h), !!t.md.validateLink(d) && (e || ((f = t.push("link_open", "a", 1)).attrs = [
                ["href", d]
            ], f.markup = "autolink", f.info = "auto", (f = t.push("text", "", 0)).content = t.md.normalizeLinkText(h), (f = t.push("link_close", "a", -1)).markup = "autolink", f.info = "auto"), t.pos += l[0].length, !0)) : !!r.test(n) && (h = (c = n.match(r))[0].slice(1, -1), d = t.md.normalizeLink("mailto:" + h), !!t.md.validateLink(d) && (e || ((f = t.push("link_open", "a", 1)).attrs = [
                ["href", d]
            ], f.markup = "autolink", f.info = "auto", (f = t.push("text", "", 0)).content = t.md.normalizeLinkText(h), (f = t.push("link_close", "a", -1)).markup = "autolink", f.info = "auto"), t.pos += c[0].length, !0))))
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(233).HTML_TAG_RE;
        t.exports = function(t, e) {
            var n, o, l, c = t.pos;
            return !!t.md.options.html && (l = t.posMax, !(60 !== t.src.charCodeAt(c) || c + 2 >= l) && (!(33 !== (n = t.src.charCodeAt(c + 1)) && 63 !== n && 47 !== n && ! function(t) {
                var e = 32 | t;
                return e >= 97 && e <= 122
            }(n)) && (!!(o = t.src.slice(c).match(r)) && (e || (t.push("html_inline", "", 0).content = t.src.slice(c, c + o[0].length)), t.pos += o[0].length, !0))))
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(228),
            o = n(9).has,
            l = n(9).isValidEntityCode,
            c = n(9).fromCodePoint,
            h = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i,
            d = /^&([a-z][a-z0-9]{1,31});/i;
        t.exports = function(t, e) {
            var code, n, f = t.pos,
                m = t.posMax;
            if (38 !== t.src.charCodeAt(f)) return !1;
            if (f + 1 < m)
                if (35 === t.src.charCodeAt(f + 1)) {
                    if (n = t.src.slice(f).match(h)) return e || (code = "x" === n[1][0].toLowerCase() ? parseInt(n[1].slice(1), 16) : parseInt(n[1], 10), t.pending += l(code) ? c(code) : c(65533)), t.pos += n[0].length, !0
                } else if ((n = t.src.slice(f).match(d)) && o(r, n[1])) return e || (t.pending += r[n[1]]), t.pos += n[0].length, !0;
            return e || (t.pending += "&"), t.pos++, !0
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t) {
            var i, e, n, r, o = t.delimiters,
                l = t.delimiters.length;
            for (i = 0; i < l; i++)
                if ((n = o[i]).close)
                    for (e = i - n.jump - 1; e >= 0;) {
                        if ((r = o[e]).open && r.marker === n.marker && r.end < 0 && r.level === n.level)
                            if (!((r.close || n.open) && void 0 !== r.length && void 0 !== n.length && (r.length + n.length) % 3 == 0)) {
                                n.jump = i - e, n.open = !1, r.end = i, r.jump = 0;
                                break
                            }
                        e -= r.jump + 1
                    }
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t) {
            var e, n, r = 0,
                o = t.tokens,
                l = t.tokens.length;
            for (e = n = 0; e < l; e++) r += o[e].nesting, o[e].level = r, "text" === o[e].type && e + 1 < l && "text" === o[e + 1].type ? o[e + 1].content = o[e].content + o[e + 1].content : (e !== n && (o[n] = o[e]), n++);
            e !== n && (o.length = n)
        }
    }, function(t, e, n) {
        "use strict";
        var r = n(153),
            o = n(9).isWhiteSpace,
            l = n(9).isPunctChar,
            c = n(9).isMdAsciiPunct;

        function h(t, e, n, r) {
            this.src = t, this.env = n, this.md = e, this.tokens = r, this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = []
        }
        h.prototype.pushPending = function() {
            var t = new r("text", "", 0);
            return t.content = this.pending, t.level = this.pendingLevel, this.tokens.push(t), this.pending = "", t
        }, h.prototype.push = function(t, e, n) {
            this.pending && this.pushPending();
            var o = new r(t, e, n);
            return n < 0 && this.level--, o.level = this.level, n > 0 && this.level++, this.pendingLevel = this.level, this.tokens.push(o), o
        }, h.prototype.scanDelims = function(t, e) {
            var n, r, h, d, f, m, v, y, _, x = t,
                w = !0,
                M = !0,
                S = this.posMax,
                marker = this.src.charCodeAt(t);
            for (n = t > 0 ? this.src.charCodeAt(t - 1) : 32; x < S && this.src.charCodeAt(x) === marker;) x++;
            return h = x - t, r = x < S ? this.src.charCodeAt(x) : 32, v = c(n) || l(String.fromCharCode(n)), _ = c(r) || l(String.fromCharCode(r)), m = o(n), (y = o(r)) ? w = !1 : _ && (m || v || (w = !1)), m ? M = !1 : v && (y || _ || (M = !1)), e ? (d = w, f = M) : (d = w && (!M || v), f = M && (!w || _)), {
                can_open: d,
                can_close: f,
                length: h
            }
        }, h.prototype.Token = r, t.exports = h
    }, function(t, e, n) {
        "use strict";

        function r(t) {
            var e = Array.prototype.slice.call(arguments, 1);
            return e.forEach((function(source) {
                source && Object.keys(source).forEach((function(e) {
                    t[e] = source[e]
                }))
            })), t
        }

        function o(t) {
            return Object.prototype.toString.call(t)
        }

        function l(t) {
            return "[object Function]" === o(t)
        }

        function c(t) {
            return t.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
        }
        var h = {
            fuzzyLink: !0,
            fuzzyEmail: !0,
            fuzzyIP: !1
        };
        var d = {
                "http:": {
                    validate: function(text, t, e) {
                        var n = text.slice(t);
                        return e.re.http || (e.re.http = new RegExp("^\\/\\/" + e.re.src_auth + e.re.src_host_port_strict + e.re.src_path, "i")), e.re.http.test(n) ? n.match(e.re.http)[0].length : 0
                    }
                },
                "https:": "http:",
                "ftp:": "http:",
                "//": {
                    validate: function(text, t, e) {
                        var n = text.slice(t);
                        return e.re.no_http || (e.re.no_http = new RegExp("^" + e.re.src_auth + "(?:localhost|(?:(?:" + e.re.src_domain + ")\\.)+" + e.re.src_domain_root + ")" + e.re.src_port + e.re.src_host_terminator + e.re.src_path, "i")), e.re.no_http.test(n) ? t >= 3 && ":" === text[t - 3] || t >= 3 && "/" === text[t - 3] ? 0 : n.match(e.re.no_http)[0].length : 0
                    }
                },
                "mailto:": {
                    validate: function(text, t, e) {
                        var n = text.slice(t);
                        return e.re.mailto || (e.re.mailto = new RegExp("^" + e.re.src_email_name + "@" + e.re.src_host_strict, "i")), e.re.mailto.test(n) ? n.match(e.re.mailto)[0].length : 0
                    }
                }
            },
            f = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");

        function m(t) {
            var e = t.re = n(391)(t.__opts__),
                r = t.__tlds__.slice();

            function h(t) {
                return t.replace("%TLDS%", e.src_tlds)
            }
            t.onCompile(), t.__tlds_replaced__ || r.push("a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]"), r.push(e.src_xn), e.src_tlds = r.join("|"), e.email_fuzzy = RegExp(h(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(h(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(h(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(h(e.tpl_host_fuzzy_test), "i");
            var d = [];

            function f(t, e) {
                throw new Error('(LinkifyIt) Invalid schema "' + t + '": ' + e)
            }
            t.__compiled__ = {}, Object.keys(t.__schemas__).forEach((function(e) {
                var n = t.__schemas__[e];
                if (null !== n) {
                    var r = {
                        validate: null,
                        link: null
                    };
                    if (t.__compiled__[e] = r, "[object Object]" === o(n)) return ! function(t) {
                        return "[object RegExp]" === o(t)
                    }(n.validate) ? l(n.validate) ? r.validate = n.validate : f(e, n) : r.validate = function(t) {
                        return function(text, e) {
                            var n = text.slice(e);
                            return t.test(n) ? n.match(t)[0].length : 0
                        }
                    }(n.validate), void(l(n.normalize) ? r.normalize = n.normalize : n.normalize ? f(e, n) : r.normalize = function(t, e) {
                        e.normalize(t)
                    });
                    ! function(t) {
                        return "[object String]" === o(t)
                    }(n) ? f(e, n): d.push(e)
                }
            })), d.forEach((function(e) {
                t.__compiled__[t.__schemas__[e]] && (t.__compiled__[e].validate = t.__compiled__[t.__schemas__[e]].validate, t.__compiled__[e].normalize = t.__compiled__[t.__schemas__[e]].normalize)
            })), t.__compiled__[""] = {
                validate: null,
                normalize: function(t, e) {
                    e.normalize(t)
                }
            };
            var m = Object.keys(t.__compiled__).filter((function(e) {
                return e.length > 0 && t.__compiled__[e]
            })).map(c).join("|");
            t.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + e.src_ZPCc + "))(" + m + ")", "i"), t.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + e.src_ZPCc + "))(" + m + ")", "ig"), t.re.pretest = RegExp("(" + t.re.schema_test.source + ")|(" + t.re.host_fuzzy_test.source + ")|@", "i"),
                function(t) {
                    t.__index__ = -1, t.__text_cache__ = ""
                }(t)
        }

        function v(t, e) {
            var n = t.__index__,
                r = t.__last_index__,
                text = t.__text_cache__.slice(n, r);
            this.schema = t.__schema__.toLowerCase(), this.index = n + e, this.lastIndex = r + e, this.raw = text, this.text = text, this.url = text
        }

        function y(t, e) {
            var n = new v(t, e);
            return t.__compiled__[n.schema].normalize(n, t), n
        }

        function _(t, e) {
            if (!(this instanceof _)) return new _(t, e);
            var n;
            e || (n = t, Object.keys(n || {}).reduce((function(t, e) {
                return t || h.hasOwnProperty(e)
            }), !1) && (e = t, t = {})), this.__opts__ = r({}, h, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = r({}, d, t), this.__compiled__ = {}, this.__tlds__ = f, this.__tlds_replaced__ = !1, this.re = {}, m(this)
        }
        _.prototype.add = function(t, e) {
            return this.__schemas__[t] = e, m(this), this
        }, _.prototype.set = function(t) {
            return this.__opts__ = r(this.__opts__, t), this
        }, _.prototype.test = function(text) {
            if (this.__text_cache__ = text, this.__index__ = -1, !text.length) return !1;
            var t, e, n, r, o, l, c, h;
            if (this.re.schema_test.test(text))
                for ((c = this.re.schema_search).lastIndex = 0; null !== (t = c.exec(text));)
                    if (r = this.testSchemaAt(text, t[2], c.lastIndex)) {
                        this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + r;
                        break
                    }
            return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (h = text.search(this.re.host_fuzzy_test)) >= 0 && (this.__index__ < 0 || h < this.__index__) && null !== (e = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) && (o = e.index + e[1].length, (this.__index__ < 0 || o < this.__index__) && (this.__schema__ = "", this.__index__ = o, this.__last_index__ = e.index + e[0].length)), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && text.indexOf("@") >= 0 && null !== (n = text.match(this.re.email_fuzzy)) && (o = n.index + n[1].length, l = n.index + n[0].length, (this.__index__ < 0 || o < this.__index__ || o === this.__index__ && l > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = o, this.__last_index__ = l)), this.__index__ >= 0
        }, _.prototype.pretest = function(text) {
            return this.re.pretest.test(text)
        }, _.prototype.testSchemaAt = function(text, t, e) {
            return this.__compiled__[t.toLowerCase()] ? this.__compiled__[t.toLowerCase()].validate(text, e, this) : 0
        }, _.prototype.match = function(text) {
            var t = 0,
                e = [];
            this.__index__ >= 0 && this.__text_cache__ === text && (e.push(y(this, t)), t = this.__last_index__);
            for (var n = t ? text.slice(t) : text; this.test(n);) e.push(y(this, t)), n = n.slice(this.__last_index__), t += this.__last_index__;
            return e.length ? e : null
        }, _.prototype.tlds = function(t, e) {
            return t = Array.isArray(t) ? t : [t], e ? (this.__tlds__ = this.__tlds__.concat(t).sort().filter((function(t, e, n) {
                return t !== n[e - 1]
            })).reverse(), m(this), this) : (this.__tlds__ = t.slice(), this.__tlds_replaced__ = !0, m(this), this)
        }, _.prototype.normalize = function(t) {
            t.schema || (t.url = "http://" + t.url), "mailto:" !== t.schema || /^mailto:/i.test(t.url) || (t.url = "mailto:" + t.url)
        }, _.prototype.onCompile = function() {}, t.exports = _
    }, function(t, e, n) {
        "use strict";
        t.exports = function(t) {
            var e = {};
            e.src_Any = n(230).source, e.src_Cc = n(231).source, e.src_Z = n(232).source, e.src_P = n(151).source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
            return e.src_pseudo_letter = "(?:(?![><]|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|[><]|" + e.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + "[><]|[()[\\]{}.,\"'?!\\-]).|\\[(?:(?!" + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + '|["]).)+\\"|\\\'(?:(?!' + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-]).|\\.{2,4}[a-zA-Z0-9%/]|\\.(?!" + e.src_ZCc + "|[.]).|" + (t && t["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + "\\,(?!" + e.src_ZCc + ").|\\!(?!" + e.src_ZCc + "|[!]).|\\?(?!" + e.src_ZCc + "|[?]).)+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = '(^|[><]|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + e.src_ZPCc + "))((?![$+<=>^`|])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + e.src_ZPCc + "))((?![$+<=>^`|])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e
        }
    }, function(t, e, n) {
        (function(t, r) {
            var o;
            ! function(l) {
                e && e.nodeType, t && t.nodeType;
                var c = "object" == typeof r && r;
                c.global !== c && c.window !== c && c.self;
                var h, d = 2147483647,
                    base = 36,
                    f = /^xn--/,
                    m = /[^\x20-\x7E]/,
                    v = /[\x2E\u3002\uFF0E\uFF61]/g,
                    y = {
                        overflow: "Overflow: input needs wider integers to process",
                        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                        "invalid-input": "Invalid input"
                    },
                    _ = Math.floor,
                    x = String.fromCharCode;

                function w(t) {
                    throw new RangeError(y[t])
                }

                function map(t, e) {
                    for (var n = t.length, r = []; n--;) r[n] = e(t[n]);
                    return r
                }

                function M(t, e) {
                    var n = t.split("@"),
                        r = "";
                    return n.length > 1 && (r = n[0] + "@", t = n[1]), r + map((t = t.replace(v, ".")).split("."), e).join(".")
                }

                function S(t) {
                    for (var e, n, output = [], r = 0, o = t.length; r < o;)(e = t.charCodeAt(r++)) >= 55296 && e <= 56319 && r < o ? 56320 == (64512 & (n = t.charCodeAt(r++))) ? output.push(((1023 & e) << 10) + (1023 & n) + 65536) : (output.push(e), r--) : output.push(e);
                    return output
                }

                function T(t) {
                    return map(t, (function(t) {
                        var output = "";
                        return t > 65535 && (output += x((t -= 65536) >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), output += x(t)
                    })).join("")
                }

                function E(t, e) {
                    return t + 22 + 75 * (t < 26) - ((0 != e) << 5)
                }

                function A(t, e, n) {
                    var r = 0;
                    for (t = n ? _(t / 700) : t >> 1, t += _(t / e); t > 455; r += base) t = _(t / 35);
                    return _(r + 36 * t / (t + 38))
                }

                function C(input) {
                    var t, e, n, r, o, l, c, h, f, m, v, output = [],
                        y = input.length,
                        i = 0,
                        x = 128,
                        M = 72;
                    for ((e = input.lastIndexOf("-")) < 0 && (e = 0), n = 0; n < e; ++n) input.charCodeAt(n) >= 128 && w("not-basic"), output.push(input.charCodeAt(n));
                    for (r = e > 0 ? e + 1 : 0; r < y;) {
                        for (o = i, l = 1, c = base; r >= y && w("invalid-input"), ((h = (v = input.charCodeAt(r++)) - 48 < 10 ? v - 22 : v - 65 < 26 ? v - 65 : v - 97 < 26 ? v - 97 : base) >= base || h > _((d - i) / l)) && w("overflow"), i += h * l, !(h < (f = c <= M ? 1 : c >= M + 26 ? 26 : c - M)); c += base) l > _(d / (m = base - f)) && w("overflow"), l *= m;
                        M = A(i - o, t = output.length + 1, 0 == o), _(i / t) > d - x && w("overflow"), x += _(i / t), i %= t, output.splice(i++, 0, x)
                    }
                    return T(output)
                }

                function L(input) {
                    var t, e, n, r, o, l, c, q, h, f, m, v, y, M, T, output = [];
                    for (v = (input = S(input)).length, t = 128, e = 0, o = 72, l = 0; l < v; ++l)(m = input[l]) < 128 && output.push(x(m));
                    for (n = r = output.length, r && output.push("-"); n < v;) {
                        for (c = d, l = 0; l < v; ++l)(m = input[l]) >= t && m < c && (c = m);
                        for (c - t > _((d - e) / (y = n + 1)) && w("overflow"), e += (c - t) * y, t = c, l = 0; l < v; ++l)
                            if ((m = input[l]) < t && ++e > d && w("overflow"), m == t) {
                                for (q = e, h = base; !(q < (f = h <= o ? 1 : h >= o + 26 ? 26 : h - o)); h += base) T = q - f, M = base - f, output.push(x(E(f + T % M, 0))), q = _(T / M);
                                output.push(x(E(q, 0))), o = A(e, y, n == r), e = 0, ++n
                            }++e, ++t
                    }
                    return output.join("")
                }
                h = {
                    version: "1.4.1",
                    ucs2: {
                        decode: S,
                        encode: T
                    },
                    decode: C,
                    encode: L,
                    toASCII: function(input) {
                        return M(input, (function(t) {
                            return m.test(t) ? "xn--" + L(t) : t
                        }))
                    },
                    toUnicode: function(input) {
                        return M(input, (function(t) {
                            return f.test(t) ? C(t.slice(4).toLowerCase()) : t
                        }))
                    }
                }, void 0 === (o = function() {
                    return h
                }.call(e, n, e, t)) || (t.exports = o)
            }()
        }).call(this, n(393)(t), n(51))
    }, , function(t, e, n) {
        "use strict";
        t.exports = {
            options: {
                html: !1,
                xhtmlOut: !1,
                breaks: !1,
                langPrefix: "language-",
                linkify: !1,
                typographer: !1,
                quotes: "",
                highlight: null,
                maxNesting: 100
            },
            components: {
                core: {},
                block: {},
                inline: {}
            }
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = {
            options: {
                html: !1,
                xhtmlOut: !1,
                breaks: !1,
                langPrefix: "language-",
                linkify: !1,
                typographer: !1,
                quotes: "",
                highlight: null,
                maxNesting: 20
            },
            components: {
                core: {
                    rules: ["normalize", "block", "inline"]
                },
                block: {
                    rules: ["paragraph"]
                },
                inline: {
                    rules: ["text"],
                    rules2: ["balance_pairs", "text_collapse"]
                }
            }
        }
    }, function(t, e, n) {
        "use strict";
        t.exports = {
            options: {
                html: !0,
                xhtmlOut: !0,
                breaks: !1,
                langPrefix: "language-",
                linkify: !1,
                typographer: !1,
                quotes: "",
                highlight: null,
                maxNesting: 20
            },
            components: {
                core: {
                    rules: ["normalize", "block", "inline"]
                },
                block: {
                    rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"]
                },
                inline: {
                    rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"],
                    rules2: ["balance_pairs", "emphasis", "text_collapse"]
                }
            }
        }
    }, , , function(t, e, n) {
        "use strict";
        var r = n(237),
            o = n(239),
            l = n(242),
            c = n(243),
            h = n(246),
            html = n(401);
        t.exports = r([l, o, c, h, html])
    }, function(t, e) {
        t.exports = function() {
            for (var t = {}, i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var e in source) n.call(source, e) && (t[e] = source[e])
            }
            return t
        };
        var n = Object.prototype.hasOwnProperty
    }, function(t, e, n) {
        "use strict";
        var r = n(116),
            o = n(76),
            l = n(244),
            c = r.boolean,
            h = r.overloadedBoolean,
            d = r.booleanish,
            f = r.number,
            m = r.spaceSeparated,
            v = r.commaSeparated;
        t.exports = o({
            space: "html",
            attributes: {
                acceptcharset: "accept-charset",
                classname: "class",
                htmlfor: "for",
                httpequiv: "http-equiv"
            },
            transform: l,
            mustUseProperty: ["checked", "multiple", "muted", "selected"],
            properties: {
                abbr: null,
                accept: v,
                acceptCharset: m,
                accessKey: m,
                action: null,
                allow: null,
                allowFullScreen: c,
                allowPaymentRequest: c,
                allowUserMedia: c,
                alt: null,
                as: null,
                async: c,
                autoCapitalize: null,
                autoComplete: m,
                autoFocus: c,
                autoPlay: c,
                capture: c,
                charSet: null,
                checked: c,
                cite: null,
                className: m,
                cols: f,
                colSpan: null,
                content: null,
                contentEditable: d,
                controls: c,
                controlsList: m,
                coords: f | v,
                crossOrigin: null,
                data: null,
                dateTime: null,
                decoding: null,
                default: c,
                defer: c,
                dir: null,
                dirName: null,
                disabled: c,
                download: h,
                draggable: d,
                encType: null,
                enterKeyHint: null,
                form: null,
                formAction: null,
                formEncType: null,
                formMethod: null,
                formNoValidate: c,
                formTarget: null,
                headers: m,
                height: f,
                hidden: c,
                high: f,
                href: null,
                hrefLang: null,
                htmlFor: m,
                httpEquiv: m,
                id: null,
                imageSizes: null,
                imageSrcSet: v,
                inputMode: null,
                integrity: null,
                is: null,
                isMap: c,
                itemId: null,
                itemProp: m,
                itemRef: m,
                itemScope: c,
                itemType: m,
                kind: null,
                label: null,
                lang: null,
                language: null,
                list: null,
                loading: null,
                loop: c,
                low: f,
                manifest: null,
                max: null,
                maxLength: f,
                media: null,
                method: null,
                min: null,
                minLength: f,
                multiple: c,
                muted: c,
                name: null,
                nonce: null,
                noModule: c,
                noValidate: c,
                onAbort: null,
                onAfterPrint: null,
                onAuxClick: null,
                onBeforePrint: null,
                onBeforeUnload: null,
                onBlur: null,
                onCancel: null,
                onCanPlay: null,
                onCanPlayThrough: null,
                onChange: null,
                onClick: null,
                onClose: null,
                onContextMenu: null,
                onCopy: null,
                onCueChange: null,
                onCut: null,
                onDblClick: null,
                onDrag: null,
                onDragEnd: null,
                onDragEnter: null,
                onDragExit: null,
                onDragLeave: null,
                onDragOver: null,
                onDragStart: null,
                onDrop: null,
                onDurationChange: null,
                onEmptied: null,
                onEnded: null,
                onError: null,
                onFocus: null,
                onFormData: null,
                onHashChange: null,
                onInput: null,
                onInvalid: null,
                onKeyDown: null,
                onKeyPress: null,
                onKeyUp: null,
                onLanguageChange: null,
                onLoad: null,
                onLoadedData: null,
                onLoadedMetadata: null,
                onLoadEnd: null,
                onLoadStart: null,
                onMessage: null,
                onMessageError: null,
                onMouseDown: null,
                onMouseEnter: null,
                onMouseLeave: null,
                onMouseMove: null,
                onMouseOut: null,
                onMouseOver: null,
                onMouseUp: null,
                onOffline: null,
                onOnline: null,
                onPageHide: null,
                onPageShow: null,
                onPaste: null,
                onPause: null,
                onPlay: null,
                onPlaying: null,
                onPopState: null,
                onProgress: null,
                onRateChange: null,
                onRejectionHandled: null,
                onReset: null,
                onResize: null,
                onScroll: null,
                onSecurityPolicyViolation: null,
                onSeeked: null,
                onSeeking: null,
                onSelect: null,
                onSlotChange: null,
                onStalled: null,
                onStorage: null,
                onSubmit: null,
                onSuspend: null,
                onTimeUpdate: null,
                onToggle: null,
                onUnhandledRejection: null,
                onUnload: null,
                onVolumeChange: null,
                onWaiting: null,
                onWheel: null,
                open: c,
                optimum: f,
                pattern: null,
                ping: m,
                placeholder: null,
                playsInline: c,
                poster: null,
                preload: null,
                readOnly: c,
                referrerPolicy: null,
                rel: m,
                required: c,
                reversed: c,
                rows: f,
                rowSpan: f,
                sandbox: m,
                scope: null,
                scoped: c,
                seamless: c,
                selected: c,
                shape: null,
                size: f,
                sizes: null,
                slot: null,
                span: f,
                spellCheck: d,
                src: null,
                srcDoc: null,
                srcLang: null,
                srcSet: v,
                start: f,
                step: null,
                style: null,
                tabIndex: f,
                target: null,
                title: null,
                translate: null,
                type: null,
                typeMustMatch: c,
                useMap: null,
                value: d,
                width: f,
                wrap: null,
                align: null,
                aLink: null,
                archive: m,
                axis: null,
                background: null,
                bgColor: null,
                border: f,
                borderColor: null,
                bottomMargin: f,
                cellPadding: null,
                cellSpacing: null,
                char: null,
                charOff: null,
                classId: null,
                clear: null,
                code: null,
                codeBase: null,
                codeType: null,
                color: null,
                compact: c,
                declare: c,
                event: null,
                face: null,
                frame: null,
                frameBorder: null,
                hSpace: f,
                leftMargin: f,
                link: null,
                longDesc: null,
                lowSrc: null,
                marginHeight: f,
                marginWidth: f,
                noResize: c,
                noHref: c,
                noShade: c,
                noWrap: c,
                object: null,
                profile: null,
                prompt: null,
                rev: null,
                rightMargin: f,
                rules: null,
                scheme: null,
                scrolling: d,
                standby: null,
                summary: null,
                text: null,
                topMargin: f,
                valueType: null,
                version: null,
                vAlign: null,
                vLink: null,
                vSpace: f,
                allowTransparency: null,
                autoCorrect: null,
                autoSave: null,
                disablePictureInPicture: c,
                disableRemotePlayback: c,
                prefix: null,
                property: null,
                results: f,
                security: null,
                unselectable: null
            }
        })
    }, function(t, e, n) {
        "use strict";
        var r = n(237),
            o = n(239),
            l = n(242),
            c = n(243),
            h = n(246),
            svg = n(403);
        t.exports = r([l, o, c, h, svg])
    }, function(t, e, n) {
        "use strict";
        var r = n(116),
            o = n(76),
            l = n(245),
            c = r.boolean,
            h = r.number,
            d = r.spaceSeparated,
            f = r.commaSeparated,
            m = r.commaOrSpaceSeparated;
        t.exports = o({
            space: "svg",
            attributes: {
                accentHeight: "accent-height",
                alignmentBaseline: "alignment-baseline",
                arabicForm: "arabic-form",
                baselineShift: "baseline-shift",
                capHeight: "cap-height",
                className: "class",
                clipPath: "clip-path",
                clipRule: "clip-rule",
                colorInterpolation: "color-interpolation",
                colorInterpolationFilters: "color-interpolation-filters",
                colorProfile: "color-profile",
                colorRendering: "color-rendering",
                crossOrigin: "crossorigin",
                dataType: "datatype",
                dominantBaseline: "dominant-baseline",
                enableBackground: "enable-background",
                fillOpacity: "fill-opacity",
                fillRule: "fill-rule",
                floodColor: "flood-color",
                floodOpacity: "flood-opacity",
                fontFamily: "font-family",
                fontSize: "font-size",
                fontSizeAdjust: "font-size-adjust",
                fontStretch: "font-stretch",
                fontStyle: "font-style",
                fontVariant: "font-variant",
                fontWeight: "font-weight",
                glyphName: "glyph-name",
                glyphOrientationHorizontal: "glyph-orientation-horizontal",
                glyphOrientationVertical: "glyph-orientation-vertical",
                hrefLang: "hreflang",
                horizAdvX: "horiz-adv-x",
                horizOriginX: "horiz-origin-x",
                horizOriginY: "horiz-origin-y",
                imageRendering: "image-rendering",
                letterSpacing: "letter-spacing",
                lightingColor: "lighting-color",
                markerEnd: "marker-end",
                markerMid: "marker-mid",
                markerStart: "marker-start",
                navDown: "nav-down",
                navDownLeft: "nav-down-left",
                navDownRight: "nav-down-right",
                navLeft: "nav-left",
                navNext: "nav-next",
                navPrev: "nav-prev",
                navRight: "nav-right",
                navUp: "nav-up",
                navUpLeft: "nav-up-left",
                navUpRight: "nav-up-right",
                onAbort: "onabort",
                onActivate: "onactivate",
                onAfterPrint: "onafterprint",
                onBeforePrint: "onbeforeprint",
                onBegin: "onbegin",
                onCancel: "oncancel",
                onCanPlay: "oncanplay",
                onCanPlayThrough: "oncanplaythrough",
                onChange: "onchange",
                onClick: "onclick",
                onClose: "onclose",
                onCopy: "oncopy",
                onCueChange: "oncuechange",
                onCut: "oncut",
                onDblClick: "ondblclick",
                onDrag: "ondrag",
                onDragEnd: "ondragend",
                onDragEnter: "ondragenter",
                onDragExit: "ondragexit",
                onDragLeave: "ondragleave",
                onDragOver: "ondragover",
                onDragStart: "ondragstart",
                onDrop: "ondrop",
                onDurationChange: "ondurationchange",
                onEmptied: "onemptied",
                onEnd: "onend",
                onEnded: "onended",
                onError: "onerror",
                onFocus: "onfocus",
                onFocusIn: "onfocusin",
                onFocusOut: "onfocusout",
                onHashChange: "onhashchange",
                onInput: "oninput",
                onInvalid: "oninvalid",
                onKeyDown: "onkeydown",
                onKeyPress: "onkeypress",
                onKeyUp: "onkeyup",
                onLoad: "onload",
                onLoadedData: "onloadeddata",
                onLoadedMetadata: "onloadedmetadata",
                onLoadStart: "onloadstart",
                onMessage: "onmessage",
                onMouseDown: "onmousedown",
                onMouseEnter: "onmouseenter",
                onMouseLeave: "onmouseleave",
                onMouseMove: "onmousemove",
                onMouseOut: "onmouseout",
                onMouseOver: "onmouseover",
                onMouseUp: "onmouseup",
                onMouseWheel: "onmousewheel",
                onOffline: "onoffline",
                onOnline: "ononline",
                onPageHide: "onpagehide",
                onPageShow: "onpageshow",
                onPaste: "onpaste",
                onPause: "onpause",
                onPlay: "onplay",
                onPlaying: "onplaying",
                onPopState: "onpopstate",
                onProgress: "onprogress",
                onRateChange: "onratechange",
                onRepeat: "onrepeat",
                onReset: "onreset",
                onResize: "onresize",
                onScroll: "onscroll",
                onSeeked: "onseeked",
                onSeeking: "onseeking",
                onSelect: "onselect",
                onShow: "onshow",
                onStalled: "onstalled",
                onStorage: "onstorage",
                onSubmit: "onsubmit",
                onSuspend: "onsuspend",
                onTimeUpdate: "ontimeupdate",
                onToggle: "ontoggle",
                onUnload: "onunload",
                onVolumeChange: "onvolumechange",
                onWaiting: "onwaiting",
                onZoom: "onzoom",
                overlinePosition: "overline-position",
                overlineThickness: "overline-thickness",
                paintOrder: "paint-order",
                panose1: "panose-1",
                pointerEvents: "pointer-events",
                referrerPolicy: "referrerpolicy",
                renderingIntent: "rendering-intent",
                shapeRendering: "shape-rendering",
                stopColor: "stop-color",
                stopOpacity: "stop-opacity",
                strikethroughPosition: "strikethrough-position",
                strikethroughThickness: "strikethrough-thickness",
                strokeDashArray: "stroke-dasharray",
                strokeDashOffset: "stroke-dashoffset",
                strokeLineCap: "stroke-linecap",
                strokeLineJoin: "stroke-linejoin",
                strokeMiterLimit: "stroke-miterlimit",
                strokeOpacity: "stroke-opacity",
                strokeWidth: "stroke-width",
                tabIndex: "tabindex",
                textAnchor: "text-anchor",
                textDecoration: "text-decoration",
                textRendering: "text-rendering",
                typeOf: "typeof",
                underlinePosition: "underline-position",
                underlineThickness: "underline-thickness",
                unicodeBidi: "unicode-bidi",
                unicodeRange: "unicode-range",
                unitsPerEm: "units-per-em",
                vAlphabetic: "v-alphabetic",
                vHanging: "v-hanging",
                vIdeographic: "v-ideographic",
                vMathematical: "v-mathematical",
                vectorEffect: "vector-effect",
                vertAdvY: "vert-adv-y",
                vertOriginX: "vert-origin-x",
                vertOriginY: "vert-origin-y",
                wordSpacing: "word-spacing",
                writingMode: "writing-mode",
                xHeight: "x-height",
                playbackOrder: "playbackorder",
                timelineBegin: "timelinebegin"
            },
            transform: l,
            properties: {
                about: m,
                accentHeight: h,
                accumulate: null,
                additive: null,
                alignmentBaseline: null,
                alphabetic: h,
                amplitude: h,
                arabicForm: null,
                ascent: h,
                attributeName: null,
                attributeType: null,
                azimuth: h,
                bandwidth: null,
                baselineShift: null,
                baseFrequency: null,
                baseProfile: null,
                bbox: null,
                begin: null,
                bias: h,
                by: null,
                calcMode: null,
                capHeight: h,
                className: d,
                clip: null,
                clipPath: null,
                clipPathUnits: null,
                clipRule: null,
                color: null,
                colorInterpolation: null,
                colorInterpolationFilters: null,
                colorProfile: null,
                colorRendering: null,
                content: null,
                contentScriptType: null,
                contentStyleType: null,
                crossOrigin: null,
                cursor: null,
                cx: null,
                cy: null,
                d: null,
                dataType: null,
                defaultAction: null,
                descent: h,
                diffuseConstant: h,
                direction: null,
                display: null,
                dur: null,
                divisor: h,
                dominantBaseline: null,
                download: c,
                dx: null,
                dy: null,
                edgeMode: null,
                editable: null,
                elevation: h,
                enableBackground: null,
                end: null,
                event: null,
                exponent: h,
                externalResourcesRequired: null,
                fill: null,
                fillOpacity: h,
                fillRule: null,
                filter: null,
                filterRes: null,
                filterUnits: null,
                floodColor: null,
                floodOpacity: null,
                focusable: null,
                focusHighlight: null,
                fontFamily: null,
                fontSize: null,
                fontSizeAdjust: null,
                fontStretch: null,
                fontStyle: null,
                fontVariant: null,
                fontWeight: null,
                format: null,
                fr: null,
                from: null,
                fx: null,
                fy: null,
                g1: f,
                g2: f,
                glyphName: f,
                glyphOrientationHorizontal: null,
                glyphOrientationVertical: null,
                glyphRef: null,
                gradientTransform: null,
                gradientUnits: null,
                handler: null,
                hanging: h,
                hatchContentUnits: null,
                hatchUnits: null,
                height: null,
                href: null,
                hrefLang: null,
                horizAdvX: h,
                horizOriginX: h,
                horizOriginY: h,
                id: null,
                ideographic: h,
                imageRendering: null,
                initialVisibility: null,
                in: null,
                in2: null,
                intercept: h,
                k: h,
                k1: h,
                k2: h,
                k3: h,
                k4: h,
                kernelMatrix: m,
                kernelUnitLength: null,
                keyPoints: null,
                keySplines: null,
                keyTimes: null,
                kerning: null,
                lang: null,
                lengthAdjust: null,
                letterSpacing: null,
                lightingColor: null,
                limitingConeAngle: h,
                local: null,
                markerEnd: null,
                markerMid: null,
                markerStart: null,
                markerHeight: null,
                markerUnits: null,
                markerWidth: null,
                mask: null,
                maskContentUnits: null,
                maskUnits: null,
                mathematical: null,
                max: null,
                media: null,
                mediaCharacterEncoding: null,
                mediaContentEncodings: null,
                mediaSize: h,
                mediaTime: null,
                method: null,
                min: null,
                mode: null,
                name: null,
                navDown: null,
                navDownLeft: null,
                navDownRight: null,
                navLeft: null,
                navNext: null,
                navPrev: null,
                navRight: null,
                navUp: null,
                navUpLeft: null,
                navUpRight: null,
                numOctaves: null,
                observer: null,
                offset: null,
                onAbort: null,
                onActivate: null,
                onAfterPrint: null,
                onBeforePrint: null,
                onBegin: null,
                onCancel: null,
                onCanPlay: null,
                onCanPlayThrough: null,
                onChange: null,
                onClick: null,
                onClose: null,
                onCopy: null,
                onCueChange: null,
                onCut: null,
                onDblClick: null,
                onDrag: null,
                onDragEnd: null,
                onDragEnter: null,
                onDragExit: null,
                onDragLeave: null,
                onDragOver: null,
                onDragStart: null,
                onDrop: null,
                onDurationChange: null,
                onEmptied: null,
                onEnd: null,
                onEnded: null,
                onError: null,
                onFocus: null,
                onFocusIn: null,
                onFocusOut: null,
                onHashChange: null,
                onInput: null,
                onInvalid: null,
                onKeyDown: null,
                onKeyPress: null,
                onKeyUp: null,
                onLoad: null,
                onLoadedData: null,
                onLoadedMetadata: null,
                onLoadStart: null,
                onMessage: null,
                onMouseDown: null,
                onMouseEnter: null,
                onMouseLeave: null,
                onMouseMove: null,
                onMouseOut: null,
                onMouseOver: null,
                onMouseUp: null,
                onMouseWheel: null,
                onOffline: null,
                onOnline: null,
                onPageHide: null,
                onPageShow: null,
                onPaste: null,
                onPause: null,
                onPlay: null,
                onPlaying: null,
                onPopState: null,
                onProgress: null,
                onRateChange: null,
                onRepeat: null,
                onReset: null,
                onResize: null,
                onScroll: null,
                onSeeked: null,
                onSeeking: null,
                onSelect: null,
                onShow: null,
                onStalled: null,
                onStorage: null,
                onSubmit: null,
                onSuspend: null,
                onTimeUpdate: null,
                onToggle: null,
                onUnload: null,
                onVolumeChange: null,
                onWaiting: null,
                onZoom: null,
                opacity: null,
                operator: null,
                order: null,
                orient: null,
                orientation: null,
                origin: null,
                overflow: null,
                overlay: null,
                overlinePosition: h,
                overlineThickness: h,
                paintOrder: null,
                panose1: null,
                path: null,
                pathLength: h,
                patternContentUnits: null,
                patternTransform: null,
                patternUnits: null,
                phase: null,
                ping: d,
                pitch: null,
                playbackOrder: null,
                pointerEvents: null,
                points: null,
                pointsAtX: h,
                pointsAtY: h,
                pointsAtZ: h,
                preserveAlpha: null,
                preserveAspectRatio: null,
                primitiveUnits: null,
                propagate: null,
                property: m,
                r: null,
                radius: null,
                referrerPolicy: null,
                refX: null,
                refY: null,
                rel: m,
                rev: m,
                renderingIntent: null,
                repeatCount: null,
                repeatDur: null,
                requiredExtensions: m,
                requiredFeatures: m,
                requiredFonts: m,
                requiredFormats: m,
                resource: null,
                restart: null,
                result: null,
                rotate: null,
                rx: null,
                ry: null,
                scale: null,
                seed: null,
                shapeRendering: null,
                side: null,
                slope: null,
                snapshotTime: null,
                specularConstant: h,
                specularExponent: h,
                spreadMethod: null,
                spacing: null,
                startOffset: null,
                stdDeviation: null,
                stemh: null,
                stemv: null,
                stitchTiles: null,
                stopColor: null,
                stopOpacity: null,
                strikethroughPosition: h,
                strikethroughThickness: h,
                string: null,
                stroke: null,
                strokeDashArray: m,
                strokeDashOffset: null,
                strokeLineCap: null,
                strokeLineJoin: null,
                strokeMiterLimit: h,
                strokeOpacity: h,
                strokeWidth: null,
                style: null,
                surfaceScale: h,
                syncBehavior: null,
                syncBehaviorDefault: null,
                syncMaster: null,
                syncTolerance: null,
                syncToleranceDefault: null,
                systemLanguage: m,
                tabIndex: h,
                tableValues: null,
                target: null,
                targetX: h,
                targetY: h,
                textAnchor: null,
                textDecoration: null,
                textRendering: null,
                textLength: null,
                timelineBegin: null,
                title: null,
                transformBehavior: null,
                type: null,
                typeOf: m,
                to: null,
                transform: null,
                u1: null,
                u2: null,
                underlinePosition: h,
                underlineThickness: h,
                unicode: null,
                unicodeBidi: null,
                unicodeRange: null,
                unitsPerEm: h,
                values: null,
                vAlphabetic: h,
                vMathematical: h,
                vectorEffect: null,
                vHanging: h,
                vIdeographic: h,
                version: null,
                vertAdvY: h,
                vertOriginX: h,
                vertOriginY: h,
                viewBox: null,
                viewTarget: null,
                visibility: null,
                width: null,
                widths: null,
                wordSpacing: null,
                writingMode: null,
                x: null,
                x1: null,
                x2: null,
                xChannelSelector: null,
                xHeight: h,
                y: null,
                y1: null,
                y2: null,
                yChannelSelector: null,
                z: null,
                zoomAndPan: null
            }
        })
    }, function(t, e, n) {
        "use strict";
        var r = n(154),
            o = n(240),
            l = n(241),
            data = "data";
        t.exports = function(t, e) {
            var n = r(e),
                v = e,
                y = l;
            if (n in t.normal) return t.property[t.normal[n]];
            n.length > 4 && n.slice(0, 4) === data && c.test(e) && ("-" === e.charAt(4) ? v = function(t) {
                var e = t.slice(5).replace(h, m);
                return data + e.charAt(0).toUpperCase() + e.slice(1)
            }(e) : e = function(t) {
                var e = t.slice(4);
                if (h.test(e)) return t;
                "-" !== (e = e.replace(d, f)).charAt(0) && (e = "-" + e);
                return data + e
            }(e), y = o);
            return new y(v, e)
        };
        var c = /^data[-\w.:]+$/i,
            h = /-[a-z]/g,
            d = /[A-Z]/g;

        function f(t) {
            return "-" + t.toLowerCase()
        }

        function m(t) {
            return t.charAt(1).toUpperCase()
        }
    }]
]);